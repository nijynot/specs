<!DOCTYPE html>
<!-- Built with spec-md -->
<html><head><meta charset="utf-8"><title>Filecoin Spec</title><style>body {
  color: #333333;
  font: 13pt/18pt Cambria, "Palatino Linotype", Palatino, "Liberation Serif", serif;
  margin: 6rem auto 3rem;
  max-width: 780px;
}


/* Links */

a {
  color: #3B5998;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}


/* Section headers */

h1, h2, h3, h4, h5, h6, h7, h8 {
  margin: 3rem 0 1em;
  position: relative;
}

h1 {
  font-size: 1.5em;
  margin: 8rem 0 2em;
}

h2 {
  font-size: 1.45em;
  margin: 8rem 0 1em;
}

h3 {
  font-size: 1.30em;
  margin: 5rem 0 1em;
}

h4 {
  font-size: 1.20em;
}

h5 {
  font-size: 1.12em;
}

h6, h7, h8 {
  font-size: 1.1em;
}

section .spec-secid {
  margin-right: 1ex;
  position: absolute;
  right: 100%;
  text-align: right;
  white-space: nowrap;
}

footer {
  font-size: 75%;
  opacity: 0.5;
  text-align: center;
  margin-top: 12rem;
}


/* Table of contents */

.spec-toc {
  margin: 1rem 0 3rem;
}

.spec-toc .title {
  content: 'Contents';
  display: block;
  font-weight: bold;
  margin: 3rem 0 1rem;
}

.spec-toc .spec-secid {
  margin-right: 1ex;
}

.spec-toc ol {
  list-style: none;
  padding-left: 0;
}

.spec-toc ol ol {
  list-style: none;
  padding-left: 2ex;
}

.spec-toc li {
  position: relative;
  padding: 5px 0 0 30px;
  margin: -5px 0 0 -30px;
}

.spec-toc a {
  color: #333333;
}

.spec-toc a:hover {
  text-decoration: none;
}

.spec-toc a .spec-secid {
  color: #3B5998;
}

.spec-toc a:hover .spec-secid {
  text-decoration: underline;
}

.spec-toc .toggle {
  display: none;
}

.spec-toc .toggle + label {
  cursor: pointer;
  left: 10px;
  opacity: 1;
  padding: 3px 5px 3px 6px;
  position: absolute;
  top: 8px;
  transform: rotate(0deg);
  transition: all 0.18s ease-in-out;
}

.spec-toc .toggle + label:after {
  border-color: transparent transparent transparent #bbc;
  border-style: solid;
  border-width: 6px 0 6px 7px;
  content: ' ';
  display: block;
  height: 0;
  width: 0;
}

.spec-toc .toggle:checked + label {
  transform: rotate(90deg);
}

.spec-toc li:not(:hover) > .toggle:checked + label {
  opacity: 0;
}

.spec-toc .toggle:not(:checked) ~ ol {
  max-height: 0;
  overflow: hidden;
}


/* Sidebar */

.spec-sidebar-toggle {
  display: none;
}

.spec-sidebar-toggle + label {
  position: fixed;
  right: 0;
  top: 0;
  padding: 10px 15px;
  font-size: 30px;
  color: rgba(0,0,0,0.7);
  z-index: 2;
  cursor: pointer;
  user-select: none;
  -moz-user-select: none;
  -webkit-user-select: none;
  -ms-user-select: none;
}

.spec-sidebar {
  display: none;
  position: fixed;
  right: 0;
  top: 0;
  width: 320px;
  font-size: 80%;
  overflow-y: scroll;
  height: 100%;
  padding: 0 0 5rem 30px;
  box-sizing: border-box;
  background: #f0f0f0;
}

.spec-sidebar-toggle:checked ~ .spec-sidebar {
  display: block;
  box-shadow:
    -1px 0 rgba(0,0,0,0.12),
    -4px 0 8px -2px rgba(0,0,0,0.05);
}

.spec-sidebar .viewing > a:after {
  color: #8b9;
  content: '\2022';
  margin-left: 1ex;
}

@media (min-width: 1240px) {
  .spec-sidebar-toggle + label {
    display: none;
  }

  .spec-sidebar {
    display: block;
    box-shadow:
      inset 1px 0 rgba(0,0,0,0.05),
      inset 4px 0 8px -2px rgba(0,0,0,0.08) !important;
  }

  body {
    padding-right: 300px;
  }
}


/* Notes */

.spec-note {
  background: #FEFEF3;
  border-left: solid 4px #F4E925;
  margin: 1em -1em;
  min-width: 416px;
  padding: 1ex 1em 1ex calc(1em - 4px);
  width: -moz-fit-content;
  width: -webkit-fit-content;
  width: fit-content;
}

.spec-note::before {
  color: #6C6613;
  content: 'Note';
  display: block;
  font: italic 11pt/18pt Cambria, "Palatino Linotype", Palatino, "Liberation Serif", serif;
  opacity: 0.6;
  user-select: none;
}


/* Todos */

.spec-todo {
  color: #666666;
  margin: 1em 0 1em 5em;
  min-height: 1em;
}

.spec-todo::before {
  content: 'todo';
  display: block;
  float: left;
  margin-left: -5em;
  text-transform: uppercase;
}

/* Index table */

.spec-index ol {
  list-style-type: none;
  margin: 0 0 0 2rem;
  padding: 0;
  column-width: 210px;
  column-gap: 2rem;
}

.spec-index ol li {
  width: min-content;
}

/* Code */

code {
  background: #FAFAFA;
  font-family: Consolas, Monaco, monospace;
  font-size: 85%;
  font-weight: inherit;
  margin: -2px -1px;
  padding: 3px 3px;
  white-space: pre;
}

pre code {
  background: none;
  font-weight: inherit;
  margin: 0;
  padding: 0;
}

pre {
  background: #FAFAFA;
  border-left: solid 4px #E9E9E9;
  margin: 1em -1em;
  min-width: 40ch;
  padding: 1ex 1em 1ex calc(1em - 4px);
  width: -moz-fit-content;
  width: -webkit-fit-content;
  width: fit-content;
}

.spec-example {
  background: #FAFAFF;
  border-left: solid 4px #BBBBFF;
}

.spec-counter-example {
  background: #FFFAFA;
  border-left: solid 4px #FFBBBB;
}

.spec-example > a,
.spec-counter-example > a {
  display: block;
  font: italic 11pt/18pt Cambria, "Palatino Linotype", Palatino, "Liberation Serif", serif;
  opacity: 0.6;
  user-select: none;
}

.spec-counter-example > a {
  color: #98593b;
}


/* Tables */

table {
  border-collapse: collapse;
}

th {
  background-color: #F9F9F9;
}

td, th {
  border: 1px solid #D0D0D0;
  padding: 0.4em;
  vertical-align: baseline;
}


/* Edits */

ins {
  background-color: rgba(0, 200, 30, 0.08);
  text-decoration: none;
}

del {
  background-color: rgba(200, 0, 0, 0.08);
}

.spec-added, .spec-removed {
  border-left: 4px solid;
  margin-left: -18px;
  padding-left: 14px;
}

.spec-added {
  border-color: #396;
}

.spec-removed {
  border-color: #933;
  text-decoration: line-through;
}


/* Values */

.spec-keyword {
  font-weight: bold;
}

.spec-string {
  font-family: Consolas, Monaco, monospace;
  white-space: pre;
}

var {
  font-style: italic;
}

*[data-name] {
  transition: 0.15s background ease-out;
  border-radius: 2px;
  padding: 0 3px;
  margin: 0 -3px;
}


/* Grammar semantics, algorithms and calls */

.spec-semantic,
.spec-algo {
  margin: 1rem 0 1rem 2rem;
}

.spec-semantic > .spec-rhs {
  display: inline-block;
  margin-left: 1ex;
}

.spec-semantic > .spec-nt::after,
.spec-algo > .spec-call:first-child::after {
  content: ':';
  font-style: normal;
  font-weight: bold;
  margin-left: 1ex;
}

.spec-semantic ol, .spec-semantic ol ol ol ol,
.spec-algo ol, .spec-algo ol ol ol ol {
  list-style-type: decimal;
}

.spec-semantic ol ol, .spec-semantic ol ol ol ol ol,
.spec-algo ol ol, .spec-algo ol ol ol ol ol {
  list-style-type: lower-alpha;
}

.spec-semantic ol ol ol, .spec-semantic ol ol ol ol ol ol,
.spec-algo ol ol ol, .spec-algo ol ol ol ol ol ol {
  list-style-type: lower-roman;
}

.spec-call > a {
  color: inherit;
}


/* Grammar productions */

.spec-production {
  margin: 1rem 0 1rem 2rem;
}

.spec-production > .spec-nt::after {
  content: ':';
  font-style: normal;
  font-weight: bold;
  margin: 0 1ex;
}

.spec-semantic.d2 > .spec-nt::after,
.spec-production.d2 > .spec-nt::after {
  content: '::';
}

.spec-semantic.d3 > .spec-nt::after,
.spec-production.d3 > .spec-nt::after {
  content: ':::';
}

.spec-rhs {
  margin-left: 2rem;
}

.spec-oneof {
  display: inline;
}

.spec-oneof::before {
  content: 'one of';
  font-style: normal;
  font-weight: bold;
}

.spec-oneof > table {
  margin-left: 2rem;
}

.spec-oneof .spec-rhs {
  border: none;
  margin: 0;
  padding: 0 0.5em;
  vertical-align: baseline;
}

.spec-rhs .spec-constrained:not(:first-child),
.spec-rhs .spec-quantified:not(:first-child),
.spec-rhs .spec-nt:not(:first-child),
.spec-rhs .spec-t:not(:first-child),
.spec-rhs .spec-rx:not(:first-child),
.spec-rhs .spec-prose:not(:first-child),
.spec-rhs .spec-empty:not(:first-child),
.spec-rhs .spec-lookahead:not(:first-child) {
  margin-left: 1ex;
}

.spec-condition {
  font-size: 85%;
}

.spec-condition::before {
  content: '[+'
}

.spec-condition.not::before {
  content: '[~'
}

.spec-condition::after {
  content: ']'
}

.spec-empty,
.spec-prose {
  color: #666666;
}

.spec-nt {
  font-style: italic;
}

.spec-nt > a {
  color: inherit;
}

.spec-quantifiers,
.spec-params {
  font-size: 65%;
  font-style: normal;
  vertical-align: sub;
}

.spec-quantifier.list {
  color: #3348D3;
}

.spec-quantifier.optional {
  color: #83238E;
}

.spec-params,
.spec-condition {
  color: #1C7758;
}

.spec-params::before {
  content: '[';
}

.spec-params::after {
  content: ']';
}

.spec-quantifier:not(:last-child)::after,
.spec-param:not(:last-child)::after {
  color: #666666;
  content: ', ';
}

.spec-param.conditional::before {
  content: '?';
}

.spec-t, .spec-rx {
  color: #333333;
  font-family: monospace;
  font-weight: bold;
}

.spec-butnot::before {
  color: #666666;
  content: 'but not';
  font-family: Cambria, "Palatino Linotype", Palatino, "Liberation Serif", serif;
  font-weight: normal;
  margin-right: 1ex;
}

.spec-butnot > *:not(:first-child)::before {
  color: #666666;
  content: 'or';
  font-family: Cambria, "Palatino Linotype", Palatino, "Liberation Serif", serif;
  font-weight: normal;
  margin-right: 1ex;
}

.spec-rhs .spec-oneof::before,
.spec-rhs .spec-butnot::before {
  margin-left: 1ex;
}

.spec-lookahead > * {
  margin: 0 !important;
}

.spec-lookahead > *:not(:first-child)::before {
  color: #666666;
  content: ', ';
  font-family: Cambria, "Palatino Linotype", Palatino, "Liberation Serif", serif;
  font-style: normal;
  font-weight: normal;
}

.spec-lookahead::before {
  color: #666666;
  content: '[lookahead = ';
  font-family: Cambria, "Palatino Linotype", Palatino, "Liberation Serif", serif;
  font-style: normal;
  font-weight: normal;
}

.spec-lookahead.not::before {
  content: '[lookahead \2260  ';
}

.spec-lookahead.set::before {
  content: '[lookahead \2208  {';
  margin-right: 0;
}

.spec-lookahead.set.not::before {
  content: '[lookahead \2209  {';
}

.spec-lookahead::after {
  color: #666666;
  content: ']';
}

.spec-lookahead.set::after {
  content: '}]';
}
</style><style>/* Copied from node_modules/prismjs/themes/prism.css */
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
	color: black;
	background: none;
	text-shadow: 0 1px white;
	font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
	text-align: left;
	white-space: pre;
	word-spacing: normal;
	word-break: normal;
	word-wrap: normal;
	line-height: 1.5;

	-moz-tab-size: 4;
	-o-tab-size: 4;
	tab-size: 4;

	-webkit-hyphens: none;
	-moz-hyphens: none;
	-ms-hyphens: none;
	hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
	text-shadow: none;
	background: #b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
	text-shadow: none;
	background: #b3d4fc;
}

@media print {
	code[class*="language-"],
	pre[class*="language-"] {
		text-shadow: none;
	}
}

/* Code blocks */
pre[class*="language-"] {
	padding: 1em;
	margin: .5em 0;
	overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
	background: #f5f2f0;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
	padding: .1em;
	border-radius: .3em;
	white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
	color: slategray;
}

.token.punctuation {
	color: #999;
}

.namespace {
	opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
	color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
	color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
	color: #a67f59;
	background: hsla(0, 0%, 100%, .5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
	color: #07a;
}

.token.function {
	color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
	color: #e90;
}

.token.important,
.token.bold {
	font-weight: bold;
}
.token.italic {
	font-style: italic;
}

.token.entity {
	cursor: help;
}
</style><script>(function (){
var styleSheet = document.getElementsByTagName('style')[0].sheet;
var ruleIndex;

function removeHighlight() {
  if (ruleIndex) {
    styleSheet.deleteRule(ruleIndex);
    ruleIndex = void 0;
  }
}

function highlightKeyword(name) {
  removeHighlight();
  ruleIndex = styleSheet.insertRule(
    '*[data-name="' + name + '"] { background: #FBF8D0; }',
    styleSheet.cssRules.length
  );
}

document.documentElement.addEventListener('mouseover', function (event) {
  var nameAttribute = event.target.attributes['data-name'];
  if (nameAttribute) {
    highlightKeyword(nameAttribute.value);
  }
});

document.documentElement.addEventListener('mouseout', removeHighlight);
})()</script></head><body><header><h1>Filecoin Spec</h1><section id="intro"><p><em>Living Standard, 18 March 2019</em></p><p><strong>Abstract</strong></p><p>Filecoin is a distributed storage network, with shared state persisted to a blockchain.</p><p><strong>Introduction</strong></p><p>This is the official Filecoin protocol specification. It is a work in progress. While reading, if you notice any discrepancies, or issues, please open an issue on the <a href="https://github.com/filecoin-project/specs">specs repo</a>.</p><p>This collection of pages specify the protocols comprising the Filecoin network. The goal of these specs is to provide sufficient detail that another implementation, written using only this document as reference, can be fully compatible with <code>go-filecoin</code> peers, but this is still a work in progress.</p></section><nav class="spec-toc"><div class="title">Contents</div><ol><li><a href="#sec-Overview"><span class="spec-secid">1</span>Overview</a><input hidden class="toggle" type="checkbox" checked id="_toggle_1" /><label for="_toggle_1"></label><ol><li><a href="#sec-Message-Transport"><span class="spec-secid">1.1</span>Message Transport</a></li></ol></li><li><a href="#sec-Filecoin-Spec-Process-v0-"><span class="spec-secid">2</span>Filecoin Spec Process (v0)</a><input hidden class="toggle" type="checkbox" checked id="_toggle_2" /><label for="_toggle_2"></label><ol><li><a href="#sec--Catch-Up-Mode"><span class="spec-secid">2.1</span>&#x27;Catch Up&#x27; Mode</a></li><li><a href="#sec-Proposals---Drafts---Spec"><span class="spec-secid">2.2</span>Proposals -&gt; Drafts -&gt; Spec</a><input hidden class="toggle" type="checkbox" checked id="_toggle_2.2" /><label for="_toggle_2.2"></label><ol><li><a href="#sec-On-merging"><span class="spec-secid">2.2.1</span>On merging</a></li><li><a href="#sec-Issues"><span class="spec-secid">2.2.2</span>Issues</a></li></ol></li></ol></li><li><a href="#sec-Filecoin-Node-Operation"><span class="spec-secid">3</span>Filecoin Node Operation</a><input hidden class="toggle" type="checkbox" checked id="_toggle_3" /><label for="_toggle_3"></label><ol><li><a href="#sec-Chain-Validation"><span class="spec-secid">3.1</span>Chain Validation</a></li><li><a href="#sec-MemPool-Maintenance"><span class="spec-secid">3.2</span>MemPool Maintenance</a></li><li><a href="#sec-Handshaking"><span class="spec-secid">3.3</span>Handshaking</a></li><li><a href="#sec-DHT-for-Peer-Routing"><span class="spec-secid">3.4</span>DHT for Peer Routing</a></li><li><a href="#sec-Bitswap-for-data-requests"><span class="spec-secid">3.5</span>Bitswap for data requests</a></li><li><a href="#sec-Filecoin-Node-Operation.Mining"><span class="spec-secid">3.6</span>Mining</a><input hidden class="toggle" type="checkbox" checked id="_toggle_3.6" /><label for="_toggle_3.6"></label><ol><li><a href="#sec-Filecoin-Node-Operation.Mining.Storage"><span class="spec-secid">3.6.1</span>Storage</a><input hidden class="toggle" type="checkbox" checked id="_toggle_3.6.1" /><label for="_toggle_3.6.1"></label><ol><li><a href="#sec-Accept-Deals"><span class="spec-secid">3.6.1.1</span>Accept Deals</a></li><li><a href="#sec-Prove-Storage"><span class="spec-secid">3.6.1.2</span>Prove Storage</a></li><li><a href="#sec-Extend-the-Blockchain"><span class="spec-secid">3.6.1.3</span>Extend the Blockchain</a></li></ol></li><li><a href="#sec-Retrieval"><span class="spec-secid">3.6.2</span>Retrieval</a></li></ol></li></ol></li><li><a href="#sec-Chain-Syncing"><span class="spec-secid">4</span>Chain Syncing</a><input hidden class="toggle" type="checkbox" checked id="_toggle_4" /><label for="_toggle_4"></label><ol><li><a href="#sec-What-is-chain-syncing-in-Filecoin-"><span class="spec-secid">4.1</span>What is chain syncing in Filecoin?</a></li><li><a href="#sec-Chain-Syncing.Interface"><span class="spec-secid">4.2</span>Interface</a></li><li><a href="#sec-General-Operation"><span class="spec-secid">4.3</span>General Operation</a></li><li><a href="#sec-Syncing-Mode"><span class="spec-secid">4.4</span>Syncing Mode</a></li><li><a href="#sec-Caught-Up-Mode"><span class="spec-secid">4.5</span>Caught Up Mode</a></li><li><a href="#sec-Maintaining-a-fresh-Peer-Set"><span class="spec-secid">4.6</span>Maintaining a fresh Peer Set</a></li><li><a href="#sec-Chain-Syncing.Dependencies"><span class="spec-secid">4.7</span>Dependencies</a></li><li><a href="#sec-Chain-Syncing.Open-Questions"><span class="spec-secid">4.8</span>Open Questions</a></li></ol></li><li><a href="#sec-The-Filecoin-Storage-Market"><span class="spec-secid">5</span>The Filecoin Storage Market</a><input hidden class="toggle" type="checkbox" checked id="_toggle_5" /><label for="_toggle_5"></label><ol><li><a href="#sec-What-is-the-Filecoin-Storage-Market"><span class="spec-secid">5.1</span>What is the Filecoin Storage Market</a><input hidden class="toggle" type="checkbox" checked id="_toggle_5.1" /><label for="_toggle_5.1"></label><ol><li><a href="#sec-Visualization-of-the-Filecoin-Storage-Market"><span class="spec-secid">5.1.1</span>Visualization of the Filecoin Storage Market</a></li></ol></li><li><a href="#sec-The-Market-Interface"><span class="spec-secid">5.2</span>The Market Interface</a></li><li><a href="#sec-The-Filecoin-Storage-Market-Operation"><span class="spec-secid">5.3</span>The Filecoin Storage Market Operation</a><input hidden class="toggle" type="checkbox" checked id="_toggle_5.3" /><label for="_toggle_5.3"></label><ol><li><a href="#sec-Market-Datastructures"><span class="spec-secid">5.3.1</span>Market Datastructures</a></li></ol></li><li><a href="#sec-Market-Flow"><span class="spec-secid">5.4</span>Market Flow</a><input hidden class="toggle" type="checkbox" checked id="_toggle_5.4" /><label for="_toggle_5.4"></label><ol><li><a href="#sec-Before-Deal"><span class="spec-secid">5.4.1</span>Before Deal</a></li><li><a href="#sec-Market-Flow.Deal"><span class="spec-secid">5.4.2</span>Deal</a></li></ol></li><li><a href="#sec-The-Power-Table"><span class="spec-secid">5.5</span>The Power Table</a><input hidden class="toggle" type="checkbox" checked id="_toggle_5.5" /><label for="_toggle_5.5"></label><ol><li><a href="#sec-Power-Updates"><span class="spec-secid">5.5.1</span>Power Updates</a></li></ol></li><li><a href="#sec-The-Filecoin-Storage-Market.Payments"><span class="spec-secid">5.6</span>Payments</a></li><li><a href="#sec-Future-Protocol-Improvements"><span class="spec-secid">5.7</span>Future Protocol Improvements</a></li><li><a href="#sec-Open-questions"><span class="spec-secid">5.8</span>Open questions</a></li></ol></li><li><a href="#sec--Retrieval-Market-V0"><span class="spec-secid">6</span>`Retrieval Market` V0</a><input hidden class="toggle" type="checkbox" checked id="_toggle_6" /><label for="_toggle_6"></label><ol><li><a href="#sec-What-is-the-Retrieval-Market-"><span class="spec-secid">6.1</span>What is the `Retrieval Market`</a></li><li><a href="#sec-What-the-Retrieval-Market-affects"><span class="spec-secid">6.2</span>What the `Retrieval Market` affects</a></li><li><a href="#sec--Retrieval-Market-V0.Dependencies"><span class="spec-secid">6.3</span>Dependencies</a></li><li><a href="#sec-Components"><span class="spec-secid">6.4</span>Components</a></li><li><a href="#sec-Retrieval-V0-libp2p-Services"><span class="spec-secid">6.5</span>Retrieval V0 `libp2p` Services</a></li><li><a href="#sec-Chain-Based-Content-Routing"><span class="spec-secid">6.6</span>Chain Based Content Routing</a></li><li><a href="#sec-Retrieval-Market-Commands"><span class="spec-secid">6.7</span>Retrieval Market Commands</a></li></ol></li><li><a href="#sec-undefined.Payments"><span class="spec-secid">7</span>Payments</a><input hidden class="toggle" type="checkbox" checked id="_toggle_7" /><label for="_toggle_7"></label><ol><li><a href="#sec-What-are-payments"><span class="spec-secid">7.1</span>What are payments</a></li><li><a href="#sec-What-payments-affect"><span class="spec-secid">7.2</span>What payments affect</a></li><li><a href="#sec-undefined.Payments.Dependencies"><span class="spec-secid">7.3</span>Dependencies</a></li><li><a href="#sec-Miners-Claiming-Earnings"><span class="spec-secid">7.4</span>Miners Claiming Earnings</a></li><li><a href="#sec-Payment-Channels"><span class="spec-secid">7.5</span>Payment Channels</a><input hidden class="toggle" type="checkbox" checked id="_toggle_7.5" /><label for="_toggle_7.5"></label><ol><li><a href="#sec-Multi-Lane-Payment-Channel"><span class="spec-secid">7.5.1</span>Multi-Lane Payment Channel</a></li><li><a href="#sec-Payment-Channel-Reconciliation"><span class="spec-secid">7.5.2</span>Payment Channel Reconciliation</a></li></ol></li></ol></li><li><a href="#sec-Payment-Reconciliation"><span class="spec-secid">8</span>Payment Reconciliation</a><input hidden class="toggle" type="checkbox" checked id="_toggle_8" /><label for="_toggle_8"></label><ol><li><a href="#sec-Storage-Miner-Payments"><span class="spec-secid">8.1</span>Storage Miner Payments</a></li></ol></li><li><a href="#sec-undefined.Mining"><span class="spec-secid">9</span>Mining</a><input hidden class="toggle" type="checkbox" checked id="_toggle_9" /><label for="_toggle_9"></label><ol><li><a href="#sec-What-is-the-Filecoin-Mining-Process"><span class="spec-secid">9.1</span>What is the Filecoin Mining Process</a></li><li><a href="#sec-The-Miner-Actor"><span class="spec-secid">9.2</span>The Miner Actor</a><input hidden class="toggle" type="checkbox" checked id="_toggle_9.2" /><label for="_toggle_9.2"></label><ol><li><a href="#sec-Owner-Worker-distinction"><span class="spec-secid">9.2.1</span>Owner Worker distinction</a></li><li><a href="#sec-Storage-Mining-Cycle"><span class="spec-secid">9.2.2</span>Storage Mining Cycle</a><input hidden class="toggle" type="checkbox" checked id="_toggle_9.2.2" /><label for="_toggle_9.2.2"></label><ol><li><a href="#sec-Step-0-Registration"><span class="spec-secid">9.2.2.1</span>Step 0: Registration</a></li><li><a href="#sec-Step-1-Commit"><span class="spec-secid">9.2.2.2</span>Step 1: Commit</a></li><li><a href="#sec-Step-2-Proving-Storage-PoSt-creation-"><span class="spec-secid">9.2.2.3</span>Step 2: Proving Storage (PoSt creation)</a></li><li><a href="#sec-Step-3-PoSt-Submission"><span class="spec-secid">9.2.2.4</span>Step 3: PoSt Submission</a></li></ol></li><li><a href="#sec-Stop-Mining"><span class="spec-secid">9.2.3</span>Stop Mining</a></li><li><a href="#sec-The-Miner-Actor.Faults"><span class="spec-secid">9.2.4</span>Faults</a></li><li><a href="#sec-On-Being-Slashed-WIP-needs-discussion-"><span class="spec-secid">9.2.5</span>On Being Slashed (WIP, needs discussion)</a></li></ol></li><li><a href="#sec-Mining-Blocks"><span class="spec-secid">9.3</span>Mining Blocks</a><input hidden class="toggle" type="checkbox" checked id="_toggle_9.3" /><label for="_toggle_9.3"></label><ol><li><a href="#sec-Receiving-Blocks"><span class="spec-secid">9.3.1</span>Receiving Blocks</a></li><li><a href="#sec-Block-Validation"><span class="spec-secid">9.3.2</span>Block Validation</a></li><li><a href="#sec-Ticket-Generation"><span class="spec-secid">9.3.3</span>Ticket Generation</a></li><li><a href="#sec-Scratching-a-losing-ticket"><span class="spec-secid">9.3.4</span>Scratching a losing ticket</a></li><li><a href="#sec-Block-Creation"><span class="spec-secid">9.3.5</span>Block Creation</a><input hidden class="toggle" type="checkbox" checked id="_toggle_9.3.5" /><label for="_toggle_9.3.5"></label><ol><li><a href="#sec-Block-Broadcast"><span class="spec-secid">9.3.5.1</span>Block Broadcast</a></li></ol></li><li><a href="#sec-Block-Rewards"><span class="spec-secid">9.3.6</span>Block Rewards</a></li></ol></li><li><a href="#sec-undefined.Mining.Open-Questions"><span class="spec-secid">9.4</span>Open Questions</a></li><li><a href="#sec-Future-Work"><span class="spec-secid">9.5</span>Future Work</a></li></ol></li><li><a href="#sec-Expected-Consensus"><span class="spec-secid">10</span>Expected Consensus</a><input hidden class="toggle" type="checkbox" checked id="_toggle_10" /><label for="_toggle_10"></label><ol><li><a href="#sec-Secret-Leader-Election"><span class="spec-secid">10.1</span>Secret Leader Election</a><input hidden class="toggle" type="checkbox" checked id="_toggle_10.1" /><label for="_toggle_10.1"></label><ol><li><a href="#sec-Tickets"><span class="spec-secid">10.1.1</span>Tickets</a><input hidden class="toggle" type="checkbox" checked id="_toggle_10.1.1" /><label for="_toggle_10.1.1"></label><ol><li><a href="#sec-Ticket-generation"><span class="spec-secid">10.1.1.1</span>Ticket generation</a></li><li><a href="#sec-Checking-election-results"><span class="spec-secid">10.1.1.2</span>Checking election results</a></li></ol></li><li><a href="#sec-Losing-Tickets"><span class="spec-secid">10.1.2</span>Losing Tickets</a></li><li><a href="#sec-Block-Generation"><span class="spec-secid">10.1.3</span>Block Generation</a></li></ol></li><li><a href="#sec-Chain-Selection"><span class="spec-secid">10.2</span>Chain Selection</a><input hidden class="toggle" type="checkbox" checked id="_toggle_10.2" /><label for="_toggle_10.2"></label><ol><li><a href="#sec-Tipsets"><span class="spec-secid">10.2.1</span>Tipsets</a></li><li><a href="#sec-Chain-Weighting"><span class="spec-secid">10.2.2</span>Chain Weighting</a></li><li><a href="#sec-Selecting-between-TipSets-with-equal-weight"><span class="spec-secid">10.2.3</span>Selecting between TipSets with equal weight</a></li><li><a href="#sec-Chain-Selection.Slashing"><span class="spec-secid">10.2.4</span>Slashing</a></li><li><a href="#sec-ChainTipsManager"><span class="spec-secid">10.2.5</span>ChainTipsManager</a></li></ol></li><li><a href="#sec-Implementation-Notes"><span class="spec-secid">10.3</span>Implementation Notes</a></li><li><a href="#sec-Expected-Consensus.Open-Questions"><span class="spec-secid">10.4</span>Open Questions</a></li></ol></li><li><a href="#sec-The-Filecoin-State-Machine"><span class="spec-secid">11</span>The Filecoin State Machine</a><input hidden class="toggle" type="checkbox" checked id="_toggle_11" /><label for="_toggle_11"></label><ol><li><a href="#sec-Method-Invocation"><span class="spec-secid">11.1</span>Method Invocation</a></li><li><a href="#sec-State-Representation"><span class="spec-secid">11.2</span>State Representation</a></li><li><a href="#sec-Execution-Calling-a-method-on-an-Actor-"><span class="spec-secid">11.3</span>Execution (Calling a method on an Actor)</a><input hidden class="toggle" type="checkbox" checked id="_toggle_11.3" /><label for="_toggle_11.3"></label><ol><li><a href="#sec-Receipts"><span class="spec-secid">11.3.1</span>Receipts</a></li><li><a href="#sec-Execution-Calling-a-method-on-an-Actor-.Storage"><span class="spec-secid">11.3.2</span>Storage</a></li></ol></li></ol></li><li><a href="#sec-Filecoin-State-Machine-Actors"><span class="spec-secid">12</span>Filecoin State Machine Actors</a><input hidden class="toggle" type="checkbox" checked id="_toggle_12" /><label for="_toggle_12"></label><ol><li><a href="#sec-Built-In-Actors"><span class="spec-secid">12.1</span>Built In Actors</a></li><li><a href="#sec-Init-Actor"><span class="spec-secid">12.2</span>Init Actor</a><input hidden class="toggle" type="checkbox" checked id="_toggle_12.2" /><label for="_toggle_12.2"></label><ol><li><a href="#sec-Init-Actor.Code-Cid"><span class="spec-secid">12.2.1</span>Code Cid</a></li><li><a href="#sec--Exec-code-Cid-params-Param-Address-"><span class="spec-secid">12.2.2</span>`Exec(code Cid, params []Param) Address`</a><input hidden class="toggle" type="checkbox" checked id="_toggle_12.2.2" /><label for="_toggle_12.2.2"></label><ol><li><a href="#sec--Exec-code-Cid-params-Param-Address-.Parameters"><span class="spec-secid">12.2.2.1</span>Parameters</a></li></ol></li><li><a href="#sec--GetIdForAddress-addr-Address-BigInt-"><span class="spec-secid">12.2.3</span>`GetIdForAddress(addr Address) BigInt`</a><input hidden class="toggle" type="checkbox" checked id="_toggle_12.2.3" /><label for="_toggle_12.2.3"></label><ol><li><a href="#sec--GetIdForAddress-addr-Address-BigInt-.Parameters"><span class="spec-secid">12.2.3.1</span>Parameters</a></li></ol></li></ol></li><li><a href="#sec-Account-Actor"><span class="spec-secid">12.3</span>Account Actor</a><input hidden class="toggle" type="checkbox" checked id="_toggle_12.3" /><label for="_toggle_12.3"></label><ol><li><a href="#sec-Account-Actor.Code-Cid"><span class="spec-secid">12.3.1</span>Code Cid</a></li></ol></li><li><a href="#sec-Storage-Market-Actor"><span class="spec-secid">12.4</span>Storage Market Actor</a><input hidden class="toggle" type="checkbox" checked id="_toggle_12.4" /><label for="_toggle_12.4"></label><ol><li><a href="#sec-Storage-Market-Actor.Code-Cid"><span class="spec-secid">12.4.1</span>Code Cid</a><input hidden class="toggle" type="checkbox" checked id="_toggle_12.4.1" /><label for="_toggle_12.4.1"></label><ol><li><a href="#sec-CreateStorageMiner"><span class="spec-secid">12.4.1.1</span>CreateStorageMiner</a></li></ol></li><li><a href="#sec-SlashConsensusFault"><span class="spec-secid">12.4.2</span>SlashConsensusFault</a></li><li><a href="#sec-UpdateStorage"><span class="spec-secid">12.4.3</span>UpdateStorage</a></li><li><a href="#sec-GetTotalStorage"><span class="spec-secid">12.4.4</span>GetTotalStorage</a></li></ol></li><li><a href="#sec-Storage-Miner-Actor"><span class="spec-secid">12.5</span>Storage Miner Actor</a><input hidden class="toggle" type="checkbox" checked id="_toggle_12.5" /><label for="_toggle_12.5"></label><ol><li><a href="#sec-Storage-Miner-Actor.Code-Cid"><span class="spec-secid">12.5.1</span>Code Cid</a></li><li><a href="#sec-Storage-Miner-Actor.Constructor"><span class="spec-secid">12.5.2</span>Constructor</a></li><li><a href="#sec-AddAsk"><span class="spec-secid">12.5.3</span>AddAsk</a></li><li><a href="#sec-CommitSector"><span class="spec-secid">12.5.4</span>CommitSector</a></li><li><a href="#sec-SubmitPoSt"><span class="spec-secid">12.5.5</span>SubmitPoSt</a></li><li><a href="#sec-IncreasePledge"><span class="spec-secid">12.5.6</span>IncreasePledge</a></li><li><a href="#sec-SlashStorageFault"><span class="spec-secid">12.5.7</span>SlashStorageFault</a></li><li><a href="#sec-GetCurrentProvingSet"><span class="spec-secid">12.5.8</span>GetCurrentProvingSet</a></li><li><a href="#sec-ArbitrateDeal"><span class="spec-secid">12.5.9</span>ArbitrateDeal</a></li><li><a href="#sec-DePledge"><span class="spec-secid">12.5.10</span>DePledge</a></li><li><a href="#sec-GetOwner"><span class="spec-secid">12.5.11</span>GetOwner</a></li><li><a href="#sec-GetWorkerAddr"><span class="spec-secid">12.5.12</span>GetWorkerAddr</a></li><li><a href="#sec-GetPower"><span class="spec-secid">12.5.13</span>GetPower</a></li><li><a href="#sec-GetKey"><span class="spec-secid">12.5.14</span>GetKey</a></li><li><a href="#sec-GetPeerID"><span class="spec-secid">12.5.15</span>GetPeerID</a></li><li><a href="#sec-GetSectorSize"><span class="spec-secid">12.5.16</span>GetSectorSize</a></li><li><a href="#sec-UpdatePeerID"><span class="spec-secid">12.5.17</span>UpdatePeerID</a></li></ol></li><li><a href="#sec-Payment-Channel-Broker-Actor"><span class="spec-secid">12.6</span>Payment Channel Broker Actor</a></li><li><a href="#sec-Multisig-Account-Actor"><span class="spec-secid">12.7</span>Multisig Account Actor</a><input hidden class="toggle" type="checkbox" checked id="_toggle_12.7" /><label for="_toggle_12.7"></label><ol><li><a href="#sec-Multisig-Account-Actor.State"><span class="spec-secid">12.7.1</span>State</a></li><li><a href="#sec-Multisig-Account-Actor.Code-Cid"><span class="spec-secid">12.7.2</span>Code Cid</a><input hidden class="toggle" type="checkbox" checked id="_toggle_12.7.2" /><label for="_toggle_12.7.2"></label><ol><li><a href="#sec-Multisig-Account-Actor.Code-Cid.Constructor"><span class="spec-secid">12.7.2.1</span>Constructor</a></li><li><a href="#sec-Multisig-Account-Actor.Code-Cid.Parameters"><span class="spec-secid">12.7.2.2</span>Parameters</a></li></ol></li><li><a href="#sec-Propose"><span class="spec-secid">12.7.3</span>Propose</a></li><li><a href="#sec-Approve"><span class="spec-secid">12.7.4</span>Approve</a></li><li><a href="#sec-Cancel"><span class="spec-secid">12.7.5</span>Cancel</a></li><li><a href="#sec-ClearCompleted"><span class="spec-secid">12.7.6</span>ClearCompleted</a></li><li><a href="#sec-AddSigner"><span class="spec-secid">12.7.7</span>AddSigner</a></li><li><a href="#sec-RemoveSigner"><span class="spec-secid">12.7.8</span>RemoveSigner</a></li><li><a href="#sec-SwapSigner"><span class="spec-secid">12.7.9</span>SwapSigner</a></li><li><a href="#sec-ChangeRequirement"><span class="spec-secid">12.7.10</span>ChangeRequirement</a></li><li><a href="#sec-Helper-Methods"><span class="spec-secid">12.7.11</span>Helper Methods</a></li></ol></li></ol></li><li><a href="#sec-undefined.Faults"><span class="spec-secid">13</span>Faults</a><input hidden class="toggle" type="checkbox" checked id="_toggle_13" /><label for="_toggle_13"></label><ol><li><a href="#sec-Fault-List"><span class="spec-secid">13.1</span>Fault List</a><input hidden class="toggle" type="checkbox" checked id="_toggle_13.1" /><label for="_toggle_13.1"></label><ol><li><a href="#sec-Consensus-Faults"><span class="spec-secid">13.1.1</span>Consensus Faults</a></li><li><a href="#sec-Market-Faults"><span class="spec-secid">13.1.2</span>Market Faults</a></li></ol></li></ol></li><li><a href="#sec-Signatures"><span class="spec-secid">14</span>Signatures</a><input hidden class="toggle" type="checkbox" checked id="_toggle_14" /><label for="_toggle_14"></label><ol><li><a href="#sec-What-are-signatures-in-Filecoin"><span class="spec-secid">14.1</span>What are signatures in Filecoin</a></li><li><a href="#sec-What-signatures-affect"><span class="spec-secid">14.2</span>What signatures affect</a></li><li><a href="#sec-Signatures.Dependencies"><span class="spec-secid">14.3</span>Dependencies</a></li><li><a href="#sec-Non-Dependencies"><span class="spec-secid">14.4</span>Non-Dependencies</a></li><li><a href="#sec-Signatures.Interface"><span class="spec-secid">14.5</span>Interface</a></li><li><a href="#sec-Selected-Signature-Scheme"><span class="spec-secid">14.6</span>Selected Signature Scheme</a><input hidden class="toggle" type="checkbox" checked id="_toggle_14.6" /><label for="_toggle_14.6"></label><ol><li><a href="#sec-Wire-Format"><span class="spec-secid">14.6.1</span>Wire Format</a></li><li><a href="#sec-Github"><span class="spec-secid">14.6.2</span>Github</a></li><li><a href="#sec-External-References"><span class="spec-secid">14.6.3</span>External References</a></li><li><a href="#sec-References"><span class="spec-secid">14.6.4</span>References</a></li><li><a href="#sec-Inspiration"><span class="spec-secid">14.6.5</span>Inspiration</a></li></ol></li></ol></li><li><a href="#sec-Filecoin-Proofs"><span class="spec-secid">15</span>Filecoin Proofs</a><input hidden class="toggle" type="checkbox" checked id="_toggle_15" /><label for="_toggle_15"></label><ol><li><a href="#sec-Filecoin-Proofs.Proof-of-Replication"><span class="spec-secid">15.1</span>Proof of Replication</a></li><li><a href="#sec-Seal"><span class="spec-secid">15.2</span>Seal</a><input hidden class="toggle" type="checkbox" checked id="_toggle_15.2" /><label for="_toggle_15.2"></label><ol><li><a href="#sec-VerifySeal"><span class="spec-secid">15.2.1</span>VerifySeal</a></li><li><a href="#sec-Unseal"><span class="spec-secid">15.2.2</span>Unseal</a></li><li><a href="#sec-Security-Notes"><span class="spec-secid">15.2.3</span>Security Notes</a><input hidden class="toggle" type="checkbox" checked id="_toggle_15.2.3" /><label for="_toggle_15.2.3"></label><ol><li><a href="#sec-Guaranteeing-sector-uniqueness"><span class="spec-secid">15.2.3.1</span>Guaranteeing sector uniqueness</a></li></ol></li></ol></li><li><a href="#sec-Proof-of-Space-Time"><span class="spec-secid">15.3</span>Proof of Space-Time</a><input hidden class="toggle" type="checkbox" checked id="_toggle_15.3" /><label for="_toggle_15.3"></label><ol><li><a href="#sec-GeneratePost"><span class="spec-secid">15.3.1</span>GeneratePost</a></li><li><a href="#sec-VerifyPoSt"><span class="spec-secid">15.3.2</span>VerifyPoSt</a></li></ol></li><li><a href="#sec-Filecoin-Proofs.Piece-Inclusion-Proof"><span class="spec-secid">15.4</span>Piece Inclusion Proof</a><input hidden class="toggle" type="checkbox" checked id="_toggle_15.4" /><label for="_toggle_15.4"></label><ol><li><a href="#sec-PieceInclusionProof"><span class="spec-secid">15.4.1</span>PieceInclusionProof</a></li><li><a href="#sec-GeneratePieceInclusionProofs"><span class="spec-secid">15.4.2</span>GeneratePieceInclusionProofs</a></li></ol></li></ol></li><li><a href="#sec-Filecoin-Network-Protocols"><span class="spec-secid">16</span>Filecoin Network Protocols</a><input hidden class="toggle" type="checkbox" checked id="_toggle_16" /><label for="_toggle_16"></label><ol><li><a href="#sec-CBOR-RPC"><span class="spec-secid">16.1</span>CBOR RPC</a></li><li><a href="#sec-Hello-Handshake"><span class="spec-secid">16.2</span>Hello Handshake</a></li><li><a href="#sec-Storage-Deal"><span class="spec-secid">16.3</span>Storage Deal</a><input hidden class="toggle" type="checkbox" checked id="_toggle_16.3" /><label for="_toggle_16.3"></label><ol><li><a href="#sec-Deal-State-Values"><span class="spec-secid">16.3.1</span>Deal State Values</a></li></ol></li><li><a href="#sec-Query"><span class="spec-secid">16.4</span>Query</a></li><li><a href="#sec-Retrieve-Piece-for-Free"><span class="spec-secid">16.5</span>Retrieve Piece for Free</a></li><li><a href="#sec-BlockSync"><span class="spec-secid">16.6</span>BlockSync</a></li></ol></li><li><a href="#sec-Filecoin-Data-Propagation"><span class="spec-secid">17</span>Filecoin Data Propagation</a><input hidden class="toggle" type="checkbox" checked id="_toggle_17" /><label for="_toggle_17"></label><ol><li><a href="#sec-Links"><span class="spec-secid">17.1</span>Links</a></li><li><a href="#sec-Block-Propagation"><span class="spec-secid">17.2</span>Block Propagation</a></li><li><a href="#sec-Message-Propagation"><span class="spec-secid">17.3</span>Message Propagation</a></li></ol></li><li><a href="#sec-Data-Structures"><span class="spec-secid">18</span>Data Structures</a><input hidden class="toggle" type="checkbox" checked id="_toggle_18" /><label for="_toggle_18"></label><ol><li><a href="#sec-Data-Structures.Address"><span class="spec-secid">18.1</span>Address</a></li><li><a href="#sec-CID"><span class="spec-secid">18.2</span>CID</a></li><li><a href="#sec-Data-Structures.Block"><span class="spec-secid">18.3</span>Block</a></li><li><a href="#sec-Data-Structures.Message"><span class="spec-secid">18.4</span>Message</a><input hidden class="toggle" type="checkbox" checked id="_toggle_18.4" /><label for="_toggle_18.4"></label><ol><li><a href="#sec-Parameter-Encoding"><span class="spec-secid">18.4.1</span>Parameter Encoding</a></li><li><a href="#sec-Signing"><span class="spec-secid">18.4.2</span>Signing</a></li></ol></li><li><a href="#sec-Message-Receipt"><span class="spec-secid">18.5</span>Message Receipt</a><input hidden class="toggle" type="checkbox" checked id="_toggle_18.5" /><label for="_toggle_18.5"></label><ol><li><a href="#sec-Message-Receipt.Serialization"><span class="spec-secid">18.5.1</span>Serialization</a></li></ol></li><li><a href="#sec-Data-Structures.Actor"><span class="spec-secid">18.6</span>Actor</a></li><li><a href="#sec-State-Tree"><span class="spec-secid">18.7</span>State Tree</a></li><li><a href="#sec-HAMT"><span class="spec-secid">18.8</span>HAMT</a></li><li><a href="#sec-Signature"><span class="spec-secid">18.9</span>Signature</a><input hidden class="toggle" type="checkbox" checked id="_toggle_18.9" /><label for="_toggle_18.9"></label><ol><li><a href="#sec--Type-Values"><span class="spec-secid">18.9.1</span>`Type` Values</a></li><li><a href="#sec-Signature.Serialization"><span class="spec-secid">18.9.2</span>Serialization</a></li></ol></li><li><a href="#sec-Basic-Type-Encodings"><span class="spec-secid">18.10</span>Basic Type Encodings</a><input hidden class="toggle" type="checkbox" checked id="_toggle_18.10" /><label for="_toggle_18.10"></label><ol><li><a href="#sec--PublicKey-"><span class="spec-secid">18.10.1</span>`PublicKey`</a></li><li><a href="#sec--BytesAmount-"><span class="spec-secid">18.10.2</span>`BytesAmount`</a></li><li><a href="#sec--PeerID-"><span class="spec-secid">18.10.3</span>`PeerID`</a></li><li><a href="#sec--Integer-"><span class="spec-secid">18.10.4</span>`Integer`</a></li><li><a href="#sec--BitField-"><span class="spec-secid">18.10.5</span>`BitField`</a></li><li><a href="#sec--SectorSet-"><span class="spec-secid">18.10.6</span>`SectorSet`</a></li><li><a href="#sec--FaultSet-"><span class="spec-secid">18.10.7</span>`FaultSet`</a></li><li><a href="#sec--BlockHeader-"><span class="spec-secid">18.10.8</span>`BlockHeader`</a></li><li><a href="#sec--SealProof-"><span class="spec-secid">18.10.9</span>`SealProof`</a></li><li><a href="#sec--PoStProof-"><span class="spec-secid">18.10.10</span>`PoStProof`</a></li><li><a href="#sec--TokenAmount-"><span class="spec-secid">18.10.11</span>`TokenAmount`</a></li></ol></li><li><a href="#sec-LEB128-Encoding-Reference"><span class="spec-secid">18.11</span>LEB128 Encoding Reference</a><input hidden class="toggle" type="checkbox" checked id="_toggle_18.11" /><label for="_toggle_18.11"></label><ol><li><a href="#sec-Encode-unsigned-LEB128"><span class="spec-secid">18.11.1</span>Encode unsigned LEB128</a><input hidden class="toggle" type="checkbox" checked id="_toggle_18.11.1" /><label for="_toggle_18.11.1"></label><ol><li><a href="#sec-Encode-signed-LEB128"><span class="spec-secid">18.11.1.1</span>Encode signed LEB128</a></li><li><a href="#sec-Decode-unsigned-LEB128"><span class="spec-secid">18.11.1.2</span>Decode unsigned LEB128</a></li><li><a href="#sec-Decode-signed-LEB128"><span class="spec-secid">18.11.1.3</span>Decode signed LEB128</a></li></ol></li></ol></li><li><a href="#sec-Filecoin-Compact-Serialization"><span class="spec-secid">18.12</span>Filecoin Compact Serialization</a></li><li><a href="#sec-Encoding-Considerations"><span class="spec-secid">18.13</span>Encoding Considerations</a></li><li><a href="#sec-IPLD-Considerations"><span class="spec-secid">18.14</span>IPLD Considerations</a></li><li><a href="#sec-Vectors"><span class="spec-secid">18.15</span>Vectors</a></li></ol></li><li><a href="#sec-Filecoin-Node-Local-Storage"><span class="spec-secid">19</span>Filecoin Node Local Storage</a><input hidden class="toggle" type="checkbox" checked id="_toggle_19" /><label for="_toggle_19"></label><ol><li><a href="#sec-Chain-Data"><span class="spec-secid">19.1</span>Chain Data</a></li><li><a href="#sec-Private-Keys"><span class="spec-secid">19.2</span>Private Keys</a></li><li><a href="#sec-Sectors"><span class="spec-secid">19.3</span>Sectors</a></li><li><a href="#sec-Storage-Deals"><span class="spec-secid">19.4</span>Storage Deals</a></li></ol></li><li><a href="#sec-Definitions-Glossary"><span class="spec-secid">20</span>Definitions / Glossary</a><input hidden class="toggle" type="checkbox" checked id="_toggle_20" /><label for="_toggle_20"></label><ol><li><a href="#sec-Updates-to-definitions"><span class="spec-secid">20.1</span>Updates to definitions</a></li><li><a href="#sec-Notes"><span class="spec-secid">20.2</span>Notes</a></li><li><a href="#sec-Definitions"><span class="spec-secid">20.3</span>Definitions</a><input hidden class="toggle" type="checkbox" checked id="_toggle_20.3" /><label for="_toggle_20.3"></label><ol><li><a href="#sec-Definitions.Actor"><span class="spec-secid">20.3.1</span>Actor</a></li><li><a href="#sec-Definitions.Address"><span class="spec-secid">20.3.2</span>Address</a></li><li><a href="#sec-Ask"><span class="spec-secid">20.3.3</span>Ask</a></li><li><a href="#sec-Bid"><span class="spec-secid">20.3.4</span>Bid</a></li><li><a href="#sec-Definitions.Block"><span class="spec-secid">20.3.5</span>Block</a></li><li><a href="#sec-Bootstrapping"><span class="spec-secid">20.3.6</span>Bootstrapping</a></li><li><a href="#sec-Chain-weight"><span class="spec-secid">20.3.7</span>Chain weight</a></li><li><a href="#sec-Challenge-sampling"><span class="spec-secid">20.3.8</span>Challenge sampling</a></li><li><a href="#sec-Cid"><span class="spec-secid">20.3.9</span>Cid</a></li><li><a href="#sec-Client"><span class="spec-secid">20.3.10</span>Client</a></li><li><a href="#sec-Collateral"><span class="spec-secid">20.3.11</span>Collateral</a></li><li><a href="#sec-Commitment"><span class="spec-secid">20.3.12</span>Commitment</a></li><li><a href="#sec-Confirmation"><span class="spec-secid">20.3.13</span>Confirmation</a></li><li><a href="#sec-Consensus"><span class="spec-secid">20.3.14</span>Consensus</a></li><li><a href="#sec-Definitions.Deal"><span class="spec-secid">20.3.15</span>Deal</a></li><li><a href="#sec-Erasure-coding"><span class="spec-secid">20.3.16</span>Erasure coding</a></li><li><a href="#sec-Epoch"><span class="spec-secid">20.3.17</span>Epoch</a></li><li><a href="#sec-Fault"><span class="spec-secid">20.3.18</span>Fault</a></li><li><a href="#sec-Fair"><span class="spec-secid">20.3.19</span>Fair</a></li><li><a href="#sec-File"><span class="spec-secid">20.3.20</span>File</a></li><li><a href="#sec-Finality"><span class="spec-secid">20.3.21</span>Finality</a></li><li><a href="#sec-Definitions.Piece-Inclusion-Proof"><span class="spec-secid">20.3.22</span>Piece Inclusion Proof</a></li><li><a href="#sec-Gas-Fees-Prices"><span class="spec-secid">20.3.23</span>Gas, Fees, Prices</a></li><li><a href="#sec-Generation-Attack-Threshold"><span class="spec-secid">20.3.24</span>Generation Attack Threshold</a></li><li><a href="#sec-GHOST"><span class="spec-secid">20.3.25</span>GHOST</a></li><li><a href="#sec-Leader"><span class="spec-secid">20.3.26</span>Leader</a></li><li><a href="#sec-Leader-election"><span class="spec-secid">20.3.27</span>Leader election</a></li><li><a href="#sec-Definitions.Message"><span class="spec-secid">20.3.28</span>Message</a></li><li><a href="#sec-Miner"><span class="spec-secid">20.3.29</span>Miner</a></li><li><a href="#sec-Node"><span class="spec-secid">20.3.30</span>Node</a></li><li><a href="#sec-Null-Blocks"><span class="spec-secid">20.3.31</span>Null Blocks</a></li><li><a href="#sec-On-chain-off-chain"><span class="spec-secid">20.3.32</span>On-chain/off-chain</a></li><li><a href="#sec-Online-offline"><span class="spec-secid">20.3.33</span>Online/offline</a></li><li><a href="#sec-Payment-Channel"><span class="spec-secid">20.3.34</span>Payment Channel</a></li><li><a href="#sec-Piece"><span class="spec-secid">20.3.35</span>Piece</a></li><li><a href="#sec-Pledge"><span class="spec-secid">20.3.36</span>Pledge</a></li><li><a href="#sec-Polling-Time"><span class="spec-secid">20.3.37</span>Polling Time</a></li><li><a href="#sec-Power-table"><span class="spec-secid">20.3.38</span>Power table</a></li><li><a href="#sec-Power-table-lookback"><span class="spec-secid">20.3.39</span>Power table lookback</a></li><li><a href="#sec-Protocol"><span class="spec-secid">20.3.40</span>Protocol</a></li><li><a href="#sec-Proving-Period"><span class="spec-secid">20.3.41</span>Proving Period</a></li><li><a href="#sec-Proving-Set"><span class="spec-secid">20.3.42</span>Proving Set</a></li><li><a href="#sec-Definitions.Proof-of-Replication"><span class="spec-secid">20.3.43</span>Proof of Replication</a></li><li><a href="#sec-Proof-of-Spacetime"><span class="spec-secid">20.3.44</span>Proof of Spacetime</a></li><li><a href="#sec-Random-ness-"><span class="spec-secid">20.3.45</span>Random(ness)</a></li><li><a href="#sec-Election-Randomness-Lookback"><span class="spec-secid">20.3.46</span>Election Randomness Lookback</a></li><li><a href="#sec-Repair"><span class="spec-secid">20.3.47</span>Repair</a></li><li><a href="#sec-Round"><span class="spec-secid">20.3.48</span>Round</a></li><li><a href="#sec-SEAL-UNSEAL"><span class="spec-secid">20.3.49</span>SEAL/UNSEAL</a></li><li><a href="#sec-Sector"><span class="spec-secid">20.3.50</span>Sector</a></li><li><a href="#sec-Definitions.Slashing"><span class="spec-secid">20.3.51</span>Slashing</a></li><li><a href="#sec-Smart-contracts"><span class="spec-secid">20.3.52</span>Smart contracts</a></li><li><a href="#sec-Definitions.Storage"><span class="spec-secid">20.3.53</span>Storage</a></li><li><a href="#sec-Definitions.State"><span class="spec-secid">20.3.54</span>State</a></li><li><a href="#sec-Ticket"><span class="spec-secid">20.3.55</span>Ticket</a></li><li><a href="#sec-TipSet"><span class="spec-secid">20.3.56</span>TipSet</a></li><li><a href="#sec-Verifiable"><span class="spec-secid">20.3.57</span>Verifiable</a></li><li><a href="#sec-VM"><span class="spec-secid">20.3.58</span>VM</a></li><li><a href="#sec-Voucher"><span class="spec-secid">20.3.59</span>Voucher</a></li><li><a href="#sec-zkSNARK"><span class="spec-secid">20.3.60</span>zkSNARK</a></li></ol></li></ol></li><li><a href="#index"><span class="spec-secid">ยง</span>Index</a></li></ol></nav></header><section id="sec-Overview" secid="1"><h2><span class="spec-secid" title="link to this section"><a href="#sec-Overview">1</a></span>Overview</h2><p>Filecoin is a distributed storage network, with shared state persisted to a blockchain.</p><p>The network maintains consensus over the current state of a replicated <a href="state-machine.md">state machine</a> through <a href="expected-consensus.md">expected consensus</a>. This replicated state machine is used to run the <a href="storage-market.md">filecoin storage market</a>. This market provides a place to buy and sell storage within the distributed network of filecoin miners. The market also provides the needed mechanisms to ensure that the data stored by the network is actually being stored as promised, without requiring client interaction.</p><p>Clients interact with the system by <a href="data-propagation.md#message-propagation">sending messages</a> to the network. These messages are gathered up and included by miners in blocks. Each of these messages defines a state transition in the state machine. The simplest messages say something like &ldquo;move Filecoin from <em>this</em> account under my control to <em>this</em> other account&rdquo;, but more complex ones describe storage sector commitments, storage deals struck, and proofs of storage.</p><p>The Filecoin protocol itself is really a suite of protocols, including:</p><ul><li>the chain protocol for propagating the data that constitutes the blockchain</li><li>the <a href="mining.md">block mining</a> protocol for producing new blocks</li><li>the <a href="expected-consensus.md">consensus mechanism</a> and <a href="validation.md">rules</a> for agreeing on canonical blockchain state</li><li>all interacting with the <a href="state-machine.md">state machine</a> and the <a href="actors.md">actors</a> running on it:<ul><li>the <a href="storage-market.md">storage market</a> protocol for <code>storage miners</code> to sell storage and clients to purchase it</li><li>the <a href="retrieval-market.md">retrieval market</a> protocol for retrieving files</li><li>the <a href="payments.md">payment channel</a> channel protocol for transferring FIL tokens between actors</li></ul></li></ul><section id="sec-Message-Transport" secid="1.1"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Message-Transport">1.1</a></span>Message Transport</h3><p>Filecoin uses <a href="https://libp2p.io">libp2p</a> for all network communications. libp2p provides transport&#8208;agnostic services for peer discovery, naming, routing, pubsub channels and a distributed record store, and there are full or partial <a href="https://libp2p.io/implementations/">implementations</a> in a number of languages. This spec assumes the use of libp2p and its services and does not specify transport&#8208;level details. For more details on the exact wire protocol of libp2p, refer to the <a href="https://github.com/libp2p/specs">libp2p specs</a>.</p><p>Filecoin uses <a href="https://ipld.io">IPLD</a> for the representation and serialization of the majority of the data in the system. IPLD provides a canonical model for content&#8208;addressed data structures, providing a representation of basic data objects and links between them. </p></section></section><section id="sec-Filecoin-Spec-Process-v0-" secid="2"><h2><span class="spec-secid" title="link to this section"><a href="#sec-Filecoin-Spec-Process-v0-">2</a></span>Filecoin Spec Process (v0)</h2><section id="sec--Catch-Up-Mode" secid="2.1"><h3><span class="spec-secid" title="link to this section"><a href="#sec--Catch-Up-Mode">2.1</a></span>&#x27;Catch Up&#x27; Mode</h3><p>Until we get to&lsquo;spec parity&rsquo; where our current level of understanding of the protocol and the spec are in sync, changes will be made to the spec by a simple PR process. If something is missing, PR it in, if something is wrong, PR a fix, if something needs to be elaborated, PR in updates. What is in the top level of this repo, in master, is the spec.</p></section><section id="sec-Proposals---Drafts---Spec" secid="2.2"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Proposals---Drafts---Spec">2.2</a></span>Proposals -&gt; Drafts -&gt; Spec</h3><p>For anything that is not&lsquo;catching up&rsquo; (like&lsquo;repair&rsquo;, for example) the process we will use is to first discuss the problem in an issue (or several issues, if the space is large and multithreaded enough). Then when someone feels like a solution is near, they will write it up as a document, and submit a PR to put it into the&lsquo;drafts&rsquo; folder in the repo.</p><p>&lsquo;Drafts&rsquo; are not canonical spec, and should not be considered for implementation. It is acceptable for a PR for a draft to stay open for quite a while, as thought and discussion on the topic happens. At some point (ideally, in two weeks or less), if the reviewers and the author feel that the current state of the draft is stable enough (though not&lsquo;done&rsquo;) then it should be merged into the repo. Further changes to the draft are additional PRs, which may generate more discussion. Comments on these drafts are welcome from anyone, but if you wish to be involved in the actual research process, you will need to devote very considerable time and energy to the process.</p><p>Once there is agreement that the draft should be implemented, it should then get moved from the drafts folder, into the top level along with other spec documents. This process should just be a simple renaming, and should not generate any discussion. Along with the moving of that document, any interested parties in the development teams should be explicitly tagged.</p><section id="sec-On-merging" secid="2.2.1"><h4><span class="spec-secid" title="link to this section"><a href="#sec-On-merging">2.2.1</a></span>On merging</h4><p>For anything in the drafts or notes folder, merge yourself after a review from a relevant person. For anything in the top level (canonical spec), @whyrusleeping will merge after proper review.</p></section><section id="sec-Issues" secid="2.2.2"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Issues">2.2.2</a></span>Issues</h4><p>Issues in the specs repo will be high signal, they will either be proposals, or issues directly relating to problems in the spec. More speculative research questions and discussion will happen in the research repo. </p></section></section></section><section id="sec-Filecoin-Node-Operation" secid="3"><h2><span class="spec-secid" title="link to this section"><a href="#sec-Filecoin-Node-Operation">3</a></span>Filecoin Node Operation</h2><p>Running a Filecoin <code>full node</code> requires running many different processes and protocols simultaneously. This section describes the set of things you need to do in order to run a fully validating Filecoin node.</p><div class="spec-todo">Elaborate on all this, obviously</div><section id="sec-Chain-Validation" secid="3.1"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Chain-Validation">3.1</a></span>Chain Validation</h3><p><a href="validation.md">Chain validation</a> is the process by which a node stays up to date with the current state of the blockchain. This Involves:</p><ul><li>Listening for new blocks on the blocks pubsub channel (See <a href="data-propagation.md#block-propagation">block propagation</a>)<ul><li>As new blocks come in, run through the block validation process<ul><li>Keep track of valid blocks, keep track of the current&lsquo;best&rsquo; block (according to EC rules)</li></ul></li><li>Rebroadcast valid blocks<ul><li>Note: the actual rebroadcasting is handled by the underlying gossipsub library. We simply need to signal to that library which blocks should be rebroadcast.</li></ul></li></ul></li></ul></section><section id="sec-MemPool-Maintenance" secid="3.2"><h3><span class="spec-secid" title="link to this section"><a href="#sec-MemPool-Maintenance">3.2</a></span>MemPool Maintenance</h3><p>Listen for messages on the messages pubsub channel (See <a href="data-propagation.md#message-propagation">message propagation</a>). Validate each message, rebroadcast valid ones.</p></section><section id="sec-Handshaking" secid="3.3"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Handshaking">3.3</a></span>Handshaking</h3><ul><li>For each node you connect to, run the <a href="network-protocols.md#hello-handshake">&lsquo;hello&rsquo; protocol</a> with them<ul><li>If response shows that you and the other node have different genesis blocks, disconnect from them.</li><li>If the other node gives a valid chain head that is farther ahead than you,&lsquo;sync&rsquo; the chain and maybe switch to it if it&rsquo;s <a href="expected-consensus.md#chain-weighing">&lsquo;heavier&rsquo;</a>.</li></ul></li></ul></section><section id="sec-DHT-for-Peer-Routing" secid="3.4"><h3><span class="spec-secid" title="link to this section"><a href="#sec-DHT-for-Peer-Routing">3.4</a></span>DHT for Peer Routing</h3><ul><li>Run the DHT protocol for aiding node discovery<ul><li>libp2p&#8208;kad&#8208;dht, with just&lsquo;find node&rsquo; RPCs enabled.</li></ul></li></ul></section><section id="sec-Bitswap-for-data-requests" secid="3.5"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Bitswap-for-data-requests">3.5</a></span>Bitswap for data requests</h3><p>Run bitswap to fetch and serve data (such as messages) to and from other filecoin nodes. This is used to fill in missing bits during block propagation, and also to fetch data during sync.</p><p>There is not yet an official spec for bitswap, but <a href="https://github.com/ipfs/go-bitswap/blob/master/message/pb/message.proto">the protobufs</a> should help in the interim.</p></section><section id="sec-Filecoin-Node-Operation.Mining" secid="3.6"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Filecoin-Node-Operation.Mining">3.6</a></span>Mining</h3><section id="sec-Filecoin-Node-Operation.Mining.Storage" secid="3.6.1"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Filecoin-Node-Operation.Mining.Storage">3.6.1</a></span>Storage</h4><p>To be a Filecoin storage miner means run several processes in addition to running a&lsquo;Full Node&rsquo;.</p><section id="sec-Accept-Deals" secid="3.6.1.1"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Accept-Deals">3.6.1.1</a></span>Accept Deals</h5><p>A Filecoin storage miner should listen for, decide upon, and accept storage deals from clients. The data being stored for each of these deals should be placed into a sector, and sealed up once that sector is full. Sealed sectors are then submitted to the chain via <code>CommitSector</code>. This logic is generally abstracted away by the&lsquo;Sector Sealing Subsystem&rsquo;.</p><p>To accept deals, miners should run the <a href="network-protocols.md#storage-deal">&lsquo;storage deal&rsquo;</a> service.</p></section><section id="sec-Prove-Storage" secid="3.6.1.2"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Prove-Storage">3.6.1.2</a></span>Prove Storage</h5><p>Once miners have submitted sealed sectors to the chain, they will be on the hook for proving the data over time. Every <code>proving period</code>, miners should take their current <code>proving set</code> and call <code>post.GeneratePost</code> on it. This process will take a fairly long amount of time (TODO: either put specific parameters here, or link to them) and result in a compact Proof of SpaceTime, which must then be submitted to the chain via <code>SubmitPoSt</code></p></section><section id="sec-Extend-the-Blockchain" secid="3.6.1.3"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Extend-the-Blockchain">3.6.1.3</a></span>Extend the Blockchain</h5><p>A storage miner is also responsible for producing blocks to extend the blockchain. At every round, storage miners check to see if they are the leader, and if they are, they submit a new block to the network, earning a reward for doing so.</p><p>The responsibilities of storage miners are documented in more detail in the <a href="mining.md">mining document</a></p></section></section><section id="sec-Retrieval" secid="3.6.2"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Retrieval">3.6.2</a></span>Retrieval</h4><p>To be a filecoin retrieval miner: (todo) </p></section></section></section><section id="sec-Chain-Syncing" secid="4"><h2><span class="spec-secid" title="link to this section"><a href="#sec-Chain-Syncing">4</a></span>Chain Syncing</h2><p>This spec describes the Filecoin sync protocol, for related systems, see:</p><ul><li><a href="./bootstrap.md">Bootstrapping</a> which describes how a node builds a peer set in the first place.</li><li><a href="./network-protocols.md">Network Protocols</a> on how Filecoin nodes can communicate with each other, with for instance, an <a href="./network-protocols.md#hello-handshake">initial handshake</a>, or <a href="./network-protocols.md#blocksync">block syncing</a>.</li><li><a href="./operation.md">Operation</a> on various operations a functional Filecoin node needs to run, like <a href="./operation.md#dht-for-peer-routing.md">DHT routing</a>.</li></ul><section id="sec-What-is-chain-syncing-in-Filecoin-" secid="4.1"><h3><span class="spec-secid" title="link to this section"><a href="#sec-What-is-chain-syncing-in-Filecoin-">4.1</a></span>What is chain syncing in Filecoin?</h3><p>Chain syncing is the process a filecoin node runs to sync its internal chain state with new blocks from the network and new blocks it itself has mined. A node syncs in two distinct modes: <code>syncing</code> and <code>caught up</code>. Chain syncing updates both local storage of chain data and the head of the current heaviest observed chain.</p><p>&lsquo;Syncing&rsquo; mode and&lsquo;Caught up&rsquo; mode are two distinct processes.&lsquo;Syncing&rsquo; mode, or&lsquo;the initial sync&rsquo; is a process that is triggered when a node is far enough behind the rest of the network. This process terminates once the nodes&lsquo;head&rsquo; is sufficiently far ahead. Once&lsquo;syncing&rsquo; is complete, the&lsquo;caught up&rsquo; sync process begins. This process keeps the node up to date with the rest of the network, and terminates only when the node is shut down.</p></section><section id="sec-Chain-Syncing.Interface" secid="4.2"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Chain-Syncing.Interface">4.2</a></span>Interface</h3><pre><code><span class="token keyword">type</span> Syncer <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	<span class="token comment" spellcheck="true">// The heaviest known TipSet in the network.</span>
	head TipSet

	<span class="token comment" spellcheck="true">// The interface for accessing and putting TipSets into local storage</span>
	store ChainStore

	<span class="token comment" spellcheck="true">// The known genesis TipSet</span>
	genesis TipSet

	<span class="token comment" spellcheck="true">// the current mode the syncer is in</span>
	syncMode SyncMode

	<span class="token comment" spellcheck="true">// TipSets known to be invalid</span>
	bad BadTipSetCache

  <span class="token comment" spellcheck="true">// handle to the block sync service</span>
  bsync BlockSync

  <span class="token comment" spellcheck="true">//peer set</span>
  peerSet <span class="token punctuation">[</span><span class="token punctuation">]</span>PeerID

  <span class="token comment" spellcheck="true">// peer heads</span>
  <span class="token comment" spellcheck="true">// Note: clear cache on disconnects</span>
  peerHeads <span class="token keyword">map</span><span class="token punctuation">[</span>PeerID<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span>Cid

  trustedPeers <span class="token punctuation">[</span><span class="token punctuation">]</span>PeerID
  trustedHeads <span class="token keyword">map</span><span class="token punctuation">[</span>PeerId<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span>Cid  
<span class="token punctuation">}</span>

<span class="token keyword">const</span> BootstrapPeerThreshold <span class="token operator">=</span> <span class="token number">25</span>
<span class="token keyword">const</span> DupThreshold <span class="token operator">=</span> <span class="token number">10</span>
</code></pre></section><section id="sec-General-Operation" secid="4.3"><h3><span class="spec-secid" title="link to this section"><a href="#sec-General-Operation">4.3</a></span>General Operation</h3><p>Whenever a node hears about a new head, it will sync to it as warranted. <code>InformNewHead()</code> is called both during bootstrapping and as peers send across new blocks.</p><pre><code><span class="token comment" spellcheck="true">// InformNewHead informs the syncer about a new potential TipSet</span>
<span class="token comment" spellcheck="true">// This should be called when connecting to new peers, and additionally</span>
<span class="token comment" spellcheck="true">// when receiving new blocks from the network</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>syncer <span class="token operator">*</span>Syncer<span class="token punctuation">)</span> <span class="token function">InformNewHead</span><span class="token punctuation">(</span>from PeerID<span class="token punctuation">,</span> head TipSet<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">switch</span> syncer<span class="token punctuation">.</span>syncMode <span class="token punctuation">{</span>
	<span class="token keyword">case</span> Bootstrap<span class="token punctuation">:</span>
    <span class="token comment" spellcheck="true">// InformNewHead will only get called during PeerSetExpansion during bootstrapping</span>
		<span class="token keyword">go</span> <span class="token function">SyncBootstrap</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
	<span class="token keyword">case</span> CaughtUp<span class="token punctuation">:</span>
		<span class="token keyword">go</span> syncer<span class="token punctuation">.</span><span class="token function">SyncCaughtUp</span><span class="token punctuation">(</span>blk<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// SyncBootstrap is used to synchronise your chain when first joining</span>
<span class="token comment" spellcheck="true">// the network, or when rejoining after significant downtime.</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>syncer <span class="token operator">*</span>Syncer<span class="token punctuation">)</span> <span class="token function">SyncBootstrap</span><span class="token punctuation">(</span><span class="token builtin">bool</span> expanding<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    syncer<span class="token punctuation">.</span>syncLock<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">defer</span> syncer<span class="token punctuation">.</span>syncLock<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> expanding <span class="token operator">&amp;&amp;</span> <span class="token function">len</span><span class="token punctuation">(</span>syncer<span class="token punctuation">.</span>peerHeads<span class="token punctuation">)</span> <span class="token operator">&lt;</span> BootstrapPeerThreshold <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// not enough peers to sync yet...</span>
        <span class="token keyword">return</span>
    <span class="token punctuation">}</span>

  	syncPeers <span class="token operator">:=</span> syncer<span class="token punctuation">.</span>peerSet
  	syncHeads <span class="token operator">:=</span> syncer<span class="token punctuation">.</span>peerHeads
  	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>expanding<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    		syncPeers <span class="token operator">=</span> syncer<span class="token punctuation">.</span>trustedPeers
      	syncHeads <span class="token operator">=</span> syncer<span class="token punctuation">.</span>trustedHeads
  	<span class="token punctuation">}</span>
  	<span class="token comment" spellcheck="true">// Will now get heaviest head from all the heads from our Peerset</span>
    selectedHead <span class="token operator">:=</span> <span class="token function">selectHead</span><span class="token punctuation">(</span>syncer<span class="token punctuation">.</span>peerHeads<span class="token punctuation">)</span>

    cur <span class="token operator">:=</span> selectedHead
    <span class="token keyword">var</span> blockSet BlockSet
    <span class="token keyword">for</span> head<span class="token punctuation">.</span><span class="token function">Height</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// NB: GetBlocks validates that the blocks are in-fact the ones we</span>
        <span class="token comment" spellcheck="true">// requested, and that they are correctly linked to each other. It does</span>
        <span class="token comment" spellcheck="true">// not validate any state transitions</span>
        blks <span class="token operator">:=</span> syncer<span class="token punctuation">.</span>bsync<span class="token punctuation">.</span><span class="token function">GetBlocks</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> RequestWidth<span class="token punctuation">)</span>
        blockSet<span class="token punctuation">.</span><span class="token function">Insert</span><span class="token punctuation">(</span>blks<span class="token punctuation">)</span>

        head <span class="token operator">=</span> blks<span class="token punctuation">.</span><span class="token function">Last</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Parents</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// Fetch all the messages for all the blocks in this chain</span>
    <span class="token comment" spellcheck="true">// There are many ways to make this more efficient. For now, do the dumb thing</span>
    blockSet<span class="token punctuation">.</span><span class="token function">ForEach</span><span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span>b Block<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// FetchMessages should use bitswap to fetch any messages we don't have locally</span>
        <span class="token function">FetchMessages</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>

  	<span class="token comment" spellcheck="true">// Ensure that the selectedHead has the right genesis block</span>
  	<span class="token comment" spellcheck="true">// Should be checked for trusted nodes in InitialConnect() and for</span>
  	<span class="token comment" spellcheck="true">// all others in addPeerToSet(), but we leave details up to impl.</span>
  	selectedGenesis <span class="token operator">:=</span> blockSet<span class="token punctuation">.</span><span class="token function">GetByHeight</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
	  <span class="token function">assert</span><span class="token punctuation">(</span>selectedGenesis <span class="token operator">==</span> genesis<span class="token punctuation">,</span> <span class="token string">"State failure: trying to sync to wrong chain"</span><span class="token punctuation">)</span>

    <span class="token comment" spellcheck="true">// Now, to validate some state transitions</span>
    base <span class="token operator">:=</span> syncer<span class="token punctuation">.</span>genesis
    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> selectedHead<span class="token punctuation">.</span><span class="token function">Height</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
        next <span class="token operator">:=</span> blockSet<span class="token punctuation">.</span><span class="token function">GetByHeight</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">ValidateTransition</span><span class="token punctuation">(</span>base<span class="token punctuation">,</span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// TODO: do something productive here...</span>
            <span class="token function">Error</span><span class="token punctuation">(</span><span class="token string">"invalid state transition"</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    blockSet<span class="token punctuation">.</span><span class="token function">PersistTo</span><span class="token punctuation">(</span>syncer<span class="token punctuation">.</span>store<span class="token punctuation">)</span>
    syncer<span class="token punctuation">.</span>head <span class="token operator">=</span> bset<span class="token punctuation">.</span><span class="token function">Head</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    syncer<span class="token punctuation">.</span>syncMode <span class="token operator">=</span> CaughtUp
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">selectHead</span><span class="token punctuation">(</span>heads <span class="token keyword">map</span><span class="token punctuation">[</span>PeerID<span class="token punctuation">]</span>TipSet<span class="token punctuation">)</span> TipSet <span class="token punctuation">{</span>
    headsArr <span class="token operator">:=</span> <span class="token function">toArray</span><span class="token punctuation">(</span>heads<span class="token punctuation">)</span>
    sel <span class="token operator">:=</span> headsArr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>headsArr<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
        cur <span class="token operator">:=</span> headsArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>

        <span class="token keyword">if</span> cur<span class="token punctuation">.</span><span class="token function">IsAncestorOf</span><span class="token punctuation">(</span>sel<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">continue</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> sel<span class="token punctuation">.</span><span class="token function">IsAncestorOf</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            sel <span class="token operator">=</span> cur
            <span class="token keyword">continue</span>
        <span class="token punctuation">}</span>

        nca <span class="token operator">:=</span> <span class="token function">NearestCommonAncestor</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span> sel<span class="token punctuation">)</span>
        <span class="token keyword">if</span> sel<span class="token punctuation">.</span><span class="token function">Height</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> nca<span class="token punctuation">.</span><span class="token function">Height</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> ForkLengthThreshold <span class="token punctuation">{</span>
        	<span class="token comment" spellcheck="true">// TODO: handle this better than refusing to sync</span>
        	<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"Conflict exists in heads set"</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">if</span> cur<span class="token punctuation">.</span><span class="token function">Weight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> sel<span class="token punctuation">.</span><span class="token function">Weight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            sel <span class="token operator">=</span> cur
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> sel
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// SyncCaughtUp is used to stay in sync once caught up to</span>
<span class="token comment" spellcheck="true">// the rest of the network.</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>syncer <span class="token operator">*</span>Syncer<span class="token punctuation">)</span> <span class="token function">SyncCaughtUp</span><span class="token punctuation">(</span>maybeHead TipSet<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span>
	chain<span class="token punctuation">,</span> err <span class="token operator">:=</span> syncer<span class="token punctuation">.</span><span class="token function">collectChainCaughtUp</span><span class="token punctuation">(</span>maybeHead<span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> err
	<span class="token punctuation">}</span>

	<span class="token comment" spellcheck="true">// possibleTs enumerates possible tipsets that are the union</span>
	<span class="token comment" spellcheck="true">// of tipsets from the chain and the store</span>
	<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> ts <span class="token operator">:=</span> <span class="token keyword">range</span> <span class="token function">possibleTs</span><span class="token punctuation">(</span>chain<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span> err <span class="token operator">:=</span> consensus<span class="token punctuation">.</span><span class="token function">Validate</span><span class="token punctuation">(</span>ts<span class="token punctuation">,</span> store<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
			<span class="token keyword">return</span> err
		<span class="token punctuation">}</span>
		syncer<span class="token punctuation">.</span>store<span class="token punctuation">.</span><span class="token function">PutTipSet</span><span class="token punctuation">(</span>ts<span class="token punctuation">)</span>
		<span class="token keyword">if</span> consenus<span class="token punctuation">.</span><span class="token function">Weight</span><span class="token punctuation">(</span>ts<span class="token punctuation">)</span> <span class="token operator">></span> consensus<span class="token punctuation">.</span><span class="token function">Weight</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			syncer<span class="token punctuation">.</span>head <span class="token operator">=</span> ts
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token boolean">nil</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>syncer <span class="token operator">*</span>Syncer<span class="token punctuation">)</span> <span class="token function">collectChainCaughtUp</span><span class="token punctuation">(</span>maybeHead TipSet<span class="token punctuation">)</span> <span class="token punctuation">(</span>Chain<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment" spellcheck="true">// fetch TipSet and messages via bitswap</span>
	ts <span class="token operator">:=</span> <span class="token function">tipsetFromCidOverNet</span><span class="token punctuation">(</span>newHead<span class="token punctuation">)</span>

	<span class="token keyword">var</span> chain Chain
	<span class="token keyword">for</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span> <span class="token operator">!</span>consensus<span class="token punctuation">.</span><span class="token function">Punctual</span><span class="token punctuation">(</span>ts<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			syncer<span class="token punctuation">.</span>bad<span class="token punctuation">.</span><span class="token function">InvalidateChain</span><span class="token punctuation">(</span>chain<span class="token punctuation">)</span>
			syncer<span class="token punctuation">.</span>bad<span class="token punctuation">.</span><span class="token function">InvalidateTipSet</span><span class="token punctuation">(</span>ts<span class="token punctuation">)</span>
			<span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> errors<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token string">"TipSet forks too far back from head"</span><span class="token punctuation">)</span>
		<span class="token punctuation">}</span>

		chain<span class="token punctuation">.</span><span class="token function">InsertFront</span><span class="token punctuation">(</span>ts<span class="token punctuation">)</span>

		<span class="token keyword">if</span> syncer<span class="token punctuation">.</span>store<span class="token punctuation">.</span><span class="token function">Contains</span><span class="token punctuation">(</span>ts<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token comment" spellcheck="true">// Store has record of this TipSet.</span>
			<span class="token keyword">return</span> chain<span class="token punctuation">,</span> <span class="token boolean">nil</span>
		<span class="token punctuation">}</span>
		parent <span class="token operator">:=</span> ts<span class="token punctuation">.</span><span class="token function">ParentCid</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		ts<span class="token punctuation">,</span> err <span class="token operator">=</span> <span class="token function">tipsetFromCidOverNet</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span>
		<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
			<span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> err
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></section><section id="sec-Syncing-Mode" secid="4.4"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Syncing-Mode">4.4</a></span>Syncing Mode</h3><p>A filecoin node syncs in <code>syncing</code> mode when entering the network for the first time, or after being separated for a sufficiently long period of time. The exact period of time comes from the consensus protocol (TODO specify more concretely, for example how does this relate to the consensus.Punctual method?).</p><p>During <code>syncing</code> mode a node learns about the newest head of the blockchain through the secure bootstrapping protocol. The syncing protocol then syncs the block headers for that entire chain, and validates their linking. It then fetches all the messages for the chain, and checks all the state transitions between the blocks and that the blocks were correctly created. If validation passes the node&rsquo;s head is updated to the head TipSet received from bootstrapping.</p><p>In this mode of operation a filecoin node should not mine or send messages as it will not be able to successfully generate heaviest blocks or reference the correct state of the chain to verify that messages will execute as expected.</p><p>(TODO: should include discussion of a <code>Load()</code> call to make use of existing chain data on a node during &ldquo;re&#8208;awakening&rdquo; case of <code>syncing</code> mode.)</p></section><section id="sec-Caught-Up-Mode" secid="4.5"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Caught-Up-Mode">4.5</a></span>Caught Up Mode</h3><p>A filecoin node syncs in <code>caught up</code> mode after completing <code>syncing</code> mode. A node stays in this mode until it is shut down. New block cids are gossiped from the network through the hello protocol or the network&rsquo;s <a href="data-propagation.md#block-propagation">block pubsub protocol</a>. A node also obtains new block cids coming from its own successfully mined blocks. These cids are input to the <code>caught up</code> syncing protocol. If these cids belong to a TipSet already in the store then they are already synced and the syncing protocol finishes. If not the syncing protocol resolves the TipSet corresponding to the input cids. It checks that this TipSet is not in its badTipSet cache, and that this TipSet is not too far back in the chain using the consensus <code>Punctual</code> method. It then resolves the parent TipSet by reading off the parent cids in the header of any block of the TipSet. The above procedure repeats until either an error is found or the store contains the next TipSet. In the case of an error bad TipSets and their children not already in the bad TipSet cache are added to the cache before the call to <code>collectTipSetCaughtUp</code> returns.</p><p>After collecting a chain up to an ancestor TipSet that was previously synced to the store the syncing protocol checks each TipSet of the new chain for validity one by one. When the filecoin network runs Expected Consensus, or any other multiple parents consensus protocol, the syncing protocol must consider not only the TipSets in the new chain but also possible new&#8208;heaviest TipSets that are the union of TipSets in the new chain and TipSets already in the store. In the case of Expected Consensus there is at most one such TipSet: the TipSet made up of the union of the first new TipSet in the new chain being synced and the largest TipSet with the same parents kept in the store.</p><p>To sync new TipSets the <code>caught up</code> syncing protocol first runs a consensus validation check on the TipSet. If any TipSet is invalid the syncing protocol finishes. If a TipSet is valid the syncer adds the TipSet to the chain store. The syncing protocol then checks whether the TipSet is heavier than the current head using the consensus weighting rules. If it is heavier the chain updates the state of the node to account for the new heaviest TipSet.</p></section><section id="sec-Maintaining-a-fresh-Peer-Set" secid="4.6"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Maintaining-a-fresh-Peer-Set">4.6</a></span>Maintaining a fresh Peer Set</h3><p>Syncing depends on the validity of a node&rsquo;s peer set. In order to ensure that the peer set remains representative of the network&rsquo;s state after bootstrap, a node should replace peers as peers disconnect. (TODO in future: cycle through peers on regular basis).</p><pre><code><span class="token comment" spellcheck="true">// triggered when a peer disconnects</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>syncer <span class="token operator">*</span>Syncer<span class="token punctuation">)</span> <span class="token function">replacePeer</span><span class="token punctuation">(</span>peer PeerID<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">delete</span><span class="token punctuation">(</span>syncer<span class="token punctuation">.</span>PeerSet<span class="token punctuation">,</span> peer<span class="token punctuation">)</span>
    <span class="token function">delete</span><span class="token punctuation">(</span>syncer<span class="token punctuation">.</span>PeerHeads<span class="token punctuation">,</span> peer<span class="token punctuation">)</span>

  	newPeer <span class="token operator">:=</span> syncer<span class="token punctuation">.</span><span class="token function">getRandomPeer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  	<span class="token comment" spellcheck="true">// addPeerToSet will validate this peer (i.e. check it has right genesis, etc.)</span>
  	while <span class="token operator">!</span>syncer<span class="token punctuation">.</span><span class="token function">addPeerToSet</span><span class="token punctuation">(</span>newPeer<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      newPeer <span class="token operator">=</span> syncer<span class="token punctuation">.</span><span class="token function">getRandomPeer</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>ownID<span class="token punctuation">)</span>
  	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>syncer <span class="token operator">*</span>Syncer<span class="token punctuation">)</span> <span class="token function">getRandomPeer</span><span class="token punctuation">(</span>from PeerID<span class="token punctuation">)</span> newPeer PeerID <span class="token punctuation">{</span>
  	wantedPeer <span class="token operator">:=</span> <span class="token function">generateRandomNodeID</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">// libp2p's GetClosestPeers gets back k nearest peers, ordered</span>
    peers <span class="token operator">:=</span> dht<span class="token punctuation">.</span><span class="token function">GetClosestPeers</span><span class="token punctuation">(</span>from<span class="token punctuation">,</span> wantedPeer<span class="token punctuation">)</span>
	  <span class="token comment" spellcheck="true">// We only use the nearest to get a good random peer</span>
    newPeer <span class="token operator">:=</span> peers<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
		<span class="token keyword">return</span> newPeer
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>syncer <span class="token operator">*</span>Syncer<span class="token punctuation">)</span> <span class="token function">addPeerToSet</span><span class="token punctuation">(</span>newPeer PeerID<span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">{</span>
  	<span class="token comment" spellcheck="true">// verify new peer to check whether to include in peerSet</span>
    <span class="token keyword">if</span> <span class="token operator">!</span>s<span class="token punctuation">.</span>peerSet<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>newPeer<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      peerChain <span class="token operator">:=</span> <span class="token function">sayHello</span><span class="token punctuation">(</span>newPeer<span class="token punctuation">)</span>

      <span class="token keyword">if</span> peerChain<span class="token punctuation">.</span>GenesisHash <span class="token operator">==</span> GENESIS <span class="token operator">||</span> trustedPeer<span class="token punctuation">.</span><span class="token function">isAncestorOf</span><span class="token punctuation">(</span>newPeer<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        s<span class="token punctuation">.</span>peerSet <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>peerSet<span class="token punctuation">,</span> newPeer<span class="token punctuation">)</span>
        s<span class="token punctuation">.</span><span class="token function">InformNewHead</span><span class="token punctuation">(</span>newPeer<span class="token punctuation">,</span> trustedChain<span class="token punctuation">.</span>HeaviestTipSet<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token boolean">false</span>
<span class="token punctuation">}</span>
</code></pre></section><section id="sec-Chain-Syncing.Dependencies" secid="4.7"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Chain-Syncing.Dependencies">4.7</a></span>Dependencies</h3><p>Things that affect the chain syncing protocol.</p><p><strong>Consensus protocol</strong></p><ul><li>The consensus protocol should define a punctual function: <code>func Punctual([]TipSet chain) bool</code>. <code>Punctual(chain) == true</code> when a provided chain does not fork from the node&rsquo;s view of the current best chain&lsquo;too far in the past&rsquo;, and false otherwise.</li><li>The fork selection rule. This includes the weighting function. As part of this in the context of EC the syncer must consider TipSets that are the union of independently propagated TipSets.</li></ul><p><strong>Chain storage</strong></p><ul><li>The current chain syncing protocol requires that the chain store never stores an invalid TipSet.</li></ul></section><section id="sec-Chain-Syncing.Open-Questions" secid="4.8"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Chain-Syncing.Open-Questions">4.8</a></span>Open Questions</h3><ul><li>Secure bootstrapping in <code>syncing</code> mode</li><li>How do we handle the lag between the initial head bootstrapped in <code>syncing</code> mode and the network head once the first <code>SyncBootstrap</code> call is complete? Likely we&rsquo;ll need multiple <code>SyncBootstrap</code> calls. Should they be parallelized?</li><li>The properties of the chain store implementation have significant impact on the design of the syncing protocol and the syncing protocol&rsquo;s resistance to Denial Of Service (DOS) attacks. For example if the chain store naively keeps all blocks in storage nodes are more vulnerable to running out of space. As another example the syncer assumes that the store always contains a punctual ancestor of the heaviest chain. Should the spec grow to include properties of chain storage so that the syncing protocol can guarantee a level of DOS resistance? Should chain storage be completely up to the implementation? Should the chain storage spec be a part of the syncing protocol? </li></ul></section></section><section id="sec-The-Filecoin-Storage-Market" secid="5"><h2><span class="spec-secid" title="link to this section"><a href="#sec-The-Filecoin-Storage-Market">5</a></span>The Filecoin Storage Market</h2><section id="sec-What-is-the-Filecoin-Storage-Market" secid="5.1"><h3><span class="spec-secid" title="link to this section"><a href="#sec-What-is-the-Filecoin-Storage-Market">5.1</a></span>What is the Filecoin Storage Market</h3><p>The Filecoin <code>storage market</code> is the underlying system used to discover, negotiate and form <code>storage contracts</code> between clients and storage providers called <code>storage miners</code> in a Filecoin network. The <code>storage market</code> itself is an <code>actor</code> that helps to mediate certain operations in the market, including adding new miners, and punishing faulty ones, it does not directly mediate any actual storage deals. The <code>storage contracts</code> between clients and miners specify that a given <code>piece</code> will be stored for a given time duration. It is assumed that the <code>client</code>, or some delegate of the client, remains online to monitor the <code>storage miner</code> and <code>slash</code> it in the case that the agreed upon data is removed from the miners proving set before the deal is finished.</p><p>The creation of such a storage market is motivated by the need to provide a fast, reliable and inexpensive solution to data generated worldwide. The cost and difficulty involved in starting datacenters around the world make a decentralized solution attractive here, enabling clients and miners to interact directly, forming agreements for storage ad&#8208;hoc around the world. Geography is only one such aspect in which a decentralized market can be made competitive. You can read more about the underlying motivations for building a storage market <a href="https://www.youtube.com/watch?v=EClPAFPeXIQ">here</a>.</p><p>In the current design of the <code>storage market</code>, <code>storage miners</code> post <code>asks</code> indicating the price they are willing to accepts, and <code>clients</code> select (either manually, or via some locally run algorithm) a set of storage miners to store their data with. They then contact the <code>storage miners</code> who programmatically either accept or deny their <code>deal proposals</code>. In the future, we may allow miners to search for clients and propose deals to them, but for now, for simplicity, we stick with the model described above.</p><section id="sec-Visualization-of-the-Filecoin-Storage-Market" secid="5.1.1"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Visualization-of-the-Filecoin-Storage-Market">5.1.1</a></span>Visualization of the Filecoin Storage Market</h4><div class="spec-todo">This is a high level overview of how the storage market interacts with components</div></section></section><section id="sec-The-Market-Interface" secid="5.2"><h3><span class="spec-secid" title="link to this section"><a href="#sec-The-Market-Interface">5.2</a></span>The Market Interface</h3><p>This interface, written using Go type notation, defines the set of methods that are callable on the storage market actor. The storage market actor is a built&#8208;in network actor. For more information about Actors, see TODO.</p><pre><code><span class="token keyword">type</span> StorageMarket <span class="token keyword">interface</span> <span class="token punctuation">{</span>
	<span class="token comment" spellcheck="true">// CreateStorageMiner registers a new storage miner with the given public key and a</span>
	<span class="token comment" spellcheck="true">// pledge of the given size. The miners collateral is set by the value in the message.</span>
	<span class="token comment" spellcheck="true">// The public key must match the private key used to sign off on blocks created</span>
	<span class="token comment" spellcheck="true">// by this miner. This key is the 'worker' key for the miner.</span>
	<span class="token comment" spellcheck="true">// The libp2p peer ID specified should reference the libp2p identity that the</span>
	<span class="token comment" spellcheck="true">// miner is operating. This is the ID that clients will connect to to propose deals</span>
	<span class="token comment" spellcheck="true">// TODO: maybe rename to 'RegisterStorageMiner'?</span>
	<span class="token function">CreateStorageMiner</span><span class="token punctuation">(</span>pubk PublicKey<span class="token punctuation">,</span> pledge BytesAmount<span class="token punctuation">,</span> pid libp2p<span class="token punctuation">.</span>PeerID<span class="token punctuation">)</span> Address

	<span class="token comment" spellcheck="true">// SlashConsensusFault is used to slash a misbehaving miner who submitted two different</span>
	<span class="token comment" spellcheck="true">// blocks at the same block height. The signatures on each block are validated</span>
	<span class="token comment" spellcheck="true">// and the offending miner has their entire collateral slashed, including the</span>
	<span class="token comment" spellcheck="true">// invalidation of any any all storage they are providing. The caller is rewarded</span>
	<span class="token comment" spellcheck="true">// a small amount to compensate for gas fees (TODO: maybe it should be more?)</span>
	<span class="token function">SlashConsensusFault</span><span class="token punctuation">(</span>blk1<span class="token punctuation">,</span> blk2 BlockHeader<span class="token punctuation">)</span>

	<span class="token comment" spellcheck="true">// SlashStorageFault slashes a storage miner for not submitting their PoSTs within</span>
	<span class="token comment" spellcheck="true">// the correct [time window](#TODO-link-to-faulty-submission). This may be called by anyone who detects the faulty behavior.</span>
	<span class="token comment" spellcheck="true">// The slashed miner then loses all of their staked collateral, and also loses all</span>
	<span class="token comment" spellcheck="true">// of their power, and as a result, is no longer a candidate leader for extending the chain.</span>
	<span class="token function">SlashStorageFault</span><span class="token punctuation">(</span>miner Address<span class="token punctuation">)</span>

	<span class="token comment" spellcheck="true">// UpdateStorage is called by a miner to adjust the storage market actors</span>
	<span class="token comment" spellcheck="true">// accounting of the total storage in the storage market.</span>
	<span class="token function">UpdateStorage</span><span class="token punctuation">(</span>delta BytesAmount<span class="token punctuation">)</span>

	<span class="token comment" spellcheck="true">// GetTotalStorage returns the total committed storage in the system. This number is</span>
	<span class="token comment" spellcheck="true">// also used as the 'total power' in the system for the purposes of the power table</span>
	<span class="token function">GetTotalStorage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> BytesAmount
<span class="token punctuation">}</span>
</code></pre></section><section id="sec-The-Filecoin-Storage-Market-Operation" secid="5.3"><h3><span class="spec-secid" title="link to this section"><a href="#sec-The-Filecoin-Storage-Market-Operation">5.3</a></span>The Filecoin Storage Market Operation</h3><p>The Filecoin storage market operates as follows. Miners providing storage submit ask orders, asking for a certain price for their available storage space, and clients with files to store look through the asks and select a miner they wish to use. Clients negotiate directly with the storage miner that owns that ask, off&#8208;chain. Storage is priced in terms of Filecoin per byte per block (note: we may change the units here).</p><section id="sec-Market-Datastructures" secid="5.3.1"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Market-Datastructures">5.3.1</a></span>Market Datastructures</h4><div class="spec-todo">This storage&#8208;market.md doc should try to describe the high level interfaces of the storage market, details about storage and specific method behavior should go in a separate place where we talk about individual system actors.</div><p>The storage market contains the following data:</p><ul><li>StorageMiners &ndash; The storage market keeps track of the set of the addresses of all storage miners in the storage market. All miners referenced here were created by the storage market via the <code>CreateMiner</code> method.</li><li>TotalComittedStorage &ndash; This is a tally of all the committed storage in the network. This is both a nice metric to see how much data is being stored by the filecoin network, and a critical piece of information used by mining routine to compute each miners storage ratio.</li></ul></section></section><section id="sec-Market-Flow" secid="5.4"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Market-Flow">5.4</a></span>Market Flow</h3><p>This section describes the flow required to store a single piece with a single storage miner. Most use&#8208;cases will involve performing this process for multiple pieces, with different miners.</p><section id="sec-Before-Deal" secid="5.4.1"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Before-Deal">5.4.1</a></span>Before Deal</h4><ol><li><strong>Merkle Translation:</strong> The client runs a&lsquo;Local Merkle Translation&rsquo; to generate the storage market hash for the data.<ul><li>Storage miners reference data by its storage market hash, and not by its standard hash. This step is needed for the client to be able to trust their data was correctly included in the miners sector. See <a href="definitions.md#piece-inclusion-proof">Piece Inclusion Proof</a></li></ul></li><li><strong>Miner Selection:</strong> The client looks at asks on the network, and then selects a storage miner to store their data with.<ul><li>Note: this is currently a manual process.</li></ul></li><li><strong>Payment Channel Setup:</strong> The client calls <a href="#payments"><code>Payment.Setup</code></a> with the piece and the funds they are going to pay the miner with. All payments between clients and storage providers use payment channels.</li></ol></section><section id="sec-Market-Flow.Deal" secid="5.4.2"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Market-Flow.Deal">5.4.2</a></span>Deal</h4><div class="spec-note">The details of this protocol including formats, datastructures, and algorithms, can be found <a href="network-protocols.md#storage-deal">here</a>.</div><ol><li><strong>Storage Deal Staging:</strong> The client now runs the <a href="network-protocols.md#storage-deal">&lsquo;make storage deal&rsquo;</a> protocol, as follows:<ul><li>The client sends a <code>StorageDealProposal</code> for the piece in question<ul><li>This contains updates for the payment channel that the client may close at any time, unless the piece gets confirmed (see next section), in which case the miner is able to extend the channel.</li></ul></li><li>The miner decides whether or not to accept the deal and sends back a <code>StorageDealResponse</code><ul><li>Note: Different implementations may come up with different ways of making a decision on a given deal.</li></ul></li><li>If the miner accepts, the client now sends the data to the miner</li><li>Once the miner receives the data:<ul><li>They validate that the data matches the storage market hash claimed by the client</li><li>They stage it into a sector and set the deal state to <code>Staged</code></li></ul></li></ul></li><li><strong>Storage Deal Start</strong>: Clients makes sure data is in a <a href="definitions.md#sector">sector</a><ul><li><strong>PieceInclusionProof:</strong> Once the miner seals the sector, they update the PieceInclusionProof in the deal state, which the client then gets the next time they query that state.</li><li>The PieceInclusionProof proves that the piece in the deal is contained in a sector whose commitment is on chain. The&lsquo;Merkle Translation&rsquo; hash from earlier is used here. See <a href="proofs.md#piece-inclusion-proof">piece inclusion proof for more details</a></li><li>Note: a client that is not interested in staying online to wait for PieceInclusionProof can leave immediately, however, they run the risk that their files don&rsquo;t actually get stored (but if their data is not stored, the miner will not be able to claim payment for it).</li><li>Note: In order to provide the piece inclusion proof, the miner needs to fill the sector. This may take some time. So there is a wait between the time the data is transferred to the miner, and when the piece inclusion proof becomes available.</li></ul></li><li><strong>Mining</strong>: Miner posts <code>seal commitment</code> and associated proof on chain by calling <code>CommitSector</code> and starts running <code>proofs of spacetime</code>. See <a href="mining.md#storage-mining-cycle">storage mining cycle</a> for more details.</li><li><strong>Storage Deal Abort:</strong> If the miner doesn&rsquo;t provide the PieceInclusionProof, the client can invalidate the payment channel.<ul><li>This is done by invoking the&lsquo;close&rsquo; method on the channel on&#8208;chain. This process starts a timer that, on finishing, will release the funds to the client.</li><li>If a client attempts to abort a deal that they have actually made with a miner, the miner can submit a payment channel update to force the channel to stay open for the length of the agreement.</li></ul></li><li><strong>Storage Deal Complete:</strong> The client periodically queries the miner for the deals status until the deal is&lsquo;complete&rsquo;, at which point the client knows that the data is properly replicated.<ul><li>The client should store the returned&lsquo;PieceInclusionProof&rsquo; for later validation.</li></ul></li></ol><div class="spec-todo">&lsquo;complete&rsquo; isnt really the right word here, as it implies that the deal is over.</div><ol><li><strong>Income Withdrawal</strong>: When the miner wishes to withdraw funds, they call <a href="#payments"><code>Payment.RedeemVoucher</code></a>.</li></ol></section></section><section id="sec-The-Power-Table" secid="5.5"><h3><span class="spec-secid" title="link to this section"><a href="#sec-The-Power-Table">5.5</a></span>The Power Table</h3><p>The <code>power table</code> is exported by the storage market for use by consensus. There isn&rsquo;t actually a concrete object that is the power table, instead, there is a&lsquo;total power&rsquo; exported by the storage market actor, and each individual miner reports its power through their actor.</p><div class="spec-todo">rephrase the above to make it clear that power is updated only on PoSt submission and when slashed.</div><section id="sec-Power-Updates" secid="5.5.1"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Power-Updates">5.5.1</a></span>Power Updates</h4><p>A miners power is updated only when they submit a valid PoSt to the chain, or if they are slashed.</p><div class="spec-todo">link to methods for post submission and slashing.</div><p>Power is deducted when miners remove sectors by reporting the sector&lsquo;missing&rsquo; or&lsquo;done&rsquo; in a PoSt.</p></section></section><section id="sec-The-Filecoin-Storage-Market.Payments" secid="5.6"><h3><span class="spec-secid" title="link to this section"><a href="#sec-The-Filecoin-Storage-Market.Payments">5.6</a></span>Payments</h3><p>The storage market expects a payments system to allow clients to pay miners for storage. Any payments system that has the following capabilities may be used:</p><pre><code><span class="token keyword">type</span> Payments <span class="token keyword">interface</span> <span class="token punctuation">{</span>
	<span class="token comment" spellcheck="true">// Setup sets up a payment from the caller to the target address. The payment</span>
	<span class="token comment" spellcheck="true">// MUST be contingent on the miner being able to prove that they have the data</span>
	<span class="token comment" spellcheck="true">// referenced by 'piece'. The total amount of Filecoin that may be transfered by</span>
	<span class="token comment" spellcheck="true">// this payment is specified by 'value'</span>
	<span class="token function">Setup</span><span class="token punctuation">(</span>target Address<span class="token punctuation">,</span> piece Cid<span class="token punctuation">,</span> value TokenAmount<span class="token punctuation">)</span> ID

	<span class="token comment" spellcheck="true">// MakeVouchers creates a set of vouchers redeemable by the target of the</span>
	<span class="token comment" spellcheck="true">// previously created payment. It creates 'count' vouchers, each of which is</span>
	<span class="token comment" spellcheck="true">// redeemable only after an certain block height, evenly spaced out between</span>
	<span class="token comment" spellcheck="true">// start and end. Each voucher should be redeemable for proportionally more</span>
	<span class="token comment" spellcheck="true">// Filecoin, up to the total amount specified during the payment setup.</span>
	<span class="token function">MakeVouchers</span><span class="token punctuation">(</span>id ID<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end BlockHeight<span class="token punctuation">,</span> count <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>Voucher

	<span class="token comment" spellcheck="true">// Redeem voucher is called by the target of a given payment to claim the</span>
	<span class="token comment" spellcheck="true">// funds represented by it. The voucher can only be redeemed after the block</span>
	<span class="token comment" spellcheck="true">// height that is attributed to the voucher, and also only if the proof given</span>
	<span class="token comment" spellcheck="true">// proves that the target is correctly storing the piece referenced in the</span>
	<span class="token comment" spellcheck="true">// payment setup.</span>
	<span class="token function">RedeemVoucher</span><span class="token punctuation">(</span>v Voucher<span class="token punctuation">,</span> proof Proof<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><p>For details on the implementation of the payments system, see <a href="payments.md">the payments doc</a>.</p></section><section id="sec-Future-Protocol-Improvements" secid="5.7"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Future-Protocol-Improvements">5.7</a></span>Future Protocol Improvements</h3><ul><li>Slashable Commitments<ul><li>When miners initially receive the data for a deal with a client, that signed response statement can be used to slash the miner in the event that they never include that data in a sector.</li></ul></li></ul></section><section id="sec-Open-questions" secid="5.8"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Open-questions">5.8</a></span>Open questions</h3><ul><li>Storage time should likely be designated in terms of proving period. Where a proving period is the number of blocks in which every miner must submit a proof for their sectors. Not doing this makes accounting hard: &ldquo;when exactly did this sector fail?&rdquo; </li></ul></section></section><section id="sec--Retrieval-Market-V0" secid="6"><h2><span class="spec-secid" title="link to this section"><a href="#sec--Retrieval-Market-V0">6</a></span>`Retrieval Market` V0</h2><section id="sec-What-is-the-Retrieval-Market-" secid="6.1"><h3><span class="spec-secid" title="link to this section"><a href="#sec-What-is-the-Retrieval-Market-">6.1</a></span>What is the `Retrieval Market`</h3></section><section id="sec-What-the-Retrieval-Market-affects" secid="6.2"><h3><span class="spec-secid" title="link to this section"><a href="#sec-What-the-Retrieval-Market-affects">6.2</a></span>What the `Retrieval Market` affects</h3></section><section id="sec--Retrieval-Market-V0.Dependencies" secid="6.3"><h3><span class="spec-secid" title="link to this section"><a href="#sec--Retrieval-Market-V0.Dependencies">6.3</a></span>Dependencies</h3></section><section id="sec-Components" secid="6.4"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Components">6.4</a></span>Components</h3><p>Version 0 of the <code>retrieval market</code> protocol is what we (tentatively) will launch the filecoin network with. It is version zero because it will only be good enough to fit the bill as a way to pay another node for a file.</p><p>The main components are as follows:</p><ul><li>A payment channel actor (See <a href="payment-channels.md">payment channels</a> for details)</li><li>&lsquo;retrieval&#8208;v0&rsquo; <code>libp2p</code> services</li><li>A chain&#8208;based content routing interface</li><li>A set of commands to interact with the above</li></ul></section><section id="sec-Retrieval-V0-libp2p-Services" secid="6.5"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Retrieval-V0-libp2p-Services">6.5</a></span>Retrieval V0 `libp2p` Services</h3><p>The v0 <code>retrieval market</code> will initially be implemented as two <code>libp2p</code> services. It will be request response based, where the client who is requesting a file sends a <code>retrieval deal proposal</code> to the miner. The miner chooses whether or not to accept it, sends their response which (if they accept the proposal) includes a <code>signed retrieval deal</code>, followed by the actual requested content, streamed as a series of bitswap block messages, using a pre&#8208;order traversal of the dag. Each block should use the <a href="https://github.com/ipfs/go-ipfs/blob/master/exchange/bitswap/message/message.go#L216">bitswap block message format</a>. This way, the client should be able to verify the data incrementally as it receives it. Once the client has received all the data, it should then send a payment channel SpendVoucher of the proposed amount to the miner. This protocol may be easily extended to include payments from the client to the miner every N blocks, but for now we omit that feature.</p><pre><code><span class="token keyword">type</span> RetDealProposal <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	<span class="token comment" spellcheck="true">// Ref is the cid of the data to be retrieved</span>
	Ref Cid

	<span class="token comment" spellcheck="true">// Price is the total amount that the client is willing to pay for the</span>
	<span class="token comment" spellcheck="true">// retrieval of the data</span>
	Price TokenAmount

	<span class="token comment" spellcheck="true">// Payment is a payment info from the client to the retrieval miner for the data</span>
	Payment PaymentInfo
<span class="token punctuation">}</span>

<span class="token keyword">type</span> ResponseStatus <span class="token builtin">uint</span>

<span class="token keyword">const</span> <span class="token punctuation">(</span>
	Unset <span class="token operator">=</span> <span class="token function">ResponseStatus</span><span class="token punctuation">(</span><span class="token boolean">iota</span><span class="token punctuation">)</span>
	Accepted
	Rejected
	Error
<span class="token punctuation">)</span>

<span class="token keyword">type</span> RetDealResponse <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	Status  ResponseStatus
	Message <span class="token builtin">string</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> Block <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	<span class="token comment" spellcheck="true">// Prefix is the cid prefix parameters for this block. It describes how to</span>
	<span class="token comment" spellcheck="true">// hash the block to verify it matches the expected value.</span>
	Prefix CidPrefix
	Data   <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span>
<span class="token punctuation">}</span>
</code></pre><p><code>Retrieval miners</code> should also support a query service that allows clients to request pricing information from a miner.</p><p>The query should include the CID of the piece that the client is interested in retrieving. The response contains whether or not the miner will serve that data, the price they will accept for it.</p><pre><code><span class="token keyword">type</span> RetQuery <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	Piece Cid
<span class="token punctuation">}</span>

<span class="token keyword">type</span> RetQueryResponse <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	Status   RetQueryStatus
	MinPrice TokenAmount
<span class="token punctuation">}</span>

<span class="token keyword">type</span> RetQueryStatus <span class="token builtin">uint</span>

<span class="token keyword">const</span> <span class="token punctuation">(</span>
	Unset <span class="token operator">=</span> <span class="token function">RetQueryStatus</span><span class="token punctuation">(</span><span class="token boolean">iota</span><span class="token punctuation">)</span>
	OK
	PieceUnavailable
<span class="token punctuation">)</span>
</code></pre></section><section id="sec-Chain-Based-Content-Routing" secid="6.6"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Chain-Based-Content-Routing">6.6</a></span>Chain Based Content Routing</h3><p>For the version 0 protocol. We should implement a small helper service that looks up which miners have a given piece based on deals made in the blockchain. The service should first look the content up in the blockchain (or in some client index) to find the chain address of the miner, then use the lookup service to map that to a <code>libp2p</code> <code>peerID</code> and <code>multiaddr</code>.</p><p>The interface should match the exist libp2p content routing interface:</p><pre><code><span class="token keyword">type</span> ChainContentRouting <span class="token keyword">interface</span> <span class="token punctuation">{</span>
	<span class="token function">FindProvidersAsync</span><span class="token punctuation">(</span>ref Cid<span class="token punctuation">,</span> count <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">&lt;-</span><span class="token keyword">chan</span> pstore<span class="token punctuation">.</span>PeerInfo
<span class="token punctuation">}</span>
</code></pre></section><section id="sec-Retrieval-Market-Commands" secid="6.7"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Retrieval-Market-Commands">6.7</a></span>Retrieval Market Commands</h3><p>We will need to add a few commands to allow the user to interact with the <code>retrieval market</code>, and for developers to be able to script higher level applications on top of it.</p><p>The command names here are not final, and are definitely subject to change later on once we are able to sit and think through proper UX.</p><pre><code>USAGE
  filecoin retr get &lt;piece-cid&gt; - Retrieve a piece from a miner.

SYNOPSIS
  filecoin retr get [--price=&lt;amt&gt;] [--miner=&lt;peerID&gt;] [--] &lt;piece-cid&gt;

ARGUMENTS

  &lt;piece-cid&gt; - Content ID of piece to retrieve.

OPTIONS

  --price                string - Amount of filecoin to offer for this data.
  --miner                string - Optional Peer ID of miner to connect to. (If unspecified, the chain routing service will be used)
</code></pre><pre><code>USAGE
  filecoin retr lookup &lt;piece-cid&gt; - Print a list of miners who have the given piece.

SYNOPSIS
  filecoin retr lookup [--sort=&lt;sorttype&gt;] [--] &lt;piece-cid&gt;

ARGUMENTS

  &lt;piece-cid&gt;... - Content ID of piece to find.

OPTIONS

  --sort                string - Output sorting scheme.
</code></pre><pre><code>USAGE
  filecoin retr query &lt;minerID&gt; [&lt;piece-cid&gt;] - Query the given retrieval miner.

SYNOPSIS
  filecoin retr query [--] &lt;miner-id&gt; [&lt;piece-cid&gt;]

ARGUMENTS

  &lt;miner-id&gt;  - ID of miner to query.
  [&lt;piece-cid&gt;] - Optional cid of piece to query for.
</code></pre></section></section><section id="sec-undefined.Payments" secid="7"><h2><span class="spec-secid" title="link to this section"><a href="#sec-undefined.Payments">7</a></span>Payments</h2><section id="sec-What-are-payments" secid="7.1"><h3><span class="spec-secid" title="link to this section"><a href="#sec-What-are-payments">7.1</a></span>What are payments</h3></section><section id="sec-What-payments-affect" secid="7.2"><h3><span class="spec-secid" title="link to this section"><a href="#sec-What-payments-affect">7.2</a></span>What payments affect</h3></section><section id="sec-undefined.Payments.Dependencies" secid="7.3"><h3><span class="spec-secid" title="link to this section"><a href="#sec-undefined.Payments.Dependencies">7.3</a></span>Dependencies</h3></section><section id="sec-Miners-Claiming-Earnings" secid="7.4"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Miners-Claiming-Earnings">7.4</a></span>Miners Claiming Earnings</h3><p>Storage miners get paid entirely through payment channels. Payment from a client to a storage miner comes in the form of a set of channel updates that get created when proposing the deal. These updates are each time&#8208;locked, and can only be cashed out if the storage miner has not been slashed for the storage that is being paid for. (TODO: working on a multi&#8208;lane payment channel construction that should make this all pretty easy, only requiring a single on&#8208;chain channel construction between each client and storage miner).</p></section><section id="sec-Payment-Channels" secid="7.5"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Payment-Channels">7.5</a></span>Payment Channels</h3><p>In order for the Filecoin Markets to work in a timely manner, we need to be able to have off&#8208;chain payments. This is a solved problem (at least, for our purposes in v0). Payment channels have been implemented and used in bitcoin, ethereum and many other networks.</p><p>The basic premise is this: User A wants to be able to send many small payments to user B. So user A locks up money in a contract that says &ldquo;this money will only go to user B, and the unclaimed amount will be returned to user A after a set time period&rdquo;. Once that money is locked up, user A can send user B signed transactions that user B can cash out at any time.</p><p>For example:</p><ul><li>User A locks up 10 FIL to B</li><li>User B does something for A</li><li>User A sends <code>SignedVoucher{Channel, 1 FIL}</code> to B</li><li>User B does something for user A</li><li>User A sends <code>SignedVoucher{Channel, 2 FIL}</code> to B</li></ul><p>At this point, B has two signed messages from A, but the contract is set up such that it can only be cashed out once. So if B decided to cash out, they would obviously select the message with the higher value. Also, once B cashes out, they must not accept any more payments from A on that same channel.</p><section id="sec-Multi-Lane-Payment-Channel" secid="7.5.1"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Multi-Lane-Payment-Channel">7.5.1</a></span>Multi-Lane Payment Channel</h4><p>The filecoin storage market may require a way to do incremental payments between two parties, over time, for multiple different transactions. The primary motivating usecase for this is to provide payment for file storage over time, for each file stored. An additional requirement is the ability to have less than one message on chain per transaction&lsquo;lane&rsquo;, meaning that payments for multiple files should be aggregateable (Note: its okay if this aggregation is an interactive process).</p><p>Let&rsquo;s say that <code>A</code> wants to make such an arrangement with <code>B</code>. <code>A</code> should create the payment channel with enough funds to cover all potential transactions. Then <code>A</code> decides to start the first transaction, so they send a signed voucher for the payment channel on&lsquo;lane 1&rsquo;, for 2 FIL. They can then send more updates on lane 1 as needed. Then, at some point <code>A</code> decides to start another independent transaction to <code>B</code>, so they send a voucher on&lsquo;lane 2&rsquo;. The voucher for lane 2 can be cashed out independently of lane 1. However, <code>B</code> can ask <code>A</code> to&lsquo;reconcile&rsquo; the two payment channels for them into a single update. This update could contain a value, and a list of lanes to close. Cashing out that reconciled update would invalidate the other lanes, meaning <code>B</code> couldnt also cash in those. The single update would be much smaller, and therefore cheaper to close out.</p><p>Lane state can be easily tracked on&#8208;chain with a compact bitfield.</p><pre><code><span class="token keyword">type</span> SpendVoucher <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	<span class="token comment" spellcheck="true">// Amount is the amount of FIL that this voucher can be redeemed for</span>
	Amount TokenAmount

	<span class="token comment" spellcheck="true">// Nonce is a number that sets the ordering of vouchers. If you try to redeem</span>
	<span class="token comment" spellcheck="true">// a voucher with an equal or lower nonce, the operation will fail. Nonces are</span>
	<span class="token comment" spellcheck="true">// per lane.</span>
	Nonce <span class="token builtin">uint64</span>

	<span class="token comment" spellcheck="true">// Lane specifies which 'lane' of the payment channel this voucher is for.</span>
	<span class="token comment" spellcheck="true">// Lanes may be either open or closed, a voucher for a closed lane may not be redeemed</span>
	Lane <span class="token builtin">uint64</span>

	<span class="token comment" spellcheck="true">// Merges specifies a list of lane-nonce pairs that this voucher will close.</span>
	<span class="token comment" spellcheck="true">// This voucher may not be redeemed if any of the lanes specified here are already</span>
	<span class="token comment" spellcheck="true">// closed, or their nonce specified here is lower than the nonce of the lane on-chain.</span>
	Merges <span class="token punctuation">[</span><span class="token punctuation">]</span>MergePair

	TimeLock <span class="token builtin">uint64</span>

	SecretPreimage <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span>

	RequiredSector <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span>

	DataCommitment <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span>

	MinCloseHeight <span class="token builtin">uint64</span>

	Sig Signature
<span class="token punctuation">}</span>

<span class="token keyword">type</span> MergePair <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	Lane  <span class="token builtin">uint64</span>
	Nonce <span class="token builtin">uint64</span>
<span class="token punctuation">}</span>
</code></pre><pre><code><span class="token keyword">type</span> PaymentChannel <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	From Address
	To   Address

	ChannelTotal TokenAmount
	ToSend       TokenAmount

	ClosingAt      <span class="token builtin">uint64</span>
	MinCloseHeight <span class="token builtin">uint64</span>

	LaneStates <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">uint64</span><span class="token punctuation">]</span>LaneState
<span class="token punctuation">}</span>

<span class="token keyword">type</span> LaneState <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	Nonce    <span class="token builtin">uint64</span>
	Redeemed TokenAmount
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>paych <span class="token operator">*</span>PaymentChannel<span class="token punctuation">)</span> <span class="token function">validateSignature</span><span class="token punctuation">(</span>sv SpendVoucher<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> msg<span class="token punctuation">.</span>From <span class="token operator">==</span> paych<span class="token punctuation">.</span>From <span class="token punctuation">{</span>
		<span class="token function">ValidateSignature</span><span class="token punctuation">(</span>sv<span class="token punctuation">.</span><span class="token function">SerializeNoSig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> sv<span class="token punctuation">.</span>Signature<span class="token punctuation">,</span> paych<span class="token punctuation">.</span>To<span class="token punctuation">)</span>
	<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> msg<span class="token punctuation">.</span>From <span class="token operator">==</span> paych<span class="token punctuation">.</span>To <span class="token punctuation">{</span>
		<span class="token function">ValidateSignature</span><span class="token punctuation">(</span>sv<span class="token punctuation">.</span><span class="token function">SerializeNoSig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> sv<span class="token punctuation">.</span>Signature<span class="token punctuation">,</span> paych<span class="token punctuation">.</span>From<span class="token punctuation">)</span>
	<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
		<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"bad programmer"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>paych <span class="token operator">*</span>PaymentChannel<span class="token punctuation">)</span> <span class="token function">UpdateChannelState</span><span class="token punctuation">(</span>sv SpendVoucher<span class="token punctuation">,</span> secret <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> pip <span class="token operator">*</span>PieceInclusionProof<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> <span class="token operator">!</span>paych<span class="token punctuation">.</span><span class="token function">validateSignature</span><span class="token punctuation">(</span>sv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"Signature Invalid"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">if</span> chain<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> sv<span class="token punctuation">.</span>TimeLock <span class="token punctuation">{</span>
		<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"cannot use this voucher yet!"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">if</span> sv<span class="token punctuation">.</span>SecretPreimage <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span> <span class="token function">Hash</span><span class="token punctuation">(</span>secret<span class="token punctuation">)</span> <span class="token operator">!=</span> sv<span class="token punctuation">.</span>SecretPreimage <span class="token punctuation">{</span>
			<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"Incorrect secret!"</span><span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">if</span> sv<span class="token punctuation">.</span>DataCommitment <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
		<span class="token comment" spellcheck="true">// Checks that the piece inclusion proof is valid, and that the referenced sector</span>
		<span class="token comment" spellcheck="true">// is correctly being stored</span>
		<span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">ValidateInclusion</span><span class="token punctuation">(</span>pip<span class="token punctuation">,</span> sv<span class="token punctuation">.</span>DataCommitment<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"PieceInclusionProof was invalid"</span><span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">if</span> sv<span class="token punctuation">.</span>RequiredSector <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
		miner<span class="token punctuation">,</span> found <span class="token operator">:=</span> <span class="token function">GetMiner</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>From<span class="token punctuation">)</span>
		<span class="token keyword">if</span> <span class="token operator">!</span>found <span class="token punctuation">{</span>
			<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"Redeemer is not a miner"</span><span class="token punctuation">)</span>
		<span class="token punctuation">}</span>

		<span class="token keyword">if</span> <span class="token operator">!</span>miner<span class="token punctuation">.</span><span class="token function">HasSector</span><span class="token punctuation">(</span>sv<span class="token punctuation">.</span>RequiredSector<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"miner does not have sector, cannot redeem payment"</span><span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	ls <span class="token operator">:=</span> paych<span class="token punctuation">.</span>LaneStates<span class="token punctuation">[</span>sv<span class="token punctuation">.</span>Lane<span class="token punctuation">]</span>
	<span class="token keyword">if</span> ls<span class="token punctuation">.</span>Closed <span class="token punctuation">{</span>
		<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"cannot redeem a voucher on a closed lane"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">if</span> ls<span class="token punctuation">.</span>Nonce <span class="token operator">></span> sv<span class="token punctuation">.</span>Nonce <span class="token punctuation">{</span>
		<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"voucher has an outdated nonce, cannot redeem"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">var</span> mergeValue TokenAmount
	<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> merge <span class="token operator">:=</span> <span class="token keyword">range</span> sv<span class="token punctuation">.</span>Merges <span class="token punctuation">{</span>
		ols <span class="token operator">:=</span> paych<span class="token punctuation">.</span>LaneStates<span class="token punctuation">[</span>merge<span class="token punctuation">.</span>Lane<span class="token punctuation">]</span>

		<span class="token keyword">if</span> ols<span class="token punctuation">.</span>Nonce <span class="token operator">>=</span> merge<span class="token punctuation">.</span>Nonce <span class="token punctuation">{</span>
			<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"merge in voucher has outdated nonce, cannot redeem"</span><span class="token punctuation">)</span>
		<span class="token punctuation">}</span>

		mergeValue <span class="token operator">+=</span> ols<span class="token punctuation">.</span>Redeemed
		ols<span class="token punctuation">.</span>Nonce <span class="token operator">=</span> merge<span class="token punctuation">.</span>Nonce
	<span class="token punctuation">}</span>

	ls<span class="token punctuation">.</span>Nonce <span class="token operator">=</span> sv<span class="token punctuation">.</span>Nonce
	balanceDelta <span class="token operator">=</span> sv<span class="token punctuation">.</span>Amount <span class="token operator">-</span> <span class="token punctuation">(</span>mergeValue <span class="token operator">+</span> ls<span class="token punctuation">.</span>Redeemed<span class="token punctuation">)</span>
	ls<span class="token punctuation">.</span>Redeemed <span class="token operator">=</span> sv<span class="token punctuation">.</span>Amount

	newSendBalance <span class="token operator">=</span> paych<span class="token punctuation">.</span>ToSend <span class="token operator">+</span> balanceDelta
	<span class="token keyword">if</span> newSendBalance <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">{</span>
		<span class="token comment" spellcheck="true">// TODO: is this impossible?</span>
		<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"voucher would leave channel balance negative"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">if</span> newSendBalance <span class="token operator">></span> paych<span class="token punctuation">.</span>ChannelTotal <span class="token punctuation">{</span>
		<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"not enough funds in channel to cover voucher"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	paych<span class="token punctuation">.</span>ToSend <span class="token operator">=</span> newSendBalance

	<span class="token keyword">if</span> sv<span class="token punctuation">.</span>MinCloseHeight <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span> paych<span class="token punctuation">.</span>ClosingAt <span class="token operator">&lt;</span> sv<span class="token punctuation">.</span>MinCloseHeight <span class="token punctuation">{</span>
			paych<span class="token punctuation">.</span>ClosingAt <span class="token operator">=</span> sv<span class="token punctuation">.</span>MinCloseHeight
		<span class="token punctuation">}</span>
		<span class="token keyword">if</span> paych<span class="token punctuation">.</span>MinCloseHeight <span class="token operator">&lt;</span> sv<span class="token punctuation">.</span>MinCloseHeight <span class="token punctuation">{</span>
			paych<span class="token punctuation">.</span>MinCloseHeight <span class="token operator">=</span> sv<span class="token punctuation">.</span>MinCloseHeight
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>paych <span class="token operator">*</span>PaymentChannel<span class="token punctuation">)</span> <span class="token function">Withdraw</span><span class="token punctuation">(</span>upTo TokenAmount<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment" spellcheck="true">// TODO: this ones tricky, withdraw funds without closing it out entirely...</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>paych <span class="token operator">*</span>PaymentChannel<span class="token punctuation">)</span> <span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> msg<span class="token punctuation">.</span>From <span class="token operator">!=</span> paych<span class="token punctuation">.</span>From <span class="token operator">&amp;&amp;</span> msg<span class="token punctuation">.</span>From <span class="token operator">!=</span> paych<span class="token punctuation">.</span>To <span class="token punctuation">{</span>
		<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"not authorized to close channel"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">if</span> paych<span class="token punctuation">.</span>ClosingAt <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>
		<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"Channel already closing"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	paych<span class="token punctuation">.</span>ClosingAt <span class="token operator">=</span> chain<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> ChannelClosingDelay
	<span class="token keyword">if</span> paych<span class="token punctuation">.</span>ClosingAt <span class="token operator">&lt;</span> paych<span class="token punctuation">.</span>MinCloseHeight <span class="token punctuation">{</span>
		paych<span class="token punctuation">.</span>ClosingAt <span class="token operator">=</span> paych<span class="token punctuation">.</span>MinCloseHeight
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>paych <span class="token operator">*</span>PaymentChannel<span class="token punctuation">)</span> <span class="token function">Collect</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> paych<span class="token punctuation">.</span>ClosingAt <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>
		<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"payment channel not closing or closed"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">if</span> chain<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> paych<span class="token punctuation">.</span>ClosingAt <span class="token punctuation">{</span>
		<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"Payment channel not yet closed"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token function">Transfer</span><span class="token punctuation">(</span>paych<span class="token punctuation">.</span>ChannelTotal<span class="token operator">-</span>paych<span class="token punctuation">.</span>ToSend<span class="token punctuation">,</span> paych<span class="token punctuation">.</span>From<span class="token punctuation">)</span>
	<span class="token function">Transfer</span><span class="token punctuation">(</span>paych<span class="token punctuation">.</span>ToSend<span class="token punctuation">,</span> paych<span class="token punctuation">.</span>To<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></section><section id="sec-Payment-Channel-Reconciliation" secid="7.5.2"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Payment-Channel-Reconciliation">7.5.2</a></span>Payment Channel Reconciliation</h4><p>In a situation where peers A and B have several different payment channels between them, the scenario may frequently come up where A has multiple payment channel updates from B to apply. Submitting each of these individually would cost a noticeable amount in fees, and put excess unnecessary load on the chain. To remedy this, A can contact B and ask them for a single payment channel update for the combined value of all the updates they have (minus some fee to incent B to actually want to do this). This aggregated update would contain a list of the IDs of the other payment channels that it is superceding so that A cannot also cash out on the originals.</p></section></section></section><section id="sec-Payment-Reconciliation" secid="8"><h2><span class="spec-secid" title="link to this section"><a href="#sec-Payment-Reconciliation">8</a></span>Payment Reconciliation</h2><p>The filecoin storage market will (likely) have many independent payments between the same parties. These payments will be secured through payment channels, set up initially on chain, but utilized almost entirely off&#8208;chain. The point at which they need to touch the chain is when miners wish to cash out their earnings. A naive solution to this problem would have miners perform one on&#8208;chain action per file stored for a particular client. This would not scale well. Instead, we need a system where the miner and client can have some additional off&#8208;chain communication and end up with the miner submitting only a single message to the chain.</p><p>To accomplish this, we introduce the Payment Reconciliation Protocol.</p><p>This is a libp2p service run by all participants wanting to participate in payment reconciliation. When Alice has a set of payments from Bob that she is ready to cash out, Alice can send a <code>ReconcileRequest</code> to Bob, containing the following information:</p><pre><code><span class="token keyword">type</span> ReconcileRequest <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	Vouchers <span class="token punctuation">[</span><span class="token punctuation">]</span>Vouchers

	ReqVal TokenAmount
<span class="token punctuation">}</span>
</code></pre><p>The Vouchers should all be valid vouchers from Bob to Alice, on the same payment channel, and they should all be ready to be cashed in. <code>ReqVal</code> is a token amount less than or equal to the sum of all the values in the given vouchers. Generally, this value will be between the total sum of the vouchers, and that total sum minus the fees it would cost to submit them all to the chain.</p><p>Bob receives this request, and checks that all the fields are correct, and then ensures that the difference between ReqVal and the vouchers sum is sufficient (this is a parameter that the client can set). Then, he sends back a response which either contains the requested voucher, or an error status and message.</p><pre><code><span class="token keyword">type</span> ReconcileResponse <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	Combined Voucher

	Status  StatusCode
	Message <span class="token builtin">string</span>
<span class="token punctuation">}</span>
</code></pre><p>Open Questions:</p><ul><li>In a number of usecases, this protocol will require the miner look up and connect to a client to propose reconciliation. How does a miner look up and connect to a client over libp2p given only their filecoin address?</li><li>Without repair miners, this protocol will likely not be used that much. Should that be made clear? Should there be other considerations added to compensate?</li></ul><section id="sec-Storage-Miner-Payments" secid="8.1"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Storage-Miner-Payments">8.1</a></span>Storage Miner Payments</h3><div class="spec-todo">these bits were pulled out of a different doc, and describe strategies by which client payments to a miner might happen. We need to organize&lsquo;clients paying miners&rsquo; better, unclear if it should be the same doc that talks about payment channel constructions.</div><ol><li><strong>Updates Contingent on Inclusion Proof</strong><ul><li>In this case, the miner must provide an inclusion proof that shows the client data is contained in one of the miners sectors on chain, and submit that along with the payment channel update.</li><li>This can be pretty expensive for smaller files, and ideally, we make it to one of the latter two options</li><li>This option does however allow clients to upload their files and leave.</li></ul></li><li><strong>Update Contingent on CommD Existence</strong><ul><li>For this, the client needs to wait around until the miner finishes packing a sector, and computing its commD. The client then signs a set of payment channel updates that are contingent on the given commD existing on chain.</li><li>This route makes it difficult for miners to re&#8208;seal smaller files (really, small files just suck)</li></ul></li><li><strong>Reconciled Payment</strong></li><li>In either of the above cases, the miner may go back to the client and say &ldquo;Look, these payment channel updates you gave me are able to be cashed in right now, could you take them all and give me back a single update for a slightly smaller amount?&rdquo;.</li><li>The slightly smaller amount could be the difference in transaction fees, meaning the client saves money, and the miner gets the same amount. </li></ol></section></section><section id="sec-undefined.Mining" secid="9"><h2><span class="spec-secid" title="link to this section"><a href="#sec-undefined.Mining">9</a></span>Mining</h2><section id="sec-What-is-the-Filecoin-Mining-Process" secid="9.1"><h3><span class="spec-secid" title="link to this section"><a href="#sec-What-is-the-Filecoin-Mining-Process">9.1</a></span>What is the Filecoin Mining Process</h3><p>An active participant in the filecoin consensus process is a storage miner and expected consensus block proposer. They are responsible for storing data for the filecoin network and also for driving the filecoin consensus process. Miners should constantly be performing Proofs of SpaceTime, and also checking if they have a winning <code>ticket</code> to propose a block for each round. Rounds are currently set to take around 30 seconds, in order to account for network propagation around the world. The details of both processes are defined here.</p><p>Any block proposer must be a storage miner, but storage miners can avoid performing the block proposer tasks, however in this way, they will be losing out on block rewards and transaction fees.</p></section><section id="sec-The-Miner-Actor" secid="9.2"><h3><span class="spec-secid" title="link to this section"><a href="#sec-The-Miner-Actor">9.2</a></span>The Miner Actor</h3><p>After successfully calling <code>CreateMiner</code>, a miner actor will be created on&#8208;chain, and registered in the storage market. This miner, like all other Filecoin State Machine actors, has a fixed set of methods that can be used to interact with or control it.</p><p>For details on the methods on the miner actor, see its entry in the <a href="actors.md#storage-miner-actor">actors spec</a>.</p><section id="sec-Owner-Worker-distinction" secid="9.2.1"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Owner-Worker-distinction">9.2.1</a></span>Owner Worker distinction</h4><p>The miner actor has two distinct&lsquo;controller&rsquo; addresses. One is the worker, which is the address which will be responsible for doing all of the work, submitting proofs, committing new sectors, and all other day to day activities. The owner address is the address that created the miner, paid the collateral, and has block rewards paid out to it. The reason for the distinction is to allow different parties to fulfil the different roles. One example would be for the owner to be a multisig wallet, or a cold storage key, and the worker key to be a&lsquo;hot wallet&rsquo; key.</p></section><section id="sec-Storage-Mining-Cycle" secid="9.2.2"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Storage-Mining-Cycle">9.2.2</a></span>Storage Mining Cycle</h4><p>Storage miners must continually produce Proofs of SpaceTime over their storage to convince the network that they are actually storing the sectors that they have committed to. Each PoSt covers a miner&rsquo;s entire storage.</p><section id="sec-Step-0-Registration" secid="9.2.2.1"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Step-0-Registration">9.2.2.1</a></span>Step 0: Registration</h5><p>To initially become a miner, a miner first register a new miner actor on&#8208;chain. This is done through the storage market actor&rsquo;s <a href="actors.md#createstorageminer"><code>CreateMiner</code></a> method. The call will then create a new miner actor instance and return its address.</p><p>The next step is to place one or more storage market asks on the market. This is done through the storage markets <a href="actors.md#addask"><code>AddAsk</code></a> method. A miner may create a single ask for their entire storage, or partition their storage up in some way with multiple asks (at potentially different prices).</p><p>After that, they need to make deals with clients and begin filling up sectors with data. For more information on making deals, see the section on <a href="storage-market.md#deal">deal</a>.</p><p>When they have a full sector, they should seal it. This is done by invoking <a href="proofs.md#seal"><code>PoRep.Seal</code></a> on the sector.</p></section><section id="sec-Step-1-Commit" secid="9.2.2.2"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Step-1-Commit">9.2.2.2</a></span>Step 1: Commit</h5><p>When the miner has completed their first seal, they should post it on&#8208;chain using <a href="actors.md#commitsector">CommitSector</a>. If the miner had zero committed sectors prior to this call, this begins their proving period.</p><p>The proving period is a fixed amount of time in which the miner must submit a Proof of Space Time to the network.</p><p>During this period, the miner may also commit to new sectors, but they will not be included in proofs of space time until the next proving period starts.</p><div class="spec-todo">sectors need to be globally unique. This can be done either by having the seal proof prove the sector is unique to this miner in some way, or by having a giant global map on&#8208;chain is checked against on each submission. As the system moves towards sector aggregation, the latter option will become unworkable, so more thought needs to go into how that proof statement could work.</div></section><section id="sec-Step-2-Proving-Storage-PoSt-creation-" secid="9.2.2.3"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Step-2-Proving-Storage-PoSt-creation-">9.2.2.3</a></span>Step 2: Proving Storage (PoSt creation)</h5><p>At the beginning of their proving period, miners collect the proving set (the set of all live sealed sectors on the chain at this point), and then call <code>ProveStorage</code>. This process will take the entire proving period to complete.</p><pre><code><span class="token keyword">func</span> <span class="token function">ProveStorage</span><span class="token punctuation">(</span>sectorSize BytesAmount<span class="token punctuation">,</span> sectors <span class="token punctuation">[</span><span class="token punctuation">]</span>commR<span class="token punctuation">,</span> startTime BlockHeight<span class="token punctuation">)</span> <span class="token punctuation">(</span>PoSTProof<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>FaultSet<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">var</span> proofs <span class="token punctuation">[</span><span class="token punctuation">]</span>Proofs
	<span class="token keyword">var</span> seeds <span class="token punctuation">[</span><span class="token punctuation">]</span>Seed
	<span class="token keyword">var</span> faults <span class="token punctuation">[</span><span class="token punctuation">]</span>FaultSet
	<span class="token keyword">for</span> t <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> t <span class="token operator">&lt;</span> ProvingPeriod<span class="token punctuation">;</span> t <span class="token operator">+=</span> ReseedPeriod <span class="token punctuation">{</span>
		seeds <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>seeds<span class="token punctuation">,</span> <span class="token function">GetSeedFromBlock</span><span class="token punctuation">(</span>startTime<span class="token operator">+</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span>
		proof<span class="token punctuation">,</span> faultset <span class="token operator">:=</span> <span class="token function">GenPost</span><span class="token punctuation">(</span>sectors<span class="token punctuation">,</span> seeds<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">,</span> vdfParams<span class="token punctuation">)</span>
		proofs <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>proofs<span class="token punctuation">,</span> proof<span class="token punctuation">)</span>
		faults <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>faults<span class="token punctuation">,</span> faultset<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token function">GenPostSnark</span><span class="token punctuation">(</span>sectorSize<span class="token punctuation">,</span> sectors<span class="token punctuation">,</span> seeds<span class="token punctuation">,</span> proofs<span class="token punctuation">)</span><span class="token punctuation">,</span> faults
<span class="token punctuation">}</span>
</code></pre><div class="spec-note">See <a href="proofs.md#proof-of-space-time">&lsquo;Proof of Space Time&rsquo;</a> for more details.</div><p>The proving set remains consistent during the proving period. Any sectors added in the meantime will be included in the next proving set, at the beginning of the next proving period.</p></section><section id="sec-Step-3-PoSt-Submission" secid="9.2.2.4"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Step-3-PoSt-Submission">9.2.2.4</a></span>Step 3: PoSt Submission</h5><p>When the miner has completed their PoSt, they must submit it to the network by calling <a href="actors.md#submitpost">SubmitPoSt</a>. There are two different times that this <em>could</em> be done.</p><ol><li><strong>Standard Submission</strong>: A standard submission is one that makes it on&#8208;chain before the end of the proving period. The length of time it takes to compute the PoSts is set such that there is a grace period between then and the actual end of the proving period, so that the effects of network congestion on typical miner actions is minimized.</li><li><strong>Penalized Submission</strong>: A penalized submission is one that makes it on&#8208;chain after the end of the proving period, but before the generation attack threshold. These submissions count as valid PoSt submissions, but the miner must pay a penalty for their late submission. (See&lsquo;<a href="faults.md">Faults</a>&rsquo; for more information)<ul><li>Note: In this case, the next PoSt should still be started at the beginning of the proving period, even if the current one is not yet complete. Miners must submit one PoSt per proving period.</li></ul></li></ol><p>Along with the PoSt submission, miners may also submit a set of sectors that they wish to remove from their proving set. This is done by selecting the sectors in the&lsquo;done&rsquo; bitfield passed to <code>SubmitPoSt</code>.</p></section></section><section id="sec-Stop-Mining" secid="9.2.3"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Stop-Mining">9.2.3</a></span>Stop Mining</h4><p>In order to stop mining, a miner must complete all of its storage contracts, and remove them from their proving set during a PoSt submission. A miner may then call <a href="actors.md#depledge"><code>DePledge()</code></a> to retrieve their collateral. <code>DePledge</code> must be called twice, once to start the cooldown, and once again after the cooldown to reclaim the funds. The cooldown period is to allow clients whose files have been dropped by a miner to slash them before they get their money back and get away with it.</p></section><section id="sec-The-Miner-Actor.Faults" secid="9.2.4"><h4><span class="spec-secid" title="link to this section"><a href="#sec-The-Miner-Actor.Faults">9.2.4</a></span>Faults</h4><p>Faults are described in the <a href="faults.md">faults document</a>.</p></section><section id="sec-On-Being-Slashed-WIP-needs-discussion-" secid="9.2.5"><h4><span class="spec-secid" title="link to this section"><a href="#sec-On-Being-Slashed-WIP-needs-discussion-">9.2.5</a></span>On Being Slashed (WIP, needs discussion)</h4><p>If a miner is slashed for failing to submit their PoSt on time, they currently lose all their pledge collateral. They do not necessarily lose their storage collateral. Storage collateral is lost when a miner&rsquo;s clients slash them for no longer having the data. Missing a PoSt does not necessarily imply that a miner no longer has the data. There should be an additional timeout here where the miner can submit a PoSt, along with&lsquo;refilling&rsquo; their pledge collateral. If a miner does this, they can continue mining, their mining power will be reinstated, and clients can be assured that their data is still there.</p><div class="spec-todo">disambiguate the two collaterals across the entire spec</div><p>Review Discussion Note: Taking all of a miners collateral for going over the deadline for PoSt submission is really really painful, and is likely to dissuade people from even mining filecoin in the first place (If my internet going out could cause me to lose a very large amount of money, that leads to some pretty hard decisions around profitability). One potential strategy could be to only penalize miners for the amount of sectors they could have generated in that timeframe.</p></section></section><section id="sec-Mining-Blocks" secid="9.3"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Mining-Blocks">9.3</a></span>Mining Blocks</h3><p>Having registered as a miner, it&rsquo;s time to start making and checking tickets. At this point, the miner should already be running chain validation, which includes keeping track of the latest <a href="./expected-consensus.md#tipsets">TipSets</a> seen on the network.</p><p>For additional details around how consensus works in Filecoin, see the <a href="./expected-consensus.md">expected consensus spec</a>. For the purposes of this section, there is a consensus protocol (Expected Consensus) that guarantees a fair process for determining what blocks have been generated in a round, whether a miner should mine a block themselves, and some rules pertaining to how &ldquo;Tickets&rdquo; should be validated during block validation.</p><section id="sec-Receiving-Blocks" secid="9.3.1"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Receiving-Blocks">9.3.1</a></span>Receiving Blocks</h4><p>When receiving blocks from the network (via <a href="data-propagation.md">block propagation</a>), a miner must do the following:</p><ol><li>Check their validity (see <a href="#block-validation">below</a>).</li><li>Assemble a TipSet with all valid blocks with common parents and the same number of tickets in their <code>Tickets</code> array.</li></ol><p>A miner may sometimes receive blocks belonging to different TipSets (i.e. whose parents are not the same). In that case, they must choose which TipSet to mine on.</p><p>Chain selection is a crucial component of how the Filecoin blockchain works. Every chain has an associated weight accounting for the number of blocks mined on it and so the power (storage) they track. It is always preferable to mine atop a heavier TipSet rather than a lighter one. While a miner may be foregoing block rewards earned in the past, this lighter chain is likely to be abandoned by other miners forfeiting any block reward earned as miners converge on a final chain. For more on this, see <a href="./expected-consensus.md#chain-selection">chain selection</a> in the Expected Consensus spec.</p></section><section id="sec-Block-Validation" secid="9.3.2"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Block-Validation">9.3.2</a></span>Block Validation</h4><p>The block structure and serialization is detailed in <a href="data-structures.md#block">the datastructures spec &ndash; block</a>. Check there for details on fields and types.</p><p>In order to validate a block coming in from the network at round <code>N</code> was well mined a miner must do the following:</p><pre><code><span class="token keyword">func</span> <span class="token function">VerifyBlock</span><span class="token punctuation">(</span>blk Block<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 1. Verify Signature</span>
    pubk <span class="token operator">:=</span> <span class="token function">GetPublicKey</span><span class="token punctuation">(</span>blk<span class="token punctuation">.</span>Miner<span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">ValidateSignature</span><span class="token punctuation">(</span>blk<span class="token punctuation">.</span>Signature<span class="token punctuation">,</span> pubk<span class="token punctuation">,</span> blk<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"invalid block signature"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 2. Verify Timestamp</span>
    <span class="token comment" spellcheck="true">// first check that it is not in the future</span>
    <span class="token keyword">if</span> blk<span class="token punctuation">.</span><span class="token function">GetTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"block was generated too far in the future"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// next check that it is appropriately delayed from its parents</span>
    <span class="token keyword">if</span> blk<span class="token punctuation">.</span><span class="token function">GetTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> blk<span class="token punctuation">.</span><span class="token function">minParentTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> BLOCK_DELAY <span class="token punctuation">{</span>
        <span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"block was generated too soon"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 3. Verify ParentWeight</span>
    <span class="token keyword">if</span> blk<span class="token punctuation">.</span>ParentWeight <span class="token operator">!=</span> <span class="token function">ComputeWeight</span><span class="token punctuation">(</span>blk<span class="token punctuation">.</span>Parents<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"invalid parent weight"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 4. Verify Tickets</span>
    <span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">VerifyTickets</span><span class="token punctuation">(</span>blk<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"tickets were invalid"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 5. Verify ElectionProof</span>
    randomnessLookbackTipset <span class="token operator">:=</span> <span class="token function">RandomnessLookback</span><span class="token punctuation">(</span>blk<span class="token punctuation">)</span>
    lookbackTicket <span class="token operator">:=</span> <span class="token function">minTicket</span><span class="token punctuation">(</span>randomnessLookbackTipset<span class="token punctuation">)</span>
    challenge <span class="token operator">:=</span> sha256<span class="token punctuation">.</span><span class="token function">Sum</span><span class="token punctuation">(</span>lookbackTicket<span class="token punctuation">)</span>

    <span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">ValidateSignature</span><span class="token punctuation">(</span>blk<span class="token punctuation">.</span>ElectionProof<span class="token punctuation">,</span> pubk<span class="token punctuation">,</span> challenge<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"election proof was not a valid signature of the last ticket"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    powerLookbackTipset <span class="token operator">:=</span> <span class="token function">PowerLookback</span><span class="token punctuation">(</span>blk<span class="token punctuation">)</span>
    minerPower <span class="token operator">:=</span> <span class="token function">GetPower</span><span class="token punctuation">(</span>powerLookbackTipset<span class="token punctuation">.</span>state<span class="token punctuation">,</span> blk<span class="token punctuation">.</span>Miner<span class="token punctuation">)</span>
    totalPower <span class="token operator">:=</span> <span class="token function">GetTotalPower</span><span class="token punctuation">(</span>powerLookbackTipset<span class="token punctuation">.</span>state<span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">IsProofAWinner</span><span class="token punctuation">(</span>blk<span class="token punctuation">.</span>ElectionProof<span class="token punctuation">,</span> minerPower<span class="token punctuation">,</span> totalPower<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"election proof was not a winner"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 6. Verify StateRoot</span>
    state <span class="token operator">:=</span> <span class="token function">GetParentState</span><span class="token punctuation">(</span>blk<span class="token punctuation">.</span>Parents<span class="token punctuation">)</span>
    <span class="token keyword">for</span> i<span class="token punctuation">,</span> msg <span class="token operator">:=</span> <span class="token keyword">range</span> blk<span class="token punctuation">.</span>Messages <span class="token punctuation">{</span>
        receipt <span class="token operator">:=</span> <span class="token function">ApplyMessage</span><span class="token punctuation">(</span>state<span class="token punctuation">,</span> msg<span class="token punctuation">)</span>
        <span class="token keyword">if</span> receipt <span class="token operator">!=</span> blk<span class="token punctuation">.</span>MessageReceipts<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token punctuation">{</span>
            <span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"message receipt mismatch"</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> state<span class="token punctuation">.</span><span class="token function">Cid</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> blk<span class="token punctuation">.</span>StateRoot <span class="token punctuation">{</span>
        <span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"state roots mismatch"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>Ticket validation is detailed as follows:</p><pre><code><span class="token keyword">func</span> <span class="token function">RandomnessLookback</span><span class="token punctuation">(</span>blk Block<span class="token punctuation">)</span> TipSet <span class="token punctuation">{</span>
	<span class="token keyword">return</span> chain<span class="token punctuation">.</span><span class="token function">GetAncestorTipset</span><span class="token punctuation">(</span>blk<span class="token punctuation">,</span> K<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">PowerLookback</span><span class="token punctuation">(</span>blk Block<span class="token punctuation">)</span> TipSet <span class="token punctuation">{</span>
	<span class="token keyword">return</span> chain<span class="token punctuation">.</span><span class="token function">GetAncestorTipset</span><span class="token punctuation">(</span>blk<span class="token punctuation">,</span> L<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">IsProofAWinner</span><span class="token punctuation">(</span>p ElectionProof<span class="token punctuation">,</span> minersPower<span class="token punctuation">,</span> totalPower Integer<span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> Integer<span class="token punctuation">.</span><span class="token function">FromBytes</span><span class="token punctuation">(</span>sha256<span class="token punctuation">.</span><span class="token function">Sum</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">*</span>totalPower <span class="token operator">&lt;</span> minersPower<span class="token operator">*</span><span class="token number">2</span><span class="token operator">^</span><span class="token number">32</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">VerifyTickets</span><span class="token punctuation">(</span>b Block<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span>
	<span class="token comment" spellcheck="true">// Start with the `Tickets` array</span>
	<span class="token comment" spellcheck="true">// get the smallest ticket from the blocks parent tipset</span>
	parTicket <span class="token operator">:=</span> <span class="token function">GetSmallestTicket</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>Parents<span class="token punctuation">)</span>

	<span class="token comment" spellcheck="true">// Verify each ticket in the chain of tickets. There will be one ticket</span>
	<span class="token comment" spellcheck="true">// plus one ticket for each failed election attempt.</span>
	<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> ticket <span class="token operator">:=</span> <span class="token keyword">range</span> b<span class="token punctuation">.</span>Tickets <span class="token punctuation">{</span>
		challenge <span class="token operator">:=</span> sha256<span class="token punctuation">.</span><span class="token function">Sum</span><span class="token punctuation">(</span>parTicket<span class="token punctuation">.</span>Signature<span class="token punctuation">)</span>

		<span class="token comment" spellcheck="true">// Check VDF</span>
		<span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">VerifyVDF</span><span class="token punctuation">(</span>ticket<span class="token punctuation">.</span>VDFProof<span class="token punctuation">,</span> ticket<span class="token punctuation">.</span>VDFResult<span class="token punctuation">,</span> challenge<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">return</span> <span class="token string">"VDF was not run properly"</span>
		<span class="token punctuation">}</span>

		<span class="token comment" spellcheck="true">// Check VRF</span>
		pubk <span class="token operator">:=</span> <span class="token function">getPublicKeyForMiner</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>Miner<span class="token punctuation">)</span>
		<span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">VerifySignature</span><span class="token punctuation">(</span>ticket<span class="token punctuation">.</span>Signature<span class="token punctuation">,</span> pubk<span class="token punctuation">,</span> ticket<span class="token punctuation">.</span>VDFResult<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">return</span> <span class="token string">"Ticket was not a valid signature over the parent ticket"</span>
		<span class="token punctuation">}</span>
		<span class="token comment" spellcheck="true">// in case mining this block generated multiple tickets</span>
		parTicket <span class="token operator">=</span> ticket
	<span class="token punctuation">}</span>

	<span class="token keyword">return</span> <span class="token boolean">nil</span>
<span class="token punctuation">}</span>
</code></pre><p>If all of this lines up, the block is valid. The miner repeats this for all blocks in a TipSet, and for all TipSets formed from incoming blocks.</p><p>Once they&rsquo;ve ensured all blocks in the heaviest TipSet received were properly mined, they can mine on top of it. If they weren&rsquo;t, the miner may need to ensure the next heaviest <code>Tipset</code> was properly mined. This might mean the same <code>Tipset</code> with invalid blocks removed, or an altogether different one.</p><p>If no valid blocks are received, a miner may mine atop the same <code>TipSet</code> running leader election again using the next ticket in the ticket chain, and also generating a <a href="./expected-consensus.md#losing-tickets">new ticket</a> in the process (see the <a href="./expected-consensus.md">expected consensus spec</a> for more).</p></section><section id="sec-Ticket-Generation" secid="9.3.3"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Ticket-Generation">9.3.3</a></span>Ticket Generation</h4><p>For details of ticket generation, see the <a href="./expected-consensus.md#ticket-generation">expected consensus spec</a>.</p><p>Ticket generation is the twin process of leader election (i.e. generating <code>ElectionProof</code>s). Every ticket scratch (i.e. round of leader election) has the miner generate a new ticket to include in the <code>Tickets</code> array of their block.</p><p>New tickets are generated using the smallest ticket from the parent TipSet at height <code>H</code> and added to the <code>Tickets</code> array. Generating a new ticket will take some amount of time (as imposed by the VDF in Expected Consensus).</p><p>Because of this, on expectation, as it is produced, the miner will hear about other blocks being mined on the network. By the time they have generated their new ticket, they can check whether they themselves are eligible to mine a new block.</p><p>If the lookback ticket yields a valid <code>ElectionProof</code>, the miner publishes their block (see <a href="#block-creation">block generation</a>) including the new ticket and earns a block reward. They then assemble a new TipSet using any valid blocks they heard about while generating the ticket (likely of height <code>H+1</code>) and mine atop the smallest ticket in that new TipSet.</p></section><section id="sec-Scratching-a-losing-ticket" secid="9.3.4"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Scratching-a-losing-ticket">9.3.4</a></span>Scratching a losing ticket</h4><p>If a miner fails to generate a valid <code>ElectionProof</code> using their lookback ticket, they may not yet publish a new block at height <code>H+1</code>. The miner will likely hear about other blocks being mined on the network at height <code>H+1</code> and can thus assemble a new TipSet to mine off of with these blocks (as above).</p><p>If the miner hears of no new blocks, they must instead draw a new ticket to scratch in order to try leader election again (as other miners will). In order to do so, they must generate a new ticket once more.</p><p>Now, rather than generating this new ticket from the smallest ticket from the parent TipSet (as above), the miner will instead use their ticket from the last round, now in the <code>Tickets</code> array.</p><p>This process is repeated until either a winning ticket is found (and block published) or a new valid TipSet comes in from the network. If a new TipSet comes in from the network, and it is heavier chain than the miner&rsquo;s own, they should abandon their process to mine atop this new block. Due to the way chain selection works in filecoin, a chain with more blocks will be preferred (see the <a href="./expected-consensus.md#chain-selection">Expected Consensus spec</a> for more details).</p><p>The <code>Tickets</code> array in the block to be published grows with each round (and a new ticket generated).</p></section><section id="sec-Block-Creation" secid="9.3.5"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Block-Creation">9.3.5</a></span>Block Creation</h4><p>Scratching a winning ticket, and armed with a valid <code>ElectionProof</code>, a miner can now publish a new block!</p><p>To create a block, the eligible miner must compute a few fields:</p><ul><li><code>Tickets</code> - An array containing a new ticket, and, if applicable, any intermediary tickets generated to prove appropriate delay for any failed election attempts. See <a href="./expected-consensus.md#ticket-generation">ticket generation</a>.</li><li><code>ElectionProof</code> - A signature over the final ticket from the <code>Tickets</code> array proving. See <a href="./expected-consensus.md#ticket-generation">ticket generation</a>.</li><li><code>Timestamp</code> - A Unix Timestamp generated at block creation. We use an unsigned integer to represent a UTC timestamp. The Timestamp in the newly created block must satisfy the following conditions:<ul><li>the timestamp on the block is not in the future</li><li>the timestamp on the block is at least BLOCK_DELAY higher than the latest of its parents, with BLOCK_DELAY taking on the same value as that needed to generate a valid VDF proof for a new Ticket (currently set to 30 seconds).</li></ul></li><li><code>ParentWeight</code> - As described in <a href="./expected-consensus.md#chain-weighting">Chain Weighting</a>.</li><li><code>ParentState</code> - Note that it will not end up in the newly generated block, but is necessary to compute to generate other fields. To compute this:<ul><li>Take the <code>ParentState</code> of one of the blocks in the chosen parent set (invariant: this is the same value for all blocks in a given parent set).</li><li>For each block in the parent set, ordered by their tickets:<ul><li>Apply each message in the block to the parent state, in order. If a message was already applied in a previous block, skip it.</li><li>Transaction fees are given to the miner of the block that the first occurance of the message is included in. If there are two blocks in the parent set, and they both contain the exact same set of messages, the second one will receive no fees.</li><li>It is valid for messages in two different blocks of the parent set to conflict, that is, A conflicting message from the combined set of messages will always error. Regardless of conflicts all messages are applied to the state.</li><li>TODO: define message conflicts in the state&#8208;machine doc, and link to it from here</li></ul></li></ul></li><li><code>MsgRoot</code> - To compute this:<ul><li>Select a set of messages from the mempool to include in the block.</li><li>Insert them into a Merkle Tree and take its root.</li></ul></li><li><code>StateRoot</code> - Apply each chosen message to the <code>ParentState</code> to get this.</li><li><code>ReceiptsRoot</code> - To compute this:<ul><li>Apply the set of messages selected above to the parent state, collecting invocation receipts as this happens.</li><li>Insert them into a Merkle Tree and take its root.</li></ul></li><li><code>BlockSig</code> - A signature with the miner&rsquo;s private key (must also match the ticket signature) over the entire block. This is to ensure that nobody tampers with the block after it propagates to the network, since unlike normal PoW blockchains, a winning ticket is found independently of block generation.</li></ul><p>An eligible miner can start by filling out <code>Parents</code>, <code>Tickets</code> and <code>ElectionProof</code> with values from the ticket checking process.</p><p>Next, they compute the aggregate state of their selected parent blocks, the <code>ParentState</code>. This is done by taking the aggregate parent state of the blocks&rsquo; parent TipSet, sorting the parent blocks by their tickets, and applying each message in each block to that state. Any message whose nonce is already used (duplicate message) in an earlier block should be skipped (application of this message should fail anyway). Note that re&#8208;applied messages may result in different receipts than they produced in their original blocks, an open question is how to represent the receipt trie of this tipsets&lsquo;virtual block&rsquo;. For more details on message execution and state transitions, see the <a href="state-machine.md">Filecoin state machine</a> document.</p><p>Once the miner has the aggregate <code>ParentState</code>, they must apply the mining reward. This is done by adding the correct amount to the miner owner&rsquo;s account balance in the state tree. See <a href="#block-rewards">block reward</a> for details.</p><p>Now, a set of messages is selected to put into the block. For each message, the miner subtracts <code>msg.GasPrice * msg.GasLimit</code> from the sender&rsquo;s account balance, returning a fatal processing error if the sender does not have enough funds (this message should not be included in the chain).</p><p>They then apply the messages state transition, and generate a receipt for it containing the total gas actually used by the execution, the executions exit code, and the return value (see <a href="data-structures.md#message-receipt">receipt</a> for more details). Then, they refund the sender in the amount of <code>(msg.GasLimit - GasUsed) * msg.GasPrice</code>. In the event of a message processing error, the remaining gas is refunded to the user, and all other state changes are reverted. (Note: this is a divergence from the way things are done in Ethereum)</p><p>Each message should be applied on the resultant state of the previous message execution, unless that message execution failed, in which case all state changes caused by that message are thrown out. The final state tree after this process will be the block&rsquo;s <code>StateRoot</code>.</p><p>The miner merklizes the set of messages selected, and put the root in <code>MsgRoot</code>. They gather the receipts from each execution into a set, merklize them, and put that root in <code>ReceiptsRoot</code>. Finally, they set the <code>StateRoot</code> field with the resultant state.</p><div class="spec-note">Note that the <code>ParentState</code> field from the expected consensus document is left out, this is to help minimize the size of the block header. The parent state for any given parent set should be computed by the client and cached locally.</div><p>Finally, the miner can generate a Unix Timestamp to add to their block, to show that the block generation was appropriately delayed.</p><p>The miner will wait until BLOCK_DELAY has passed since the latest block in the parent set was generated to timestamp and send out their block. We recommend using NTP or another clock synchronization protocol to ensure that the timestamp is correctly generated (lest the block be rejected). While this timestamp does not provide a hard proof that the block was delayed (we rely on the VDF in the ticket&#8208;chain to do so), it provides some softer form of block delay by ensuring that honest miners will reject undelayed blocks.</p><p>Now the block is complete, all that&rsquo;s left is to sign it. The miner serializes the block now (without the signature field), takes the sha256 hash of it, and signs that hash. They place the resultant signature in the <code>BlockSig</code> field.</p><section id="sec-Block-Broadcast" secid="9.3.5.1"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Block-Broadcast">9.3.5.1</a></span>Block Broadcast</h5><p>An eligible miner broadcasts the completed block to the network (via <a href="data-propagation.md">block propagation</a>), and assuming everything was done correctly, the network will accept it and other miners will mine on top of it, earning the miner a block reward!</p></section></section><section id="sec-Block-Rewards" secid="9.3.6"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Block-Rewards">9.3.6</a></span>Block Rewards</h4><p>Over the entire lifetime of the protocol, 1,400,000,000 FIL (<code>TotalIssuance</code>) will be given out to miners. The rate at which the funds are given out is set to halve every six years, smoothly (not a fixed jump like in Bitcoin). These funds are initially held by the network account actor, and are transferred to miners in blocks that they mine. The reward amount remains fixed for a period of 1 week (given our 30 second block time, this is 20,160 blocks, the <code>AdjustmentPeriod</code>) and is then adjusted. Over time, the reward will eventually become zero as the fractional amount given out at each step shrinks the network account&rsquo;s balance to 0.</p><p>The equation for the current block reward is of the form:</p><pre><code>Reward = IV * (Decay ^ (BlockHeight / 20160))
</code></pre><p><code>IV</code> is the initial value, and is computed by taking:</p><pre><code>IV = TotalIssuance * (1 - Decay)
</code></pre><p><code>Decay</code> is computed by:</p><pre><code>Decay = e^(ln(0.5) / (HalvingPeriodBlocks / AdjustmentPeriod))
</code></pre><pre><code>// Given one block every 30 seconds, this is how many blocks are in six years
HalvingPeriodBlocks = 6 * 365 * 24 * 60 * 2
</code></pre><div class="spec-note">Due to jitter in EC, and the gregorian calendar, there may be some error in the issuance schedule over time. This is expected to be small enough that it&rsquo;s not worth correcting for. Additionally, since the payout mechanism is transferring from the network account to the miner, there is no risk of minting <em>too much</em> FIL.</div></section></section><section id="sec-undefined.Mining.Open-Questions" secid="9.4"><h3><span class="spec-secid" title="link to this section"><a href="#sec-undefined.Mining.Open-Questions">9.4</a></span>Open Questions</h3><ul><li>How should receipts for tipsets&lsquo;virtual blocks&rsquo; be referenced? It is common for applications to provide the merkleproof of a receipt to prove that a transaction was successfully executed.</li></ul></section><section id="sec-Future-Work" secid="9.5"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Future-Work">9.5</a></span>Future Work</h3><p>There are many ideas for improving upon the storage miner, here are ideas that may be potentially implemented in the future.</p><ul><li><strong>Sector Resealing</strong>: Miners should be able to&lsquo;re&#8208;seal&rsquo; sectors, to allow them to take a set of sectors with mostly expired pieces, and combine the not&#8208;yet&#8208;expired pieces into a single (or multiple) sectors.</li><li><strong>Sector Transfer</strong>: Miners should be able to re&#8208;delegate the responsibility of storing data to another miner. This is tricky for many reasons, and will not be implemented in the initial release of Filecoin, but could provide interesting capabilities down the road. </li></ul></section></section><section id="sec-Expected-Consensus" secid="10"><h2><span class="spec-secid" title="link to this section"><a href="#sec-Expected-Consensus">10</a></span>Expected Consensus</h2><p>This spec describes how to implement the protocol in general, for Filecoin&#8208;specific processes, see:</p><ul><li><a href="mining.md#mining-blocks">Mining Blocks</a> on how consensus is used.</li><li><a href="./faults.md">Faults</a> on slashing.</li><li><a href="./storage-market.md#the-power-table">Storage Market</a> on how the power table is maintained.</li><li><a href="data-structures.md#block">Block data structure</a> for details on fields and encoding.</li></ul><p>Important Concepts</p><ul><li>TipSet</li><li>Weight</li><li>Round</li><li>Height</li><li>Epoch</li><li>Ticket</li><li>ElectionProof</li></ul><p>&gt; <strong>Definition:</strong> A <code>ticket</code> is used as a source of randomness in EC leader election. Every block depends on an <code>ElectionProof</code> derived from a ticket. At least one new ticket is produced with every new block.</p><p>&gt; <strong>Definition:</strong> An <code>ElectionProof</code> is derived from a past ticket and included in every block header. The <code>ElectionProof</code> proves that the miner was eligible to mine a block in that round.</p><p>&gt; <strong>Definition:</strong> A <code>round</code> is the period in which a miner runs leader election to attempt to generate a new block. A new ticket is produced at every round, consequently the duration of a round is currently bounded by the duration of the Verifiable Delay Function run to generate a ticket. Tickets can be counted by round as one will be produced for each round.</p><p>&gt; <strong>Definition:</strong> <code>Height</code> refers to the number of <code>TipSets</code> a given block is built upon since genesis (height 0). Multiple blocks in a <code>TipSet</code> will have the same height.</p><p>&gt; <strong>Defintion:</strong> An <code>epoch</code> is the period in which a new block is generated. There may be multiple rounds in an epoch.</p><p>&gt; <strong>Definition:</strong> A <code>TipSet</code> is a set of blocks with the same parent set, and same number of tickets (which implies they will have been mined at the same height).</p><p>Expected Consensus is a probabilistic Byzantine fault&#8208;tolerant consensus protocol. At a high level, it operates by running a leader election every round in which, on expectation, one participant may be eligible to submit a block. All valid blocks submitted in a given round form a <code>TipSet</code>. Every block in a TipSet adds weight to its chain. The&lsquo;best&rsquo; chain is the one with the highest weight, which is to say that the fork choice rule is to choose the heaviest known chain. For more details on this, see <a href="#chain-selection">Chain Selection</a>.</p><p>The basic algorithms are as follows:</p><p>For each block received over the network, <code>OnBlockReceived</code> is called. <code>VerifyBlock</code> is defined in the <a href="mining.md#block-validation">mining spec</a>.</p><pre><code><span class="token keyword">func</span> <span class="token function">OnBlockReceived</span><span class="token punctuation">(</span>blk Block<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment" spellcheck="true">// The exact definition of IsValid depends on the protocol</span>
	<span class="token comment" spellcheck="true">// For Filecoin, see mining.md</span>
	<span class="token keyword">if</span> <span class="token function">VerifyBlock</span><span class="token punctuation">(</span>blk<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		ChainTipsMgr<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>blk<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	<span class="token comment" spellcheck="true">// Received an invalid block!</span>
<span class="token punctuation">}</span>
</code></pre><p>Separately, another process is running <code>Mine</code> to attempt to generate blocks.</p><pre><code><span class="token keyword">func</span> <span class="token function">Mine</span><span class="token punctuation">(</span>minerKey PrivateKey<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">for</span> r <span class="token operator">:=</span> <span class="token keyword">range</span> rounds <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// for each round</span>
		bestTipset<span class="token punctuation">,</span> tickets <span class="token operator">:=</span> ChainTipsMgr<span class="token punctuation">.</span><span class="token function">GetBestTipsetAtRound</span><span class="token punctuation">(</span>r <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>

		ticket <span class="token operator">:=</span> <span class="token function">GenerateTicket</span><span class="token punctuation">(</span>minerKey<span class="token punctuation">,</span> bestTipset<span class="token punctuation">)</span>
		tickets<span class="token punctuation">.</span><span class="token function">Append</span><span class="token punctuation">(</span>ticket<span class="token punctuation">)</span>

		<span class="token comment" spellcheck="true">// Generate an election proof and check if we win</span>
		<span class="token comment" spellcheck="true">// Note: even if we don't win, we want to make a ticket</span>
		<span class="token comment" spellcheck="true">// in case we need to mine a null round</span>
		win<span class="token punctuation">,</span> proof <span class="token operator">:=</span> <span class="token function">CheckIfWinnerAtRound</span><span class="token punctuation">(</span>minerKey<span class="token punctuation">,</span> r<span class="token punctuation">,</span> bestTipset<span class="token punctuation">)</span>
		<span class="token keyword">if</span> win <span class="token punctuation">{</span>
			<span class="token function">GenerateAndBroadcastBlock</span><span class="token punctuation">(</span>bestTipset<span class="token punctuation">,</span> tickets<span class="token punctuation">,</span> proof<span class="token punctuation">)</span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
			<span class="token comment" spellcheck="true">// Even if we don't win, add our ticket to the tracker in</span>
			<span class="token comment" spellcheck="true">// case we need to mine on it later.</span>
			ChainTipsMgr<span class="token punctuation">.</span><span class="token function">AddFailedTicket</span><span class="token punctuation">(</span>bestTipset<span class="token punctuation">,</span> tickets<span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p><code>IsProofAWinner</code> is taken from <a href="mining.md#block-validation">the mining doc</a>.</p><pre><code><span class="token keyword">const</span> RandomnessLookback <span class="token operator">=</span> <span class="token number">1</span> <span class="token comment" spellcheck="true">// Also referred to as "K" in many places</span>
<span class="token keyword">const</span> PowerLookback <span class="token operator">=</span> <span class="token number">1</span>      <span class="token comment" spellcheck="true">// Also referred to as "L" in many places</span>

<span class="token keyword">func</span> <span class="token function">CheckIfWinnerAtRound</span><span class="token punctuation">(</span>key PrivateKey<span class="token punctuation">,</span> n Integer<span class="token punctuation">,</span> parentTipset Tipset<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">bool</span><span class="token punctuation">,</span> ElectionProof<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	lbt <span class="token operator">:=</span> ChainTipsMgr<span class="token punctuation">.</span><span class="token function">TicketFromRound</span><span class="token punctuation">(</span>parentTipset<span class="token punctuation">,</span> n<span class="token operator">-</span>RandomnessLookback<span class="token punctuation">)</span>

	eproof <span class="token operator">:=</span> <span class="token function">ComputeElectionProof</span><span class="token punctuation">(</span>lbt<span class="token punctuation">,</span> key<span class="token punctuation">)</span>

	tipset <span class="token operator">:=</span> ChainTipsMgr<span class="token punctuation">.</span><span class="token function">TipsetFromRound</span><span class="token punctuation">(</span>n <span class="token operator">-</span> PowerLookback<span class="token punctuation">)</span>
	minerPower <span class="token operator">:=</span> <span class="token function">GetPower</span><span class="token punctuation">(</span>tipset<span class="token punctuation">.</span>state<span class="token punctuation">,</span> key<span class="token punctuation">.</span><span class="token function">Public</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	totalPower <span class="token operator">:=</span> <span class="token function">GetTotalPower</span><span class="token punctuation">(</span>tipset<span class="token punctuation">.</span>state<span class="token punctuation">)</span>

	<span class="token keyword">return</span> <span class="token function">IsProofAWinner</span><span class="token punctuation">(</span>eproof<span class="token punctuation">,</span> minerPower<span class="token punctuation">,</span> totalPower<span class="token punctuation">)</span><span class="token punctuation">,</span> eproof
<span class="token punctuation">}</span>
</code></pre><div class="spec-todo">get accurate estimates for K and L, potentially merge both to a single param.</div><div class="spec-note">Validity of blocks beyond appropriate ticket generation (defined below) is defined by the specific protocol using EC. For the Filecoin definition of a valid block, see the <a href="mining.md">mining spec</a>.</div><p>The basic algorithm can be broken down by looking in turn at its two major components:</p><ul><li>Leader Election</li><li>Chain Selection</li></ul><section id="sec-Secret-Leader-Election" secid="10.1"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Secret-Leader-Election">10.1</a></span>Secret Leader Election</h3><p>Expected Consensus is a consensus protocol that works by electing a miner from a weighted set in proportion to their power. In the case of Filecoin, participants and powers are drawn from the storage <a href="./storage-market.md#the-power-table">power table</a>, where power is equivalent to storage provided through time.</p><p>Leader Election in Expected Consensus must be Secret, Fair and Verifiable. This is achieved through the use of randomness used to run the election. In the case of Filecoin&rsquo;s use of EC, the blockchain tracks an independent ticket chain. These tickets are used as randomness for Leader Election. Every block generated references an <code>ElectionProof</code> derived from a past ticket. The ticket chain is extended by the miner who generates a new ticket with each attempted election.</p><p>In cases in which no winning ticket is found by any miner in a given round (i.e. no block is mined on the network), miners move on to the next ticket in the ticket chain to attempt a new leader election. When this happens, miners should nonetheless generate a new ticket prior to the new leader election, thereby appropriately prolonging the ticket chain (the block chain can never be longer than the ticket chain). This situation is fleshed out in the <a href="#losing-tickets">Losing Tickets</a> section.</p><p>In order to pressure the network to converge on a single chain, each miner may only submit one block per round (see: <code>Slashing</code>).</p><div class="spec-todo">pictures of ticket chain and block chain</div><section id="sec-Tickets" secid="10.1.1"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Tickets">10.1.1</a></span>Tickets</h4><p>One may think of leader election in EC as a verifiable lottery, in which participants win in proportion to the power they have within the network.</p><p>A ticket is drawn from the past at the beginning of each new round, and a new ticket is generated in every round. Tickets are chained independently of the main blockchain. A ticket only depends on the ticket before it, and not any other data in the block. Nonetheless, in Filecoin, every block header contains one or more new tickets, thereby extending the ticket chain. A miner generates a new ticket in their block for every ticket they scratch running leader election, thereby ensuring the ticket chain is at least as long as the block chain.</p><p>At a high&#8208;level, tickets must do the following:</p><ul><li>Ensure leader secrecy -- meaning a block producer will not be known until they release their block to the network.</li><li>Prove leader election -- meaning a block producer can be verified by any participant in the network.</li><li>Prove appropriate delay between drawings &mdash; thereby preventing leaders from &ldquo;rushing&rdquo; the protocol by releasing blocks early (at the expense of fairness for miners with worse connectivity).</li><li>Ensure a single drawing per round &mdash; derived in part from the above, thereby preventing miners from grinding on tickets (e.g. by repeatedly drawing new tickets in the hopes of winning) within a round.</li></ul><p>For tickets in EC, one may use the following:</p><pre><code><span class="token keyword">type</span> Ticket <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	<span class="token comment" spellcheck="true">// The VDF Result is derived from the prior ticket in the ticket chain</span>
	VDFResult BigInteger
	<span class="token comment" spellcheck="true">// The VDF proves a delay between tickets generated</span>
	VDFProof BigInteger
	<span class="token comment" spellcheck="true">// This signature is generated by the miner's keypair run on the VDFResult.</span>
	<span class="token comment" spellcheck="true">// It is the value that will be used to generate future tickets or ElectionProofs.</span>
	Signature Signature
<span class="token punctuation">}</span>
</code></pre><p>In practice, EC defines two different fields within a block:</p><ul><li>A <code>Tickets</code> array &mdash; this stores new tickets generated during this epoch, or block generation attempt. It proves appropriate delay. It is from this array that miners will sample randomness to run leader election in <code>K</code> rounds. See <a href="#ticket-generation">Ticket generation</a>.</li><li>An <code>ElectionProof</code> &mdash; this stores a proof that a given miner scratched a winning lottery ticket using the appropriate ticket <code>K</code> rounds back. It proves that the leader was elected in this round. See <a href="#checking-election-results">Checking election results</a>.</li></ul><p>On expectation, the <code>Tickets</code> array will contain a single ticket. For cases in which it contains more than one, see <a href="#losing-tickets">Losing Tickets</a>.</p><pre><code>On the two uses of tickets.

Tickets serve two main purposes.

1) As a proof that blocks were appropriately delayed. This both prevents miners grinding through tickets in a given epoch and a winner rushing the protocol by publishing
blocks as fast as possible (thereby penalizing poorly connected miners).

This is a result of a new ticket being generated by the miner for every leader election
attempt (using a ticket from the past). This ticket is generated using the ticket from
the prior block, or &quot;losing&quot; tickets generated in this epoch.

2) As a source of randomness used to prove that a leader was correctly elected.

This is done by generating an &#x27;ElectionProof&#x27; derived from a ticket sampled K rounds
back.

But why the lookback?

The lookback helps turn independent lotteries (ticket drawings from a block one round back)
into a global lottery instead. Rather than having a distinct chance of winning or losing
for each potential fork in a given round, a miner will either win on all or lose on all
forks descended from the block in which the ticket is sampled.

This is useful as it reduces opportunities for grinding, across forks or sybil identities.

However this introduces a tradeoff:
- The lookback means that a miner can know K rounds in advance that they will win,
decreasing the cost of running a targeted attack (given they have local predictability).
- It means electionProofs are stored separately from new tickets on a block, taking up
more space on-chain.
</code></pre><section id="sec-Ticket-generation" secid="10.1.1.1"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Ticket-generation">10.1.1.1</a></span>Ticket generation</h5><p>This section discusses how tickets are generated for the <code>Tickets</code> array.</p><p>At round <code>N</code>, new tickets are generated using tickets drawn from the <a href="#tipsets">TipSet</a> at round <code>N-1</code>. This ensures the miner cannot publish a new block (corresponding to the <code>ElectionProof</code> generated by a winning ticket <code>K</code> rounds back) until the correct round.</p><p>Because a Tipset can contain multiple blocks (see <a href="#chain-selection">Chain Selection</a> below), the smallest ticket in the Tipset must be drawn otherwise the block will be invalid.</p><div class="spec-todo">pictures of TipSet ticket drawing</div><p>The miner runs the prior ticket through a Verifiable Delay Function (VDF) to get a new unique output. This approximates clock synchrony for miners, thereby ensuring miners have waited an appropriate delay ahead of drawing a new ticket. It also establishes a lower&#8208;bound delay between production of new blocks at different heights. This helps ensure fairness, in that miners with lesser connectivity are not penalized and have a chance to produce blocks.</p><p>This output is then used as input into a Verifiable Random Function (VRF) generating a new ticket, different from any other miners&rsquo;. This adds entropy to the ticket chain, limiting a miner&rsquo;s ability to alter one block to influence a future ticket (given a miner does not know who will win a given round in advance).</p><p>Succinctly, the process of crafting a new ticket in round <code>N</code> is as follows:</p><pre><code>old_ticket := sort(parentTickets)[0]
new_ticket := Sig(VDF(H(old_ticket)))

new_ticket: ticket to be used at round N in case of block generation
old_ticket: ticket drawn from round N-1
H: Cryptographic compression function
sort: bytewise sort
VDF: Verifiable Delay Function
Sig: Signature with the miner&#x27;s keypair, used as a Verifiable Random Function.
</code></pre></section><section id="sec-Checking-election-results" secid="10.1.1.2"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Checking-election-results">10.1.1.2</a></span>Checking election results</h5><p>Now, a miner must also check whether they have won in this round.</p><p>The process is as follows:</p><ul><li>At round N, the miner will draw the smallest ticket from the TipSet at round <code>N-K</code>, with <code>K</code> the randomness lookback parameter.<ul><li>In the case where there are multiple tickets to choose from at round <code>N-K</code> (i.e. if the TipSet eventually created has multiple blocks), miners should attempt to generate their <code>ElectionProof</code> from the ticket generated by the block with the smallest final ticket (i.e. not necessarily the smallest ticket generated at that round).</li></ul></li><li>The miner will use this ticket as input to a VRF (Verifiable Random Function), thereby ensuring secrecy: no other participant can generate this output without the miner&rsquo;s private key. In that sense whether the miner has scratched a winning ticket remains a secret until they release their <code>ElectionProof</code> along with a new block.</li><li>The miner will compare the output to their power fraction from round <code>N-L</code>, with <code>L</code> the committee lookback parameter. If it is smaller, they have won and can mine a block inserting this winning <code>ElectionProof</code> in the block header for the block produced at round <code>N</code>. Else they wait to hear of another block generated in this round.</li></ul><p>At round N:</p><pre><code>electionProof = Sig(H(SampleRandomness(CurrentRound - K)))

Sig: Signature with the miner&#x27;s keypair, used as a VRF.
H: Cryptographic compression function
sort: bytewise sort
SampleRandomness: returns the appropriate ticket from round N-K
</code></pre><p>It is important to note that a miner generates two artifacts: one, a ticket derived from last block&rsquo;s ticket to prove that they have waited the appropriate delay, and two, an election proof derived from the ticket <code>K</code> rounds back used to run leader election.</p><p>Typically, either a miner will generate a winning ticket (see <a href="#block-generation">Block Generation</a> or will hear about a new block (or multiple) by the end of a round (and start mining atop the smallest ticket of this new TipSet). The round may also have no successful miners.</p></section></section><section id="sec-Losing-Tickets" secid="10.1.2"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Losing-Tickets">10.1.2</a></span>Losing Tickets</h4><p>In the case that everybody draws a losing ticket in a given round (i.e. no miner is eligible to produce a block), every miner can run leader election again by &ldquo;scratching&rdquo; (attempting to generate a new <code>ElectionProof</code> from) the next ticket in the chain. That is, miners will now use the ticket sampled <code>K-1</code> rounds back to generate a new <code>ElectionProof</code>. They can then compare that proof with their power in the table <code>N-(L-1)</code> blocks back. This is repeated until a miner scratches a winning ticket and can publish a block (see <a href="#block-generation">Block Generation</a>).</p><p>In addition to each attempted <code>ElectionProof</code> generation, the miner will need to extend the ticket chain by generating a new ticket. They use the ticket they generated in the prior round, rather than the prior block&rsquo;s (as is normally used). This proves appropriate delay (given that finding a winning Ticket has taken multiple rounds). Thus, each time it is discovered that nobody has won in a given round, every miner should use their previously generated ticket to repeat the ticket generation process, appending said ticket to their would&#8208;be block&rsquo;s <code>Ticket</code> array. This continues until some miner finds a winning ticket (see below), ensuring that the ticket chain remains at least as long as the block chain.</p><p>As was stated above, in the case where there are multiple tickets to choose from at round <code>N-K</code> (i.e. if the TipSet eventually created has multiple blocks), miners should attempt to generate their <code>ElectionProof</code> from the ticket generated by the block with the smallest final ticket (i.e. not necessarily the smallest ticket generated at that round). Put another way, the block in a TipSet with the smallest final ticket prolongs the valid ticket chain.</p><div class="spec-todo">Add a diagram to illustrate this</div><p>The VDF ensures fairness by enforcing that miners cannot grind through repeated losing tickets (see more <a href="https://github.com/filecoin-project/research/issues/31">here</a>) and that a miner cannot &ldquo;rush&rdquo; the protocol by outputting a block before others have had a chance to (e.g. geographically disadvantaged miners). The VDF delay is currently to 30 seconds, given estimated network propagation times.</p><p>Thus, our full ticket generation algorithm (reprised from <a href="#ticket-generation">Ticket Generation</a>) is roughly (ticket handling is simplified in the pseudocode below for legibility):</p><pre><code><span class="token comment" spellcheck="true">// Ticket is created as an array, with the initial ticket</span>
<span class="token comment" spellcheck="true">// coming from the parent TipSet.</span>
<span class="token keyword">var</span> Tickets <span class="token punctuation">[</span><span class="token punctuation">]</span>Ticket
oldTicket <span class="token operator">:=</span> <span class="token function">sort</span><span class="token punctuation">(</span>parentTickets<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
newTicket <span class="token operator">:=</span> <span class="token function">VRF</span><span class="token punctuation">(</span><span class="token function">VDF</span><span class="token punctuation">(</span><span class="token function">H</span><span class="token punctuation">(</span>oldTicket<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
electionProof <span class="token operator">:=</span> <span class="token function">VRF</span><span class="token punctuation">(</span><span class="token function">H</span><span class="token punctuation">(</span><span class="token function">ticketFromRound</span><span class="token punctuation">(</span>curRound <span class="token operator">-</span> K<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

Tickets <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>Tickets<span class="token punctuation">,</span> newTicket<span class="token punctuation">)</span>

<span class="token comment" spellcheck="true">// If the current ticket isn't a winner and the block isn't found by another miner,</span>
<span class="token comment" spellcheck="true">// derive a ticket from the last ticket</span>
<span class="token keyword">for</span> <span class="token operator">!</span><span class="token function">IsProofAWinner</span><span class="token punctuation">(</span>electionProof<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">blockFound</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	newTicket <span class="token operator">=</span> <span class="token function">VRF</span><span class="token punctuation">(</span><span class="token function">VDF</span><span class="token punctuation">(</span><span class="token function">H</span><span class="token punctuation">(</span>newTicket<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	newElectionProof <span class="token operator">=</span> <span class="token function">Sig</span><span class="token punctuation">(</span><span class="token function">H</span><span class="token punctuation">(</span><span class="token function">ticketFromRound</span><span class="token punctuation">(</span>curRound <span class="token operator">-</span> K<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	Tickets <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>Tickets<span class="token punctuation">,</span> newTicket<span class="token punctuation">)</span>
	curRound <span class="token operator">+=</span> <span class="token number">1</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// if the process yields a winning ticket, mine and put out a block</span>
<span class="token comment" spellcheck="true">// containing the ticket array</span>
<span class="token keyword">if</span> <span class="token function">winning</span><span class="token punctuation">(</span>electionProof<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token function">mineBlock</span><span class="token punctuation">(</span>electionProof<span class="token punctuation">,</span> Tickets<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><p>A ticket can be verified to have been generated in the appropriate number of rounds by looking at the <code>Tickets</code> array, and ensuring that each subsequent ticket (leading to the final ticket in that array) was generated using the previous one in the array. Note that this has implications on block size, and client memory requirements, though on expectation, the <code>Ticket</code> array should only contain one value.</p><p>In fact, the length of repeated losing tickets in the ticket chain (equivalent to the length of generated tickets referenced by a single block, or the length of the <code>Tickets</code> array) decreases exponentially in the number of repeated losing tickets (see more <a href="https://github.com/filecoin-project/go-filecoin/pull/1516">here</a>). In the unlikely case the number of losing tickets drawn by miners grows larger than the randomness lookback <code>K</code> (i.e. if a miner runs out of existing tickets on the ticket chain for use as randomness), a miner should proceed as usual using new tickets generated in this epoch for randomness. This has no impact on the protocol safety/validity.</p><p>New blocks (with multiple tickets) will have a few key properties:</p><ul><li>All tickets in the <code>Tickets</code> array are signed by the same miner -- to avoid grinding through out&#8208;of&#8208;band collusion between miners exchanging tickets.</li><li>The <code>ElectionProof</code> was correctly generated from the ticket <code>K-|Tickets|-1</code> (with <code>|Tickets|</code> the length of the <code>Tickets</code> array) rounds back.</li></ul><p>This means that valid <code>ElectionProof</code>s can be generated from tickets in the middle of the <code>Tickets</code> array.</p></section><section id="sec-Block-Generation" secid="10.1.3"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Block-Generation">10.1.3</a></span>Block Generation</h4><p>Once a miner has a winning election proof generated over <code>i</code> rounds and <code>i</code> corresponding tickets, they may create a block. For more on this, see the <a href="./mining.md#block-creation">Mining spec</a>.</p></section></section><section id="sec-Chain-Selection" secid="10.2"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Chain-Selection">10.2</a></span>Chain Selection</h3><p>Just as there can have 0 miners win in a round, multiple miners can be elected in a given round . This in turn means multiple blocks can be created in a round. In order to avoid wasting valid work done by miners, EC makes use of all valid blocks generated in a round</p><section id="sec-Tipsets" secid="10.2.1"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Tipsets">10.2.1</a></span>Tipsets</h4><p>All valid blocks generated in a round form a <code>TipSet</code> that participants will attempt to mine off of in the subsequent round (see above). TipSets are valid so long as:</p><ul><li>All blocks in a TipSet have the same parent TipSet</li><li>All blocks in a TipSet have the same number of tickets in their <code>Tickets</code> array</li></ul><p>The first condition implies that all blocks in a TipSet were mined at the same height (remember that height refers to block height as opposed to ticket round). This rule is key to helping ensure that EC converges over time. While multiple new blocks can be mined in a round, subsequent blocks all mine off of a TipSet bringing these blocks together. The second rule means blocks in a TipSet are mined in a same round.</p><p>Due to network propagation delay, it is possible for a miner in round N+1 to omit valid blocks mined at round N from their TipSet. This does not make the newly generated block invalid, it does however reduce its weight and chances of being part of the canonical chain in the protocol.</p></section><section id="sec-Chain-Weighting" secid="10.2.2"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Chain-Weighting">10.2.2</a></span>Chain Weighting</h4><div class="spec-todo">ensure&lsquo;power&rsquo; is properly and clearly defined</div><p>It is possible for forks to emerge naturally in Expected Consensus. EC relies on weighted chains in order to quickly converge on&lsquo;one true chain&rsquo;, with every block adding to the chain&rsquo;s weight. This means the heaviest chain should reflect the most amount of work performed, or in Filecoin&rsquo;s case, the most storage provided.</p><p>The weight at each block is equal to its <code>ParentWeight</code>, plus that block&rsquo;s delta weight. Delta weight is a constant <code>V</code>, plus <code>X</code> - a function of the total power in the network as reported in the Power Table. The exact value for <code>V</code> and the magnitude of the power ratio value are still to be determined, but for now <code>V = 10</code> and <code>X = log(TotalPower)</code>.</p><p><code>ParentWeight</code> is the aggregate chain weight of a given block&rsquo;s parent set. It is calculated as the <code>ParentWeight</code> of any of its parent blocks (all blocks in a given TipSet should have the same <code>ParentWeight</code> value) plus the delta weight of each parent. To make the computation a bit easier, a block&rsquo;s <code>ParentWeight</code> is stored in the block itself (otherwise potentially long chain scans would be required to compute a given block&rsquo;s weight).</p></section><section id="sec-Selecting-between-TipSets-with-equal-weight" secid="10.2.3"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Selecting-between-TipSets-with-equal-weight">10.2.3</a></span>Selecting between TipSets with equal weight</h4><p>When selecting between TipSets of equal weight, a miner chooses the one with the smallest min ticket (by bytewise comparison).</p><p>In the case where two TipSets of equal weight have the same min ticket, the miner will compare the next smallest ticket (and select the TipSet with the next smaller ticket). This continues until one TipSet is selected.</p><p>The above case may happen in situations under certain block propagation conditions. Assume three blocks B, C, and D have been mined (by miners 1, 2, and 3 respectively) off of block A, with minTicket(B) &lt; minTicket(C) &lt; minTicket (D).</p><p>Miner 1 outputs their block B and shuts down. Miners 2 and 3 both receive B but not each others&rsquo; blocks. We have miner 2 mining a TipSet made of B and C and miner 3 mining a TipSet made of B and D. If both succesfully mine blocks now, other miners in the network will receive new blocks built off of TipSets with equal weight and the same smallest ticket (that of block B). They should select the block mined atop [B, C] since minTicket(C) &lt; minTicket(D).</p><p>The probability that two TipSets with different blocks would have all the same tickets can be considered negligible: this would amount to finding a collision between two 256&#8208;bit (or more) collision&#8208;resistant hashes.</p></section><section id="sec-Chain-Selection.Slashing" secid="10.2.4"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Chain-Selection.Slashing">10.2.4</a></span>Slashing</h4><p>See the <a href="./faults.md">Faults spec</a> for implementation details.</p><p>Due to the existence of potential forks, a miner can try to unduly influence protocol fairness. This means they may choose to disregard the protocol in order to gain an advantage over the power they should normally get from their storage on the network. A miner should be slashed if they are provably deviating from the honest protocol.</p><p>This is detectable when a miner submits two blocks that satisfy either of the following &ldquo;slashing conditions&rdquo;:</p><p>(1) one block contains at least one ticket in its ticket array generated at the same round as one of the tickets in the other block&rsquo;s ticket array. (2) one block&rsquo;s parent is a TipSet that could have validly included the other block according to TipSet validity rules, however the parent of the first block does not include the other block.</p><ul><li>While it cannot be proven that a miner omits known blocks from a TipSet in general (i.e. network latency could simply mean the miner did not receive a particular block) in this case it can be proven because a miner must be aware of a block they mined in a previous round.</li></ul><p>Any node that detects this occurring should take both block headers, and call <a href="actors.md#slashconsensusfault"><code>storagemarket.SlashConsensusFault</code></a>. The network will then take all of that node&rsquo;s collateral, give a portion of it to the reporter, and keep the rest.</p><div class="spec-todo">It is unclear that rewarding the reporter any more than gas fees is the right thing to do. Needs thought. Tracking issue: https://github.com/filecoin&#8208;project/specs/issues/159</div><div class="spec-note">One may wonder what prevents miners from simply breaking up their power into multiple un&#8208;linkable miner actors (or sybils) that will be able to mine on multiple chains without being caught mining at the same round at the same time. We call this the &ldquo;whyru slashing&rdquo; attack.</div><div class="spec-todo">Discuss with @zenground0 to ensure the below should not be removed</div><pre><code>An attacker with 30% of the power has a 30% chance of mining a block at any given moment.
During a fork, an attacker would have a 30% chance of winning _on each fork_, meaning
they could continue to mine on both forks, except for 30% of the time they win, they
will win on both chains and have to forgo publishing one of the blocks to avoid being
slashed. This means that the miner loses 30% of their expected rewards, but is still
able to mine on both chains.

Now, if the miner instead controls two miners each with 15% of the total power in
the network, they still have a 30% chance of winning on each fork (using both sybils),
but they drop the probability of mining with the same miner at the same time on both
chains down to 15% of their winnings (meaning they have to forgo 15% of their
โsuccessfullyโ mined blocks). This continues on down, 3 identities is 10%, 4 is 7.6%,
5 is 6% and so on. So at the end of the day, the miner can mine on both chains with
only a minimal loss in potential proceeds.

The above assumes that every election is an independent random process (even across forks).
However, using a lookback parameter for seed sampling, the independent lottery drawing
becomes a global lottery for all forks originating after the lookback (where the
randomness was drawn). That is to say, given a common random seed and public key, each
sybil will either win on all forks, or lose on all forks. This greatly decreases the
chances that this attack succeeds, erasing the economic advantage sybils created.
</code></pre></section><section id="sec-ChainTipsManager" secid="10.2.5"><h4><span class="spec-secid" title="link to this section"><a href="#sec-ChainTipsManager">10.2.5</a></span>ChainTipsManager</h4><p>The Chain Tips Manager is a subcomponent of Filecoin consensus that is technically up to the implementer, but since the pseudocode in previous sections reference it, it is documented here for clarity.</p><p>The Chain Tips Manager is responsible for tracking all live tips of the Filecoin blockchain, and tracking what the current&lsquo;best&rsquo; tipset is.</p><pre><code><span class="token comment" spellcheck="true">// Returns the ticket that is at round 'r' in the chain behind 'head'</span>
<span class="token keyword">func</span> <span class="token function">TicketFromRound</span><span class="token punctuation">(</span>head Tipset<span class="token punctuation">,</span> r Round<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// Returns the tipset that contains round r (Note: multiple rounds may exist within a single // tipset due to null blocks)</span>
<span class="token keyword">func</span> <span class="token function">TipsetFromRound</span><span class="token punctuation">(</span>head Tipset<span class="token punctuation">,</span> r Round<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// GetBestTipset returns the best known tipset. If the 'best' tipset hasnt changed, then this</span>
<span class="token comment" spellcheck="true">// will return the previous best tipset and the null block we mined on top of it.</span>
<span class="token keyword">func</span> <span class="token function">GetBestTipset</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment" spellcheck="true">// Adds the failed ticket to the chaintips manager so that null blocks can be mined on top of</span>
<span class="token keyword">func</span> <span class="token function">AddFailedTicket</span><span class="token punctuation">(</span>parent Tipset<span class="token punctuation">,</span> t Ticket<span class="token punctuation">)</span>
</code></pre></section></section><section id="sec-Implementation-Notes" secid="10.3"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Implementation-Notes">10.3</a></span>Implementation Notes</h3><ul><li>When selecting messages from the mempool to include in the block, be aware that other miners may also generate blocks during this round, and to maximize fee earnings it may be best to select some messages at random (second in a duplicate earns no fees).</li></ul></section><section id="sec-Expected-Consensus.Open-Questions" secid="10.4"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Expected-Consensus.Open-Questions">10.4</a></span>Open Questions</h3><ul><li>Parameter K, Parameter L</li><li>Checkpointing Strategy</li><li>Block confirmation time</li><li>When selecting between two forks of equal weight, one strategy might be to select the&lsquo;Tipset&rsquo; with the lowest number of linked tickets for a given block height and weight.</li><li>Should there be a minimum power required to participate in the consensus process?</li><li>How long should&lsquo;valid&rsquo; candidate blocks be kept around? Essentially the question is: when is finality?</li><li>How should block rewards be assigned in the expected consensus setting?</li><li>VDF difficulty adjustment </li></ul></section></section><section id="sec-The-Filecoin-State-Machine" secid="11"><h2><span class="spec-secid" title="link to this section"><a href="#sec-The-Filecoin-State-Machine">11</a></span>The Filecoin State Machine</h2><p>The majority of Filecoin&rsquo;s user facing functionality (payments, storage market, power table, etc) is managed through the Filecoin State Machine. The network generates a series of blocks, and agrees which&lsquo;chain&rsquo; of blocks is the correct one. Each block contains a series of state transitions called <code>messages</code>, and a checkpoint of the current <code>global state</code> after the application of those <code>messages</code>.</p><p>The <code>global state</code> here consists of a set of <code>actors</code>, each with their own private <code>state</code>.</p><p>An <code>actor</code> is the Filecoin equivalent of Ethereum&rsquo;s smart contracts, it is essentially an&lsquo;object&rsquo; in the filecoin network with state and a set of methods that can be used to interact with it. Every actor has a Filecoin balance attributed to it, a <code>state</code> pointer, a <code>code</code> CID which tells the system what type of actor it is, and a <code>nonce</code> which tracks the number of messages sent by this actor. (TODO: the nonce is really only needed for external user interface actors, AKA <code>account actors</code>. Maybe we should find a way to clean that up?)</p><section id="sec-Method-Invocation" secid="11.1"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Method-Invocation">11.1</a></span>Method Invocation</h3><p>There are two routes to calling a method on an <code>actor</code>.</p><p>First, to call a method as an external participant of the system (aka, a normal user with Filecoin) you must send a signed <code>message</code> to the network, and pay a fee to the miner that includes your <code>message</code>. The signature on the message must match the key associated with an account with sufficient Filecoin to pay for the messages execution. The fee here is equivalent to transaction fees in Bitcoin and Ethereum, where it is proportional to the work that is done to process the message (Bitcoin prices messages per byte, Ethereum uses the concept of&lsquo;gas&rsquo;. We also use&lsquo;gas&rsquo;).</p><p>Second, an <code>actor</code> may call a method on another actor during the invocation of one of its methods. However, the only time this may happen is as a result of some actor being invoked by an external users message (note: an actor called by a user may call another actor that then calls another actor, as many layers deep as the execution can afford to run for).</p></section><section id="sec-State-Representation" secid="11.2"><h3><span class="spec-secid" title="link to this section"><a href="#sec-State-Representation">11.2</a></span>State Representation</h3><p>The <code>global state</code> is modeled as a map of actor <code>ID</code>s to actor structs. This map is implemented by an ipld HAMT (TODO: link to spec for our HAMT) with the&lsquo;key&rsquo; being the serialized ID address (every actor has an ID address that can be looked up via the <code>InitActor</code>), and the value is an <a href="data-structures.md#actor"><code>Actor</code></a> object with the actors information. Within each <code>Actor</code> object is a field called <code>state</code> that is an ipld pointer to a graph that can be entirely defined by the actor.</p></section><section id="sec-Execution-Calling-a-method-on-an-Actor-" secid="11.3"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Execution-Calling-a-method-on-an-Actor-">11.3</a></span>Execution (Calling a method on an Actor)</h3><p>Message execution currently relies entirely on&lsquo;built&#8208;in&rsquo; code, with a common external interface. The method and actor to call it on are specified in the <code>Method</code> and <code>To</code> fields of a message, respectively. Method parameters are encoded and put into the <code>Params</code> field of a message. The encoding is a cbor array of each of the types individually encoded. The individual encodings for each type are as follows.</p><p>These functions are given, as input, an <code>ExecutionContext</code> containing useful information for their execution.</p><pre><code><span class="token keyword">type</span> VMContext <span class="token keyword">interface</span> <span class="token punctuation">{</span>
	<span class="token comment" spellcheck="true">// Message is the message that kicked off the current invocation</span>
	<span class="token function">Message</span><span class="token punctuation">(</span><span class="token punctuation">)</span> Message

	<span class="token comment" spellcheck="true">// Storage provides access to the VM storage layer</span>
	<span class="token function">Storage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> Storage

	<span class="token comment" spellcheck="true">// Send allows the current execution context to invoke methods on other actors in the system</span>
	<span class="token function">Send</span><span class="token punctuation">(</span>to Address<span class="token punctuation">,</span> method <span class="token builtin">string</span><span class="token punctuation">,</span> value AttoFIL<span class="token punctuation">,</span> params <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token builtin">uint8</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span>

	<span class="token comment" spellcheck="true">// BlockHeight returns the height of the block this message was added to the chain in</span>
	<span class="token function">BlockHeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> BlockHeight
<span class="token punctuation">}</span>
</code></pre><p>If the execution completes successfully, changes to the state tree are saved. Otherwise, the message is marked as failed, and any state changes are reverted.</p><pre><code><span class="token keyword">func</span> <span class="token function">ApplyMessage</span><span class="token punctuation">(</span>st StateTree<span class="token punctuation">,</span> msg Message<span class="token punctuation">)</span> MessageReceipt <span class="token punctuation">{</span>
	st<span class="token punctuation">.</span><span class="token function">Snapshot</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	fromActor<span class="token punctuation">,</span> found <span class="token operator">:=</span> st<span class="token punctuation">.</span><span class="token function">GetActor</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>From<span class="token punctuation">)</span>
	<span class="token keyword">if</span> <span class="token operator">!</span>found <span class="token punctuation">{</span>
		<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"no such from actor"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	totalCost <span class="token operator">:=</span> msg<span class="token punctuation">.</span>Value <span class="token operator">+</span> <span class="token punctuation">(</span>msg<span class="token punctuation">.</span>GasLimit <span class="token operator">*</span> msg<span class="token punctuation">.</span>GasPrice<span class="token punctuation">)</span>
	<span class="token keyword">if</span> fromActor<span class="token punctuation">.</span>Balance <span class="token operator">&lt;</span> totalCost <span class="token punctuation">{</span>
		<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"not enough funds"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">if</span> msg<span class="token punctuation">.</span><span class="token function">Nonce</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> fromActor<span class="token punctuation">.</span>Nonce<span class="token operator">+</span><span class="token number">1</span> <span class="token punctuation">{</span>
		<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"invalid nonce"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	toActor<span class="token punctuation">,</span> found <span class="token operator">:=</span> st<span class="token punctuation">.</span><span class="token function">GetActor</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>To<span class="token punctuation">)</span>
	<span class="token keyword">if</span> <span class="token operator">!</span>found <span class="token punctuation">{</span>
		toActor <span class="token operator">=</span> <span class="token function">TryCreateAccountActor</span><span class="token punctuation">(</span>st<span class="token punctuation">,</span> msg<span class="token punctuation">.</span>To<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	st<span class="token punctuation">.</span><span class="token function">DeductFunds</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>From<span class="token punctuation">,</span> totalCost<span class="token punctuation">)</span>
	st<span class="token punctuation">.</span><span class="token function">DepositFunds</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>To<span class="token punctuation">,</span> msg<span class="token punctuation">.</span>Value<span class="token punctuation">)</span>

	vmctx <span class="token operator">:=</span> <span class="token function">makeVMContext</span><span class="token punctuation">(</span>st<span class="token punctuation">,</span> msg<span class="token punctuation">)</span>

	<span class="token keyword">if</span> msg<span class="token punctuation">.</span>Method <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>
		ret<span class="token punctuation">,</span> errcode <span class="token operator">:=</span> toActor<span class="token punctuation">.</span><span class="token function">Invoke</span><span class="token punctuation">(</span>vmctx<span class="token punctuation">,</span> msg<span class="token punctuation">.</span>Method<span class="token punctuation">,</span> msg<span class="token punctuation">.</span>Params<span class="token punctuation">)</span>
		<span class="token keyword">if</span> errcode <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>
			<span class="token comment" spellcheck="true">// revert all state changes since snapshot</span>
			st<span class="token punctuation">.</span><span class="token function">Revert</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
			st<span class="token punctuation">.</span><span class="token function">DeductFunds</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>From<span class="token punctuation">,</span> vmctx<span class="token punctuation">.</span><span class="token function">GasUsed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">*</span>msg<span class="token punctuation">.</span>GasPrice<span class="token punctuation">)</span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
			<span class="token comment" spellcheck="true">// refund unused gas</span>
			st<span class="token punctuation">.</span><span class="token function">DepositFunds</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>From<span class="token punctuation">,</span> <span class="token punctuation">(</span>msg<span class="token punctuation">.</span>GasLimit<span class="token operator">-</span>vmctx<span class="token punctuation">.</span><span class="token function">GasUsed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">*</span>msg<span class="token punctuation">.</span>GasPrice<span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token comment" spellcheck="true">// reward miner gas fees</span>
	st<span class="token punctuation">.</span><span class="token function">DepositFunds</span><span class="token punctuation">(</span>BlockMiner<span class="token punctuation">,</span> msg<span class="token punctuation">.</span>GasPrice<span class="token operator">*</span>vmctx<span class="token punctuation">.</span><span class="token function">GasUsed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

	<span class="token keyword">return</span> MessageReceipt<span class="token punctuation">{</span>
		ExitCode<span class="token punctuation">:</span> errcode<span class="token punctuation">,</span>
		Return<span class="token punctuation">:</span>   ret<span class="token punctuation">,</span>
		GasUsed<span class="token punctuation">:</span>  vmctx<span class="token punctuation">.</span><span class="token function">GasUsed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">TryCreateAccountActor</span><span class="token punctuation">(</span>st StateTree<span class="token punctuation">,</span> addr Address<span class="token punctuation">)</span> Actor <span class="token punctuation">{</span>
	<span class="token keyword">switch</span> addr<span class="token punctuation">.</span><span class="token function">Type</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">case</span> BLS<span class="token punctuation">:</span>
		<span class="token keyword">return</span> <span class="token function">NewBLSAccountActor</span><span class="token punctuation">(</span>addr<span class="token punctuation">)</span>
	<span class="token keyword">case</span> Secp256k1<span class="token punctuation">:</span>
		<span class="token keyword">return</span> <span class="token function">NewSecp256k1AccountActor</span><span class="token punctuation">(</span>addr<span class="token punctuation">)</span>
	<span class="token keyword">case</span> ID<span class="token punctuation">:</span>
		<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"no actor with given ID"</span><span class="token punctuation">)</span>
	<span class="token keyword">case</span> Actor<span class="token punctuation">:</span>
		<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"no such actor"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><section id="sec-Receipts" secid="11.3.1"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Receipts">11.3.1</a></span>Receipts</h4><p>Every message execution generates a <a href="data-structures.md#message-receipt">receipt</a>. These receipts contain the encoded return value of the method invocation, and an exit code.</p></section><section id="sec-Execution-Calling-a-method-on-an-Actor-.Storage" secid="11.3.2"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Execution-Calling-a-method-on-an-Actor-.Storage">11.3.2</a></span>Storage</h4><p>Actors are given acess to a <code>Storage</code> interface to fulfil their need for persistent storage. The <code>Storage</code> interface describes a content addressed block storage system (<code>Put</code> and <code>Get</code>) and a pointer into it (<code>Head</code> and <code>Commit</code>) that points to the actor&rsquo;s current state.</p><pre><code><span class="token keyword">type</span> Storage <span class="token keyword">interface</span> <span class="token punctuation">{</span>
	<span class="token comment" spellcheck="true">// Put writes the given object to the storage staging area and returns its CID</span>
	<span class="token function">Put</span><span class="token punctuation">(</span><span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>Cid<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span>

	<span class="token comment" spellcheck="true">// Get fetches the given object from storage (either staging, or local) and returns</span>
	<span class="token comment" spellcheck="true">// the serialized data.</span>
	<span class="token function">Get</span><span class="token punctuation">(</span>Cid<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span>

	<span class="token comment" spellcheck="true">// Commit updates the actual stored state for the actor. This is a compare and swap</span>
	<span class="token comment" spellcheck="true">// operation, and will fail if 'old' is not equal to the current return value of `Head`.</span>
	<span class="token comment" spellcheck="true">// This functionality is used to prevent issues with re-entrancy</span>
	<span class="token function">Commit</span><span class="token punctuation">(</span>old Cid<span class="token punctuation">,</span> <span class="token builtin">new</span> Cid<span class="token punctuation">)</span> <span class="token builtin">error</span>

	<span class="token comment" spellcheck="true">// Head returns the CID of the current actor state</span>
	<span class="token function">Head</span><span class="token punctuation">(</span><span class="token punctuation">)</span> Cid
<span class="token punctuation">}</span>
</code></pre><p>Actors can store state as a single block or implement any persistent data structure that can be built upon a content addressed block store. Implementations may provide data structure implementations to simplify development. The current interface only supports CBOR&#8208;IPLD, but this should soon expand to allow other types of IPLD data structures (as long as the system has resolvers for them).</p><p>The current state of a given actor can be accessed first by calling <code>Head</code> to retrieve the CID of the root of the actors state, then by using <code>Get</code> to retrieve the actual object being referenced.</p><p>To store data, <code>Put</code> is used. Any number of objects may be <code>Put</code>, but only the object whose CID is committed, or objects that are linked to in some way by the committed object will be kept. All other objects are dropped after the method invocation returns. Objects stored via <code>Put</code> are first marshaled to CBOR&#8208;IPLD, and then stored, the returned CID is a 32 byte sha2&#8208;256 CBOR&#8208;IPLD content identifier. </p></section></section></section><section id="sec-Filecoin-State-Machine-Actors" secid="12"><h2><span class="spec-secid" title="link to this section"><a href="#sec-Filecoin-State-Machine-Actors">12</a></span>Filecoin State Machine Actors</h2><p>Any implementations of the Filecoin actors must be exactly byte for byte compatible with the go&#8208;filecoin actor implementations. The pseudocode below tries to capture the important logic, but capturing all the detail would require embedding exactly the code from go&#8208;filecoin, so for now, its simply informative pseudocode. The algorithms below are correct, and all implementations much match it (including go&#8208;filecoin), but details omitted from here should be looked for in the go&#8208;filecoin code.</p><p>This spec describes a set of actors that operate within the <a href="state-machine.md">Filecoin State Machine</a>. All types are defined in <a href="data-structures.md#basic-type-encodings">the basic type encoding spec</a>.</p><ul><li><a href="#init-actor">Init Actor</a></li><li><a href="#storage-market-actor">Storage Market Actor</a></li><li><a href="#storage-miner-actor">Storage Miner Actor</a></li><li><a href="#payment-channel-broker-actor">Payment Channel Broker Actor</a></li></ul><section id="sec-Built-In-Actors" secid="12.1"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Built-In-Actors">12.1</a></span>Built In Actors</h3><p>Some state machine actors are&lsquo;system&rsquo; actors that get instantiated in the genesis block, and have their IDs allocated at that point.</p><table><thead><tr><th>ID </th><th>Actor </th><th>Name </th></tr></thead><tbody><tr><td>0 </td><td>InitActor </td><td>Network Init </td></tr><tr><td>1 </td><td>AccountActor </td><td>Network Treasury </td></tr><tr><td>2 </td><td>StorageMarketActor </td><td>Filecoin Storage Market </td></tr></tbody></table></section><section id="sec-Init-Actor" secid="12.2"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Init-Actor">12.2</a></span>Init Actor</h3><p>The init actor is responsible for creating new actors on the filecoin network. This is a built&#8208;in actor and cannot be replicated. In the future, this actor will be responsible for loading new code into the system (for user programmable actors). ID allocation for user instantiated actors starts at 100. This means that <code>NextID</code> will initially be set to 100.</p><pre><code><span class="token keyword">type</span> InitActor <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	<span class="token comment" spellcheck="true">// Mapping from Address to ID, for lookups.</span>
	AddressMap <span class="token keyword">map</span><span class="token punctuation">[</span>Address<span class="token punctuation">]</span>BigInt

	NextID BigInt
<span class="token punctuation">}</span>
</code></pre><section id="sec-Init-Actor.Code-Cid" secid="12.2.1"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Init-Actor.Code-Cid">12.2.1</a></span>Code Cid</h4><p><code>&lt;codec:raw&gt;&lt;mhType:identity&gt;&lt;&quot;init&quot;&gt;</code></p><table><thead><tr><th>Index </th><th>Method Name </th></tr></thead><tbody><tr><td>1 </td><td><code>Exec</code> </td></tr><tr><td>2 </td><td><code>GetIdForAddress</code> </td></tr></tbody></table></section><section id="sec--Exec-code-Cid-params-Param-Address-" secid="12.2.2"><h4><span class="spec-secid" title="link to this section"><a href="#sec--Exec-code-Cid-params-Param-Address-">12.2.2</a></span>`Exec(code Cid, params []Param) Address`</h4><p>&gt; This method is the core of the <code>Init Actor</code>. It handles instantiating new actors and assigning them their IDs.</p><section id="sec--Exec-code-Cid-params-Param-Address-.Parameters" secid="12.2.2.1"><h5><span class="spec-secid" title="link to this section"><a href="#sec--Exec-code-Cid-params-Param-Address-.Parameters">12.2.2.1</a></span>Parameters</h5><table><thead><tr><th>Name </th><th>Type </th><th>Description </th></tr></thead><tbody><tr><td><code>code</code> </td><td><code>Cid</code> </td><td>A pointer to the location at which the code of the actor to create is stored. </td></tr><tr><td><code>params</code> </td><td><code>[] Param</code> </td><td>The parameters passed to the constructor of the actor. </td></tr></tbody></table><p><code>Param</code> is the type representing any valid arugment that can be passed to a function.</p><div class="spec-todo">Find a better place for this definition.</div><pre><code><span class="token keyword">func</span> <span class="token function">Exec</span><span class="token punctuation">(</span>code Cid<span class="token punctuation">,</span> params <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> Address <span class="token punctuation">{</span>
	<span class="token comment" spellcheck="true">// Get the actor ID for this actor.</span>
	actorID <span class="token operator">=</span> self<span class="token punctuation">.</span>NextID
	self<span class="token punctuation">.</span>NextID<span class="token operator">++</span>

	<span class="token comment" spellcheck="true">// Make sure that only the actors defined in the spec can be launched.</span>
	<span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">IsBuiltinActor</span><span class="token punctuation">(</span>code<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"cannot launch actor instance that is not a builtin actor"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	<span class="token comment" spellcheck="true">// Ensure that singeltons can be only launched once.</span>
	<span class="token comment" spellcheck="true">// TODO: do we want to enforce this? If so how should actors be marked as such?</span>
	<span class="token keyword">if</span> <span class="token function">IsSingletonActor</span><span class="token punctuation">(</span>code<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"cannot launch another actor of this type"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	<span class="token comment" spellcheck="true">// This generates a unique address for this actor that is stable across message</span>
	<span class="token comment" spellcheck="true">// reordering</span>
	addr <span class="token operator">:=</span> VM<span class="token punctuation">.</span><span class="token function">ComputeActorAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token comment" spellcheck="true">// Set up the actor itself</span>
	actor <span class="token operator">:=</span> Actor<span class="token punctuation">{</span>
		Code<span class="token punctuation">:</span>    code<span class="token punctuation">,</span>
		Balance<span class="token punctuation">:</span> msg<span class="token punctuation">.</span>Value<span class="token punctuation">,</span>
	<span class="token punctuation">}</span>

	<span class="token comment" spellcheck="true">// The call to the actors constructor will set up the initial state</span>
	<span class="token comment" spellcheck="true">// from the given parameters</span>
	actor<span class="token punctuation">.</span><span class="token function">Constructor</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span>

	VM<span class="token punctuation">.</span>GlobalState<span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span>actorID<span class="token punctuation">,</span> actor<span class="token punctuation">)</span>

	<span class="token comment" spellcheck="true">// Store the mapping of address to actor ID.</span>
	self<span class="token punctuation">.</span>AddressMap<span class="token punctuation">[</span>addr<span class="token punctuation">]</span> <span class="token operator">=</span> actorID

	<span class="token keyword">return</span> addr
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">IsSingletonActor</span><span class="token punctuation">(</span>code Cid<span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> code <span class="token operator">==</span> StorageMarketActor <span class="token operator">||</span> code <span class="token operator">==</span> InitActor
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// TODO: find a better home for this logic</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>VM VM<span class="token punctuation">)</span> <span class="token function">ComputeActorAddress</span><span class="token punctuation">(</span>creator Address<span class="token punctuation">,</span> nonce Integer<span class="token punctuation">)</span> Address <span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token function">NewActorAddress</span><span class="token punctuation">(</span>bytes<span class="token punctuation">.</span><span class="token function">Concat</span><span class="token punctuation">(</span>creator<span class="token punctuation">.</span><span class="token function">Bytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nonce<span class="token punctuation">.</span><span class="token function">BigEndianBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></section></section><section id="sec--GetIdForAddress-addr-Address-BigInt-" secid="12.2.3"><h4><span class="spec-secid" title="link to this section"><a href="#sec--GetIdForAddress-addr-Address-BigInt-">12.2.3</a></span>`GetIdForAddress(addr Address) BigInt`</h4><p>&gt; This method allows for fetching the corresponding ID of a given Address</p><section id="sec--GetIdForAddress-addr-Address-BigInt-.Parameters" secid="12.2.3.1"><h5><span class="spec-secid" title="link to this section"><a href="#sec--GetIdForAddress-addr-Address-BigInt-.Parameters">12.2.3.1</a></span>Parameters</h5><table><thead><tr><th>Name </th><th>Type </th><th>Description </th></tr></thead><tbody><tr><td><code>addr</code> </td><td><code>Address</code> </td><td>The address to lookup </td></tr></tbody></table><pre><code><span class="token keyword">func</span> <span class="token function">GetIdForAddress</span><span class="token punctuation">(</span>addr Address<span class="token punctuation">)</span> BigInt <span class="token punctuation">{</span>
	id <span class="token operator">:=</span> self<span class="token punctuation">.</span>AddressMap<span class="token punctuation">[</span>addr<span class="token punctuation">]</span>
	<span class="token keyword">if</span> id <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
		<span class="token function">Fault</span><span class="token punctuation">(</span><span class="token string">"unknown address"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> id
<span class="token punctuation">}</span>
</code></pre></section></section></section><section id="sec-Account-Actor" secid="12.3"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Account-Actor">12.3</a></span>Account Actor</h3><p>The Account actor is the actor used for normal keypair backed accounts on the filecoin network.</p><pre><code><span class="token keyword">type</span> AccountActor <span class="token keyword">struct</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// The account actor has no extra state</span>
<span class="token punctuation">}</span>
</code></pre><section id="sec-Account-Actor.Code-Cid" secid="12.3.1"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Account-Actor.Code-Cid">12.3.1</a></span>Code Cid</h4><p><code>&lt;codec:raw&gt;&lt;mhType:identity&gt;&lt;&quot;account&quot;&gt;</code></p></section></section><section id="sec-Storage-Market-Actor" secid="12.4"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Storage-Market-Actor">12.4</a></span>Storage Market Actor</h3><p>The storage market actor is the central point for the Filecoin storage market. It is responsible for registering new miners to the system, and maintaining the power table. The Filecoin storage market is a singleton that lives at a specific well&#8208;known address.</p><pre><code><span class="token keyword">type</span> StorageMarketActor <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	Miners AddressSet

	<span class="token comment" spellcheck="true">// TODO: Determine correct unit of measure. Could be denominated in the</span>
	<span class="token comment" spellcheck="true">// smallest sector size supported by the network.</span>
	TotalStorage BytesAmount
<span class="token punctuation">}</span>
</code></pre><section id="sec-Storage-Market-Actor.Code-Cid" secid="12.4.1"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Storage-Market-Actor.Code-Cid">12.4.1</a></span>Code Cid</h4><p><code>&lt;codec:raw&gt;&lt;mhType:identity&gt;&lt;&quot;smarket&quot;&gt;</code></p><table><thead><tr><th>Index </th><th>Method Name </th></tr></thead><tbody><tr><td>0 </td><td><code>CreateStorageMiner</code> </td></tr><tr><td>1 </td><td><code>SlashConsensusFault</code> </td></tr><tr><td>2 </td><td><code>UpdateStorage</code> </td></tr><tr><td>3 </td><td><code>GetTotalStorage</code> </td></tr></tbody></table><section id="sec-CreateStorageMiner" secid="12.4.1.1"><h5><span class="spec-secid" title="link to this section"><a href="#sec-CreateStorageMiner">12.4.1.1</a></span>CreateStorageMiner</h5><div class="spec-production" id="Parameters"><span class="spec-nt"><a href="#Parameters" data-name="Parameters">Parameters</a></span><div class="spec-rhs"><span class="spec-t">pubkey</span><span class="spec-nt"><span data-name="PublicKey">PublicKey</span></span></div><div class="spec-rhs"><span class="spec-t">pledge</span><span class="spec-nt"><span data-name="BytesAmount">BytesAmount</span></span></div><div class="spec-rhs"><span class="spec-t">sectorSize</span><span class="spec-nt"><span data-name="BytesAmount">BytesAmount</span></span></div><div class="spec-rhs"><span class="spec-t">pid</span><span class="spec-nt"><span data-name="PeerID">PeerID</span></span></div></div><div class="spec-production" id="Return"><span class="spec-nt"><a href="#Return" data-name="Return">Return</a></span><div class="spec-rhs"><span class="spec-nt"><span data-name="Address">Address</span></span></div></div><pre><code><span class="token keyword">func</span> <span class="token function">CreateStorageMiner</span><span class="token punctuation">(</span>pubkey PublicKey<span class="token punctuation">,</span> pledge<span class="token punctuation">,</span> sectorSize BytesAmount<span class="token punctuation">,</span> pid PeerID<span class="token punctuation">)</span> Address <span class="token punctuation">{</span>
	<span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">SupportedSectorSize</span><span class="token punctuation">(</span>sectorSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"Unsupported sector size"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">if</span> pledge <span class="token operator">&lt;</span> <span class="token function">MinimumPledge</span><span class="token punctuation">(</span>sectorSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"Pledge too low"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">if</span> msg<span class="token punctuation">.</span>Value <span class="token operator">&lt;</span> <span class="token function">MinimumCollateral</span><span class="token punctuation">(</span>pledge<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"not enough funds to cover required collateral"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	newminer <span class="token operator">:=</span> InitActor<span class="token punctuation">.</span><span class="token function">Exec</span><span class="token punctuation">(</span>MinerActorCodeCid<span class="token punctuation">,</span> <span class="token function">EncodeParams</span><span class="token punctuation">(</span>pubkey<span class="token punctuation">,</span> pledge<span class="token punctuation">,</span> sectorSize<span class="token punctuation">,</span> pid<span class="token punctuation">)</span><span class="token punctuation">)</span>

	self<span class="token punctuation">.</span>Miners<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>newminer<span class="token punctuation">)</span>

	<span class="token keyword">return</span> newminer
<span class="token punctuation">}</span>
</code></pre></section></section><section id="sec-SlashConsensusFault" secid="12.4.2"><h4><span class="spec-secid" title="link to this section"><a href="#sec-SlashConsensusFault">12.4.2</a></span>SlashConsensusFault</h4><div class="spec-production" id="Parameters"><span class="spec-nt"><a href="#Parameters" data-name="Parameters">Parameters</a></span><div class="spec-rhs"><span class="spec-t">block1</span><span class="spec-nt"><span data-name="BlockHeader">BlockHeader</span></span></div><div class="spec-rhs"><span class="spec-t">block2</span><span class="spec-nt"><span data-name="BlockHeader">BlockHeader</span></span></div></div><div class="spec-production" id="Return"><span class="spec-nt"><a href="#Return" data-name="Return">Return</a></span><div class="spec-rhs"><span class="spec-nt"><span data-name="None">None</span></span></div></div><pre><code><span class="token keyword">func</span> <span class="token function">shouldSlash</span><span class="token punctuation">(</span>block1<span class="token punctuation">,</span> block2 BlockHeader<span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">{</span>
	<span class="token comment" spellcheck="true">// First slashing condition, blocks have the same ticket round</span>
	<span class="token keyword">if</span> <span class="token function">sameTicketRound</span><span class="token punctuation">(</span>block1<span class="token punctuation">,</span> block2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token boolean">true</span>
	<span class="token punctuation">}</span>

	<span class="token comment" spellcheck="true">// Second slashing condition, miner ignored own block when mining</span>
	<span class="token comment" spellcheck="true">// Case A: block2 could have been in block1's parent set but is not</span>
	block1ParentTipSet <span class="token operator">:=</span> <span class="token function">parentOf</span><span class="token punctuation">(</span>block1<span class="token punctuation">)</span>
	<span class="token keyword">if</span> <span class="token operator">!</span>block1Parent<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>block2<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
		block1ParentTipSet<span class="token punctuation">.</span>Height <span class="token operator">==</span> block2<span class="token punctuation">.</span>Height <span class="token operator">&amp;&amp;</span>
		block1ParentTipSet<span class="token punctuation">.</span>ParentCids <span class="token operator">==</span> block2<span class="token punctuation">.</span>ParentCids <span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token boolean">true</span>
	<span class="token punctuation">}</span>

	<span class="token comment" spellcheck="true">// Case B: block1 could have been in block2's parent set but is not</span>
	block2ParentTipSet <span class="token operator">:=</span> <span class="token function">parentOf</span><span class="token punctuation">(</span>block2<span class="token punctuation">)</span>
	<span class="token keyword">if</span> <span class="token operator">!</span>block2Parent<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>block1<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
		block2ParentTipSet<span class="token punctuation">.</span>Height <span class="token operator">==</span> block1<span class="token punctuation">.</span>Height <span class="token operator">&amp;&amp;</span>
		block2ParentTipSet<span class="token punctuation">.</span>ParentCids <span class="token operator">==</span> block1<span class="token punctuation">.</span>ParentCids <span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token boolean">true</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">return</span> <span class="token boolean">false</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">SlashConsensusFault</span><span class="token punctuation">(</span>block1<span class="token punctuation">,</span> block2 BlockHeader<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">ValidateSignature</span><span class="token punctuation">(</span>block1<span class="token punctuation">.</span>Signature<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">ValidSignature</span><span class="token punctuation">(</span>block2<span class="token punctuation">.</span>Signature<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"invalid blocks"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">if</span> <span class="token function">AuthorOf</span><span class="token punctuation">(</span>block1<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token function">AuthorOf</span><span class="token punctuation">(</span>block2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"blocks must be from the same miner"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	<span class="token comment" spellcheck="true">// see the "Consensus Faults" section of the faults spec (faults.md)</span>
	<span class="token comment" spellcheck="true">// for details on these slashing conditions.</span>
	<span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">shouldSlash</span><span class="token punctuation">(</span>block1<span class="token punctuation">,</span> block2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"blocks do not prove a slashable offense"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	miner <span class="token operator">:=</span> <span class="token function">AuthorOf</span><span class="token punctuation">(</span>block1<span class="token punctuation">)</span>

	<span class="token comment" spellcheck="true">// TODO: Some of the slashed collateral should be paid to the slasher</span>

	<span class="token comment" spellcheck="true">// Burn all of the miners collateral</span>
	miner<span class="token punctuation">.</span><span class="token function">BurnCollateral</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token comment" spellcheck="true">// Remove the miner from the list of network miners</span>
	self<span class="token punctuation">.</span>Miners<span class="token punctuation">.</span><span class="token function">Remove</span><span class="token punctuation">(</span>miner<span class="token punctuation">)</span>
	self<span class="token punctuation">.</span><span class="token function">UpdateStorage</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">*</span> miner<span class="token punctuation">.</span>Power<span class="token punctuation">)</span>

	<span class="token comment" spellcheck="true">// Now delete the miner (maybe this is a bit harsh, but i'm okay with it for now)</span>
	miner<span class="token punctuation">.</span><span class="token function">SelfDestruct</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></section><section id="sec-UpdateStorage" secid="12.4.3"><h4><span class="spec-secid" title="link to this section"><a href="#sec-UpdateStorage">12.4.3</a></span>UpdateStorage</h4><p>UpdateStorage is used to update the global power table.</p><div class="spec-production" id="Parameters"><span class="spec-nt"><a href="#Parameters" data-name="Parameters">Parameters</a></span><div class="spec-rhs"><span class="spec-t">delta</span><span class="spec-nt"><span data-name="BytesAmount">BytesAmount</span></span></div></div><div class="spec-production" id="Return"><span class="spec-nt"><a href="#Return" data-name="Return">Return</a></span><div class="spec-rhs"><span class="spec-nt"><span data-name="None">None</span></span></div></div><pre><code><span class="token keyword">func</span> <span class="token function">UpdateStorage</span><span class="token punctuation">(</span>delta BytesAmount<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> <span class="token operator">!</span>self<span class="token punctuation">.</span>Miners<span class="token punctuation">.</span><span class="token function">Has</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>From<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"update storage must only be called by a miner actor"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	self<span class="token punctuation">.</span>TotalStorage <span class="token operator">+=</span> delta
<span class="token punctuation">}</span>
</code></pre></section><section id="sec-GetTotalStorage" secid="12.4.4"><h4><span class="spec-secid" title="link to this section"><a href="#sec-GetTotalStorage">12.4.4</a></span>GetTotalStorage</h4><div class="spec-production" id="Parameters"><span class="spec-nt"><a href="#Parameters" data-name="Parameters">Parameters</a></span><div class="spec-rhs"><span class="spec-nt"><span data-name="None">None</span></span></div></div><div class="spec-production" id="Return"><span class="spec-nt"><a href="#Return" data-name="Return">Return</a></span><div class="spec-rhs"><span class="spec-nt"><span data-name="BytesAmount">BytesAmount</span></span></div></div><pre><code><span class="token keyword">func</span> <span class="token function">GetTotalStorage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> BytesAmount <span class="token punctuation">{</span>
	<span class="token keyword">return</span> self<span class="token punctuation">.</span>TotalStorage
<span class="token punctuation">}</span>
</code></pre></section></section><section id="sec-Storage-Miner-Actor" secid="12.5"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Storage-Miner-Actor">12.5</a></span>Storage Miner Actor</h3><pre><code><span class="token keyword">type</span> StorageMiner <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	<span class="token comment" spellcheck="true">// Owner is the address of the account that owns this miner</span>
	Owner Address

	<span class="token comment" spellcheck="true">// Worker is the address of the worker account for this miner</span>
	Worker Address

	<span class="token comment" spellcheck="true">// PeerID is the libp2p peer identity that should be used to connect</span>
	<span class="token comment" spellcheck="true">// to this miner</span>
	PeerID peer<span class="token punctuation">.</span>ID

	<span class="token comment" spellcheck="true">// PublicKey is the public portion of the key that the miner will use to sign blocks</span>
	PublicKey PublicKey

	<span class="token comment" spellcheck="true">// PledgeBytes is the amount of space being offered by this miner to the network</span>
	PledgeBytes BytesAmount

	<span class="token comment" spellcheck="true">// SectorSize is the amount of space in each sector committed to the network</span>
	<span class="token comment" spellcheck="true">// by this miner.</span>
	SectorSize BytesAmount

	<span class="token comment" spellcheck="true">// Collateral is locked up filecoin the miner has available to commit to storage.</span>
	<span class="token comment" spellcheck="true">// When miners commit new sectors, tokens are moved from here to 'ActiveCollateral'</span>
	<span class="token comment" spellcheck="true">// The sum of collateral here and in activecollateral should equal the required amount</span>
	<span class="token comment" spellcheck="true">// for the size of the miners pledge.</span>
	Collateral TokenAmount

	<span class="token comment" spellcheck="true">// ActiveCollateral is the amount of collateral currently committed to live storage</span>
	ActiveCollateral TokenAmount

	<span class="token comment" spellcheck="true">// DePledgedCollateral is collateral that is waiting to be withdrawn</span>
	DePledgedCollateral TokenAmount

	<span class="token comment" spellcheck="true">// DePledgeTime is the time at which the depledged collateral may be withdrawn</span>
	DePledgeTime BlockHeight

	<span class="token comment" spellcheck="true">// Sectors is the set of all sectors this miner has committed</span>
	Sectors SectorSet

	<span class="token comment" spellcheck="true">// ProvingSet is the set of sectors this miner is currently mining. It is only updated</span>
	<span class="token comment" spellcheck="true">// when a PoSt is submitted (not as each new sector commitment is added)</span>
	ProvingSet SectorSet

	<span class="token comment" spellcheck="true">// NextDoneSet is a set of sectors reported during the last PoSt submission as</span>
	<span class="token comment" spellcheck="true">// being 'done'. The collateral for them is still being held until the next PoSt</span>
	<span class="token comment" spellcheck="true">// submission in case early sector removal penalization is needed.</span>
	NextDoneSet SectorSet

	<span class="token comment" spellcheck="true">// ArbitratedDeals is the set of deals this miner has been slashed for since the</span>
	<span class="token comment" spellcheck="true">// last post submission</span>
	ArbitratedDeals CidSet

	<span class="token comment" spellcheck="true">// TODO: maybe this number is redundant with power</span>
	LockedStorage Integer

	<span class="token comment" spellcheck="true">// Power is the amount of power this miner has</span>
	Power Integer

	<span class="token comment" spellcheck="true">// Asks are the set of active asks this miner has available</span>
	Asks AskSet
<span class="token punctuation">}</span>
</code></pre><section id="sec-Storage-Miner-Actor.Code-Cid" secid="12.5.1"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Storage-Miner-Actor.Code-Cid">12.5.1</a></span>Code Cid</h4><p><code>&lt;codec:raw&gt;&lt;mhType:identity&gt;&lt;&quot;sminer&quot;&gt;</code></p><table><thead><tr><th>Index </th><th>Method Name </th></tr></thead><tbody><tr><td>1 </td><td><code>AddAsk</code> </td></tr><tr><td>2 </td><td><code>CommitSector</code> </td></tr><tr><td>3 </td><td><code>SubmitPoSt</code> </td></tr><tr><td>4 </td><td><code>SlashStorageFault</code> </td></tr><tr><td>5 </td><td><code>GetCurrentProvingSet</code> </td></tr><tr><td>6 </td><td><code>ArbitrateDeal</code> </td></tr><tr><td>7 </td><td><code>DePledge</code> </td></tr><tr><td>8 </td><td><code>GetOwner</code> </td></tr><tr><td>9 </td><td><code>GetWorkerAddr</code> </td></tr><tr><td>10 </td><td><code>GetPower</code> </td></tr><tr><td>11 </td><td><code>GetKey</code> </td></tr><tr><td>12 </td><td><code>GetPeerID</code> </td></tr><tr><td>13 </td><td><code>GetSectorSize</code> </td></tr><tr><td>14 </td><td><code>UpdatePeerID</code> </td></tr></tbody></table></section><section id="sec-Storage-Miner-Actor.Constructor" secid="12.5.2"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Storage-Miner-Actor.Constructor">12.5.2</a></span>Constructor</h4><p>Along with the call, the actor must be created with exactly enough filecoin for the collateral necessary for the pledge.</p><pre><code><span class="token keyword">func</span> <span class="token function">StorageMinerActor</span><span class="token punctuation">(</span>pubkey PublicKey<span class="token punctuation">,</span> pledge BytesAmount<span class="token punctuation">,</span> pid PeerID<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> msg<span class="token punctuation">.</span>Value <span class="token operator">&lt;</span> <span class="token function">CollateralForPledgeSize</span><span class="token punctuation">(</span>pledge<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"not enough collateral given"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	self<span class="token punctuation">.</span>Owner <span class="token operator">=</span> message<span class="token punctuation">.</span>From
	self<span class="token punctuation">.</span>PublicKey <span class="token operator">=</span> pubkey
	self<span class="token punctuation">.</span>PeerID <span class="token operator">=</span> pid
	self<span class="token punctuation">.</span>PledgeBytes <span class="token operator">=</span> pledge
<span class="token punctuation">}</span>
</code></pre></section><section id="sec-AddAsk" secid="12.5.3"><h4><span class="spec-secid" title="link to this section"><a href="#sec-AddAsk">12.5.3</a></span>AddAsk</h4><div class="spec-production" id="Parameters"><span class="spec-nt"><a href="#Parameters" data-name="Parameters">Parameters</a></span><div class="spec-rhs"><span class="spec-t">price</span><span class="spec-nt"><span data-name="TokenAmount">TokenAmount</span></span></div><div class="spec-rhs"><span class="spec-t">ttl</span><span class="spec-nt"><span data-name="Integer">Integer</span></span></div></div><div class="spec-production" id="Return"><span class="spec-nt"><a href="#Return" data-name="Return">Return</a></span><div class="spec-rhs"><span class="spec-nt"><span data-name="AskID">AskID</span></span></div></div><pre><code><span class="token keyword">func</span> <span class="token function">AddAsk</span><span class="token punctuation">(</span>price TokenAmount<span class="token punctuation">,</span> ttl Integer<span class="token punctuation">)</span> AskID <span class="token punctuation">{</span>
	<span class="token keyword">if</span> msg<span class="token punctuation">.</span>From <span class="token operator">!=</span> self<span class="token punctuation">.</span>Worker <span class="token punctuation">{</span>
		<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"Asks may only be added via the worker address"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	<span class="token comment" spellcheck="true">// Filter out expired asks</span>
	self<span class="token punctuation">.</span>Asks<span class="token punctuation">.</span><span class="token function">FilterExpired</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	askid <span class="token operator">:=</span> self<span class="token punctuation">.</span>NextAskID
	self<span class="token punctuation">.</span>NextAskID<span class="token operator">++</span>

	self<span class="token punctuation">.</span>Asks<span class="token punctuation">.</span><span class="token function">Append</span><span class="token punctuation">(</span>Ask<span class="token punctuation">{</span>
		Price<span class="token punctuation">:</span>  price<span class="token punctuation">,</span>
		Expiry<span class="token punctuation">:</span> CurrentBlockHeight <span class="token operator">+</span> ttl<span class="token punctuation">,</span>
		ID<span class="token punctuation">:</span>     askid<span class="token punctuation">,</span>
	<span class="token punctuation">}</span><span class="token punctuation">)</span>

	<span class="token keyword">return</span> askid
<span class="token punctuation">}</span>
</code></pre><div class="spec-note">this may be moved off chain soon, don&rsquo;t worry about testing it too heavily.</div></section><section id="sec-CommitSector" secid="12.5.4"><h4><span class="spec-secid" title="link to this section"><a href="#sec-CommitSector">12.5.4</a></span>CommitSector</h4><div class="spec-production" id="Parameters"><span class="spec-nt"><a href="#Parameters" data-name="Parameters">Parameters</a></span><div class="spec-rhs"><span class="spec-t">commD</span><span class="spec-t">[</span><span class="spec-t">]byte</span></div><div class="spec-rhs"><span class="spec-t">commR</span><span class="spec-t">[</span><span class="spec-t">]byte</span></div><div class="spec-rhs"><span class="spec-t">commRStar</span><span class="spec-t">[</span><span class="spec-t">]byte</span></div><div class="spec-rhs"><span class="spec-t">proof</span><span class="spec-nt"><span data-name="SealProof">SealProof</span></span></div></div><div class="spec-production" id="Return"><span class="spec-nt"><a href="#Return" data-name="Return">Return</a></span><div class="spec-rhs"><span class="spec-nt"><span data-name="SectorID">SectorID</span></span></div></div><pre><code><span class="token comment" spellcheck="true">// NotYetSpeced: ValidatePoRep, EnsureSectorIsUnique, CollateralForSector, Commitment</span>
<span class="token keyword">func</span> <span class="token function">CommitSector</span><span class="token punctuation">(</span>comm Commitment<span class="token punctuation">,</span> proof <span class="token operator">*</span>SealProof<span class="token punctuation">)</span> SectorID <span class="token punctuation">{</span>
	<span class="token keyword">if</span> <span class="token operator">!</span>miner<span class="token punctuation">.</span><span class="token function">ValidatePoRep</span><span class="token punctuation">(</span>miner<span class="token punctuation">.</span>SectorSize<span class="token punctuation">,</span> comm<span class="token punctuation">,</span> miner<span class="token punctuation">.</span>PublicKey<span class="token punctuation">,</span> proof<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"bad proof!"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	<span class="token comment" spellcheck="true">// make sure the miner isnt trying to submit a pre-existing sector</span>
	<span class="token keyword">if</span> <span class="token operator">!</span>miner<span class="token punctuation">.</span><span class="token function">EnsureSectorIsUnique</span><span class="token punctuation">(</span>comm<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"sector already committed!"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	<span class="token comment" spellcheck="true">// make sure the miner has enough collateral to add more storage</span>
	coll <span class="token operator">=</span> <span class="token function">CollateralForSector</span><span class="token punctuation">(</span>miner<span class="token punctuation">.</span>SectorSize<span class="token punctuation">)</span>

	<span class="token keyword">if</span> coll <span class="token operator">&lt;</span> miner<span class="token punctuation">.</span>Collateral <span class="token punctuation">{</span>
		<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"not enough collateral"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	miner<span class="token punctuation">.</span>Collateral <span class="token operator">-=</span> coll
	miner<span class="token punctuation">.</span>ActiveCollateral <span class="token operator">+=</span> coll

	sectorId <span class="token operator">=</span> miner<span class="token punctuation">.</span>Sectors<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>commR<span class="token punctuation">)</span>
	<span class="token comment" spellcheck="true">// TODO: sectors IDs might not be that useful. For now, this should just be the number of</span>
	<span class="token comment" spellcheck="true">// the sector within the set of sectors, but that can change as the miner experiences</span>
	<span class="token comment" spellcheck="true">// failures.</span>

	<span class="token comment" spellcheck="true">// if miner is not mining, start their proving period now</span>
	<span class="token comment" spellcheck="true">// Note: As written here, every miners first PoSt will only be over one sector.</span>
	<span class="token comment" spellcheck="true">// We could set up a 'grace period' for starting mining that would allow miners</span>
	<span class="token comment" spellcheck="true">// to submit several sectors for their first proving period. Alternatively, we</span>
	<span class="token comment" spellcheck="true">// could simply make the 'CommitSector' call take multiple sectors at a time.</span>
	<span class="token comment" spellcheck="true">//</span>
	<span class="token comment" spellcheck="true">// Note: Proving period is a function of sector size; small sectors take less</span>
	<span class="token comment" spellcheck="true">// time to prove than large sectors do. Sector size is selected when pledging.</span>
	<span class="token keyword">if</span> miner<span class="token punctuation">.</span>ProvingSet<span class="token punctuation">.</span><span class="token function">Size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>
		miner<span class="token punctuation">.</span>ProvingSet <span class="token operator">=</span> miner<span class="token punctuation">.</span>Sectors
		miner<span class="token punctuation">.</span>ProvingPeriodEnd <span class="token operator">=</span> chain<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">ProvingPeriodDuration</span><span class="token punctuation">(</span>miner<span class="token punctuation">.</span>SectorSize<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">return</span> sectorId
<span class="token punctuation">}</span>
</code></pre></section><section id="sec-SubmitPoSt" secid="12.5.5"><h4><span class="spec-secid" title="link to this section"><a href="#sec-SubmitPoSt">12.5.5</a></span>SubmitPoSt</h4><div class="spec-production" id="Parameters"><span class="spec-nt"><a href="#Parameters" data-name="Parameters">Parameters</a></span><div class="spec-rhs"><span class="spec-t">proofs</span><span class="spec-t">[</span><span class="spec-t">]PoStProof</span></div><div class="spec-rhs"><span class="spec-t">faults</span><span class="spec-t">[</span><span class="spec-t">]FailureSet</span></div><div class="spec-rhs"><span class="spec-t">recovered</span><span class="spec-nt"><span data-name="SectorSet">SectorSet</span></span></div><div class="spec-rhs"><span class="spec-t">done</span><span class="spec-nt"><span data-name="SectorSet">SectorSet</span></span></div></div><div class="spec-production" id="Return"><span class="spec-nt"><a href="#Return" data-name="Return">Return</a></span><div class="spec-rhs"><span class="spec-nt"><span data-name="None">None</span></span></div></div><pre><code><span class="token comment" spellcheck="true">// NotYetSpeced: ValidateFaultSets, GenerationAttackTime, ComputeLateFee</span>
<span class="token keyword">func</span> <span class="token function">SubmitPost</span><span class="token punctuation">(</span>proofs <span class="token punctuation">[</span><span class="token punctuation">]</span>PoStProof<span class="token punctuation">,</span> faults <span class="token punctuation">[</span><span class="token punctuation">]</span>FaultSet<span class="token punctuation">,</span> recovered BitField<span class="token punctuation">,</span> done BitField<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> msg<span class="token punctuation">.</span>From <span class="token operator">!=</span> miner<span class="token punctuation">.</span>Worker <span class="token punctuation">{</span>
		<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"not authorized to submit post for miner"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	<span class="token comment" spellcheck="true">// ensure the fault sets properly stack, recovered is a subset of the combined</span>
	<span class="token comment" spellcheck="true">// fault sets, and that done does not intersect with either, and that all sets</span>
	<span class="token comment" spellcheck="true">// only reference sectors that currently exist</span>
	<span class="token keyword">if</span> <span class="token operator">!</span>miner<span class="token punctuation">.</span><span class="token function">ValidateFaultSets</span><span class="token punctuation">(</span>faults<span class="token punctuation">,</span> recovered<span class="token punctuation">,</span> done<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"fault sets invalid"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">var</span> feesRequired TokenAmount

	<span class="token keyword">if</span> chain<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> miner<span class="token punctuation">.</span>ProvingPeriodEnd<span class="token operator">+</span><span class="token function">GenerationAttackTime</span><span class="token punctuation">(</span>miner<span class="token punctuation">.</span>SectorSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token comment" spellcheck="true">// TODO: determine what exactly happens here. Is the miner permanently banned?</span>
		<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"Post submission too late"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> chain<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> miner<span class="token punctuation">.</span>ProvingPeriodEnd <span class="token punctuation">{</span>
		feesRequired <span class="token operator">+=</span> <span class="token function">ComputeLateFee</span><span class="token punctuation">(</span>chain<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> miner<span class="token punctuation">.</span>ProvingPeriodEnd<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	feesRequired <span class="token operator">+=</span> <span class="token function">ComputeTemporarySectorFailureFee</span><span class="token punctuation">(</span>recovered<span class="token punctuation">)</span>

	<span class="token keyword">if</span> msg<span class="token punctuation">.</span>Value <span class="token operator">&lt;</span> feesRequired <span class="token punctuation">{</span>
		<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"not enough funds to pay post submission fees"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	<span class="token comment" spellcheck="true">// we want to ensure that the miner can submit more fees than required, just in case</span>
	<span class="token keyword">if</span> msg<span class="token punctuation">.</span>Value <span class="token operator">></span> feesRequired <span class="token punctuation">{</span>
		<span class="token function">Refund</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>Value <span class="token operator">-</span> feesRequired<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">CheckPostProofs</span><span class="token punctuation">(</span>miner<span class="token punctuation">.</span>SectorSize<span class="token punctuation">,</span> proofs<span class="token punctuation">,</span> faults<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"proofs invalid"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	permLostSet <span class="token operator">=</span> <span class="token function">AggregateBitfields</span><span class="token punctuation">(</span>faults<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Subtract</span><span class="token punctuation">(</span>recovered<span class="token punctuation">)</span>

	<span class="token comment" spellcheck="true">// adjust collateral for 'done' sectors</span>
	miner<span class="token punctuation">.</span>ActiveCollateral <span class="token operator">-=</span> <span class="token function">CollateralForSectors</span><span class="token punctuation">(</span>miner<span class="token punctuation">.</span>SectorSize<span class="token punctuation">,</span> miner<span class="token punctuation">.</span>NextDoneSet<span class="token punctuation">)</span>
	miner<span class="token punctuation">.</span>Collateral <span class="token operator">+=</span> <span class="token function">CollateralForSectors</span><span class="token punctuation">(</span>miner<span class="token punctuation">.</span>SectorSize<span class="token punctuation">,</span> miner<span class="token punctuation">.</span>NextDoneSet<span class="token punctuation">)</span>

	<span class="token comment" spellcheck="true">// penalize collateral for lost sectors</span>
	miner<span class="token punctuation">.</span>ActiveCollateral <span class="token operator">-=</span> <span class="token function">CollateralForSectors</span><span class="token punctuation">(</span>miner<span class="token punctuation">.</span>SectorSize<span class="token punctuation">,</span> permLostSet<span class="token punctuation">)</span>

	<span class="token comment" spellcheck="true">// burn funds for fees and collateral penalization</span>
	<span class="token function">BurnFunds</span><span class="token punctuation">(</span>miner<span class="token punctuation">,</span> <span class="token function">CollateralForSectors</span><span class="token punctuation">(</span>miner<span class="token punctuation">.</span>SectorSize<span class="token punctuation">,</span> permLostSet<span class="token punctuation">)</span><span class="token operator">+</span>feesRequired<span class="token punctuation">)</span>

	<span class="token comment" spellcheck="true">// update sector sets and proving set</span>
	miner<span class="token punctuation">.</span>Sectors<span class="token punctuation">.</span><span class="token function">Subtract</span><span class="token punctuation">(</span>done<span class="token punctuation">)</span>
	miner<span class="token punctuation">.</span>Sectors<span class="token punctuation">.</span><span class="token function">Subtract</span><span class="token punctuation">(</span>permLostSet<span class="token punctuation">)</span>

	<span class="token comment" spellcheck="true">// update miner power to the amount of data actually proved during</span>
	<span class="token comment" spellcheck="true">// the last proving period.</span>
	oldPower <span class="token operator">:=</span> miner<span class="token punctuation">.</span>Power
	miner<span class="token punctuation">.</span>Power <span class="token operator">=</span> <span class="token function">SizeOf</span><span class="token punctuation">(</span><span class="token function">Filter</span><span class="token punctuation">(</span>miner<span class="token punctuation">.</span>ProvingSet<span class="token punctuation">,</span> faults<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> miner<span class="token punctuation">.</span>SectorSize
	StorageMarket<span class="token punctuation">.</span><span class="token function">UpdateStorage</span><span class="token punctuation">(</span>miner<span class="token punctuation">.</span>Power <span class="token operator">-</span> oldPower<span class="token punctuation">)</span>

	miner<span class="token punctuation">.</span>ProvingSet <span class="token operator">=</span> miner<span class="token punctuation">.</span>Sectors

	<span class="token comment" spellcheck="true">// NEEDS REVIEW: early submission of PoSts may give the miner extra time for</span>
	<span class="token comment" spellcheck="true">// their next PoSt, which could compound. Does the beacon reseeding for Posts</span>
	<span class="token comment" spellcheck="true">// address this well enough?</span>
	miner<span class="token punctuation">.</span>ProvingPeriodEnd <span class="token operator">=</span> miner<span class="token punctuation">.</span>ProvingPeriodEnd <span class="token operator">+</span> <span class="token function">ProvingPeriodDuration</span><span class="token punctuation">(</span>miner<span class="token punctuation">.</span>SectorSize<span class="token punctuation">)</span>

	<span class="token comment" spellcheck="true">// update next done set</span>
	miner<span class="token punctuation">.</span>NextDoneSet <span class="token operator">=</span> done
	miner<span class="token punctuation">.</span>ArbitratedDeals<span class="token punctuation">.</span><span class="token function">Clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></section><section id="sec-IncreasePledge" secid="12.5.6"><h4><span class="spec-secid" title="link to this section"><a href="#sec-IncreasePledge">12.5.6</a></span>IncreasePledge</h4><div class="spec-production" id="Parameters"><span class="spec-nt"><a href="#Parameters" data-name="Parameters">Parameters</a></span><div class="spec-rhs"><span class="spec-t">addspace</span><span class="spec-nt"><span data-name="BytesAmount">BytesAmount</span></span></div></div><div class="spec-production" id="Return"><span class="spec-nt"><a href="#Return" data-name="Return">Return</a></span><div class="spec-rhs"><span class="spec-nt"><span data-name="None">None</span></span></div></div><pre><code><span class="token keyword">func</span> <span class="token function">IncreasePledge</span><span class="token punctuation">(</span>addspace BytesAmount<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment" spellcheck="true">// Note: msg.Value is implicitly transferred to the miner actor</span>
	<span class="token keyword">if</span> miner<span class="token punctuation">.</span>Collateral<span class="token operator">+</span>msg<span class="token punctuation">.</span>Value <span class="token operator">&lt;</span> <span class="token function">CollateralForPledge</span><span class="token punctuation">(</span>addspace<span class="token operator">+</span>miner<span class="token punctuation">.</span>PledgeBytes<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"not enough total collateral for the requested pledge"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	miner<span class="token punctuation">.</span>Collateral <span class="token operator">+=</span> msg<span class="token punctuation">.</span>Value
	miner<span class="token punctuation">.</span>PledgeBytes <span class="token operator">+=</span> addspace
<span class="token punctuation">}</span>
</code></pre></section><section id="sec-SlashStorageFault" secid="12.5.7"><h4><span class="spec-secid" title="link to this section"><a href="#sec-SlashStorageFault">12.5.7</a></span>SlashStorageFault</h4><div class="spec-production" id="Parameters"><span class="spec-nt"><a href="#Parameters" data-name="Parameters">Parameters</a></span><div class="spec-rhs"><span class="spec-t">miner</span><span class="spec-nt"><span data-name="Address">Address</span></span></div></div><div class="spec-production" id="Return"><span class="spec-nt"><a href="#Return" data-name="Return">Return</a></span><div class="spec-rhs"><span class="spec-nt"><span data-name="None">None</span></span></div></div><pre><code><span class="token keyword">func</span> <span class="token function">SlashStorageFault</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> self<span class="token punctuation">.</span>SlashedAt <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">{</span>
		<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"miner already slashed"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">if</span> chain<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> miner<span class="token punctuation">.</span>ProvingPeriodEnd<span class="token operator">+</span><span class="token function">GenerationAttackTime</span><span class="token punctuation">(</span>miner<span class="token punctuation">.</span>SectorSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"miner is not yet tardy"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">if</span> miner<span class="token punctuation">.</span>ProvingSet<span class="token punctuation">.</span><span class="token function">Size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>
		<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"miner is inactive"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	<span class="token comment" spellcheck="true">// Strip miner of their power</span>
	StorageMarketActor<span class="token punctuation">.</span><span class="token function">UpdateStorage</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">*</span> self<span class="token punctuation">.</span>Power<span class="token punctuation">)</span>
	self<span class="token punctuation">.</span>Power <span class="token operator">=</span> <span class="token number">0</span>

	<span class="token comment" spellcheck="true">// TODO: make this less hand wavey</span>
	<span class="token function">BurnCollateral</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>ConsensusCollateral<span class="token punctuation">)</span>

	self<span class="token punctuation">.</span>SlashedAt <span class="token operator">=</span> CurrentBlockHeight
<span class="token punctuation">}</span>
</code></pre></section><section id="sec-GetCurrentProvingSet" secid="12.5.8"><h4><span class="spec-secid" title="link to this section"><a href="#sec-GetCurrentProvingSet">12.5.8</a></span>GetCurrentProvingSet</h4><div class="spec-production" id="Parameters"><span class="spec-nt"><a href="#Parameters" data-name="Parameters">Parameters</a></span><div class="spec-rhs"><span class="spec-nt"><span data-name="None">None</span></span></div></div><div class="spec-production" id="Return"><span class="spec-nt"><a href="#Return" data-name="Return">Return</a></span><div class="spec-rhs"><span class="spec-t">[][]byte</span></div></div><pre><code><span class="token keyword">func</span> <span class="token function">GetCurrentProvingSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> self<span class="token punctuation">.</span>ProvingSet
<span class="token punctuation">}</span>
</code></pre><div class="spec-note">this is unlikely to ever be called on&#8208;chain, and will be a very large amount of data. We should reconsider the need for a list of all sector commitments (maybe fixing with accumulators?)</div></section><section id="sec-ArbitrateDeal" secid="12.5.9"><h4><span class="spec-secid" title="link to this section"><a href="#sec-ArbitrateDeal">12.5.9</a></span>ArbitrateDeal</h4><p>This may be called by anyone to penalize a miner for dropping the data of a deal they committed to before the deal expires. Note: in order to call this, the caller must have the signed deal between the client and the miner in question, this would require out of band communication of this information from the client to acquire.</p><div class="spec-production" id="Parameters"><span class="spec-nt"><a href="#Parameters" data-name="Parameters">Parameters</a></span><div class="spec-rhs"><span class="spec-t">deal</span><span class="spec-nt"><span data-name="Deal">Deal</span></span></div></div><div class="spec-production" id="Return"><span class="spec-nt"><a href="#Return" data-name="Return">Return</a></span><div class="spec-rhs"><span class="spec-nt"><span data-name="None">None</span></span></div></div><pre><code><span class="token keyword">func</span> <span class="token function">AbitrateDeal</span><span class="token punctuation">(</span>d Deal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">ValidateSignature</span><span class="token punctuation">(</span>d<span class="token punctuation">,</span> self<span class="token punctuation">.</span>Worker<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"invalid signature on deal"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">if</span> CurrentBlockHeight <span class="token operator">&lt;</span> d<span class="token punctuation">.</span>StartTime <span class="token punctuation">{</span>
		<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"Deal not yet started"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">if</span> d<span class="token punctuation">.</span>Expiry <span class="token operator">&lt;</span> CurrentBlockHeight <span class="token punctuation">{</span>
		<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"Deal is expired"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">if</span> <span class="token operator">!</span>self<span class="token punctuation">.</span>NextDoneSet<span class="token punctuation">.</span><span class="token function">Has</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>PieceCommitment<span class="token punctuation">.</span>Sector<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"Deal agreement not broken, or arbitration too late"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">if</span> self<span class="token punctuation">.</span>ArbitratedDeals<span class="token punctuation">.</span><span class="token function">Has</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>PieceRef<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"cannot slash miner twice for same deal"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	pledge<span class="token punctuation">,</span> storage <span class="token operator">:=</span> <span class="token function">CollateralForDeal</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span>

	<span class="token comment" spellcheck="true">// burn the pledge collateral</span>
	self<span class="token punctuation">.</span><span class="token function">BurnFunds</span><span class="token punctuation">(</span>pledge<span class="token punctuation">)</span>

	<span class="token comment" spellcheck="true">// pay the client the storage collateral</span>
	<span class="token function">TransferFunds</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>ClientAddr<span class="token punctuation">,</span> storage<span class="token punctuation">)</span>

	<span class="token comment" spellcheck="true">// make sure the miner can't be slashed twice for this deal</span>
	self<span class="token punctuation">.</span>ArbitratedDeals<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>PieceRef<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><p>TODO(scaling): This method, as currently designed, must be called once per sector. If a miner agrees to store 1TB (1000 sectors) for a particular client, and loses all that data, the client must then call this method 1000 times, which will be really expensive.</p></section><section id="sec-DePledge" secid="12.5.10"><h4><span class="spec-secid" title="link to this section"><a href="#sec-DePledge">12.5.10</a></span>DePledge</h4><div class="spec-production" id="Parameters"><span class="spec-nt"><a href="#Parameters" data-name="Parameters">Parameters</a></span><div class="spec-rhs"><span class="spec-t">amt</span><span class="spec-nt"><span data-name="TokenAmount">TokenAmount</span></span></div></div><div class="spec-production" id="Return"><span class="spec-nt"><a href="#Return" data-name="Return">Return</a></span><div class="spec-rhs"><span class="spec-nt"><span data-name="None">None</span></span></div></div><pre><code><span class="token keyword">func</span> <span class="token function">DePledge</span><span class="token punctuation">(</span>amt TokenAmount<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment" spellcheck="true">// TODO: Do both the worker and the owner have the right to call this?</span>
	<span class="token keyword">if</span> msg<span class="token punctuation">.</span>From <span class="token operator">!=</span> miner<span class="token punctuation">.</span>Worker <span class="token operator">&amp;&amp;</span> msg<span class="token punctuation">.</span>From <span class="token operator">!=</span> miner<span class="token punctuation">.</span>Owner <span class="token punctuation">{</span>
		<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"Not authorized to call DePledge"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">if</span> miner<span class="token punctuation">.</span>DePledgeTime <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span> miner<span class="token punctuation">.</span>DePledgeTime <span class="token operator">></span> CurrentBlockHeight <span class="token punctuation">{</span>
			<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"too early to withdraw collateral"</span><span class="token punctuation">)</span>
		<span class="token punctuation">}</span>

		<span class="token function">TransferFunds</span><span class="token punctuation">(</span>miner<span class="token punctuation">.</span>Owner<span class="token punctuation">,</span> miner<span class="token punctuation">.</span>DePledgedCollateral<span class="token punctuation">)</span>
		miner<span class="token punctuation">.</span>DePledgeTime <span class="token operator">=</span> <span class="token number">0</span>
		miner<span class="token punctuation">.</span>DePledgedCollateral <span class="token operator">=</span> <span class="token number">0</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">if</span> amt <span class="token operator">></span> miner<span class="token punctuation">.</span>Collateral <span class="token punctuation">{</span>
		<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"Not enough free collateral to withdraw that much"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	miner<span class="token punctuation">.</span>Collateral <span class="token operator">-=</span> amt
	miner<span class="token punctuation">.</span>DePledgedCollateral <span class="token operator">=</span> amt
	miner<span class="token punctuation">.</span>DePledgeTime <span class="token operator">=</span> CurrentBlockHeight <span class="token operator">+</span> DePledgeCooldown
<span class="token punctuation">}</span>
</code></pre></section><section id="sec-GetOwner" secid="12.5.11"><h4><span class="spec-secid" title="link to this section"><a href="#sec-GetOwner">12.5.11</a></span>GetOwner</h4><div class="spec-production" id="Parameters"><span class="spec-nt"><a href="#Parameters" data-name="Parameters">Parameters</a></span><div class="spec-rhs"><span class="spec-nt"><span data-name="None">None</span></span></div></div><div class="spec-production" id="Return"><span class="spec-nt"><a href="#Return" data-name="Return">Return</a></span><div class="spec-rhs"><span class="spec-nt"><span data-name="Address">Address</span></span></div></div><pre><code><span class="token keyword">func</span> <span class="token function">GetOwner</span><span class="token punctuation">(</span><span class="token punctuation">)</span> Address <span class="token punctuation">{</span>
	<span class="token keyword">return</span> self<span class="token punctuation">.</span>Owner
<span class="token punctuation">}</span>
</code></pre></section><section id="sec-GetWorkerAddr" secid="12.5.12"><h4><span class="spec-secid" title="link to this section"><a href="#sec-GetWorkerAddr">12.5.12</a></span>GetWorkerAddr</h4><div class="spec-production" id="Parameters"><span class="spec-nt"><a href="#Parameters" data-name="Parameters">Parameters</a></span><div class="spec-rhs"><span class="spec-nt"><span data-name="None">None</span></span></div></div><div class="spec-production" id="Return"><span class="spec-nt"><a href="#Return" data-name="Return">Return</a></span><div class="spec-rhs"><span class="spec-nt"><span data-name="Address">Address</span></span></div></div><pre><code><span class="token keyword">func</span> <span class="token function">GetWorkerAddr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> Address <span class="token punctuation">{</span>
	<span class="token keyword">return</span> self<span class="token punctuation">.</span>Worker
<span class="token punctuation">}</span>
</code></pre></section><section id="sec-GetPower" secid="12.5.13"><h4><span class="spec-secid" title="link to this section"><a href="#sec-GetPower">12.5.13</a></span>GetPower</h4><div class="spec-production" id="Parameters"><span class="spec-nt"><a href="#Parameters" data-name="Parameters">Parameters</a></span><div class="spec-rhs"><span class="spec-nt"><span data-name="None">None</span></span></div></div><div class="spec-production" id="Return"><span class="spec-nt"><a href="#Return" data-name="Return">Return</a></span><div class="spec-rhs"><span class="spec-nt"><span data-name="BytesAmount">BytesAmount</span></span></div></div><pre><code><span class="token keyword">func</span> <span class="token function">GetPower</span><span class="token punctuation">(</span><span class="token punctuation">)</span> BytesAmount <span class="token punctuation">{</span>
	<span class="token keyword">return</span> self<span class="token punctuation">.</span>Power
<span class="token punctuation">}</span>
</code></pre></section><section id="sec-GetKey" secid="12.5.14"><h4><span class="spec-secid" title="link to this section"><a href="#sec-GetKey">12.5.14</a></span>GetKey</h4><div class="spec-production" id="Parameters"><span class="spec-nt"><a href="#Parameters" data-name="Parameters">Parameters</a></span><div class="spec-rhs"><span class="spec-nt"><span data-name="None">None</span></span></div></div><div class="spec-production" id="Return"><span class="spec-nt"><a href="#Return" data-name="Return">Return</a></span><div class="spec-rhs"><span class="spec-nt"><span data-name="PublicKey">PublicKey</span></span></div></div><pre><code><span class="token keyword">func</span> <span class="token function">GetKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> PublicKey <span class="token punctuation">{</span>
	<span class="token keyword">return</span> self<span class="token punctuation">.</span>PublicKey
<span class="token punctuation">}</span>
</code></pre></section><section id="sec-GetPeerID" secid="12.5.15"><h4><span class="spec-secid" title="link to this section"><a href="#sec-GetPeerID">12.5.15</a></span>GetPeerID</h4><div class="spec-production" id="Parameters"><span class="spec-nt"><a href="#Parameters" data-name="Parameters">Parameters</a></span><div class="spec-rhs"><span class="spec-nt"><span data-name="None">None</span></span></div></div><div class="spec-production" id="Return"><span class="spec-nt"><a href="#Return" data-name="Return">Return</a></span><div class="spec-rhs"><span class="spec-nt"><span data-name="PeerID">PeerID</span></span></div></div><pre><code><span class="token keyword">func</span> <span class="token function">GetPeerID</span><span class="token punctuation">(</span><span class="token punctuation">)</span> PeerID <span class="token punctuation">{</span>
	<span class="token keyword">return</span> self<span class="token punctuation">.</span>PeerID
<span class="token punctuation">}</span>
</code></pre></section><section id="sec-GetSectorSize" secid="12.5.16"><h4><span class="spec-secid" title="link to this section"><a href="#sec-GetSectorSize">12.5.16</a></span>GetSectorSize</h4><div class="spec-production" id="Parameters"><span class="spec-nt"><a href="#Parameters" data-name="Parameters">Parameters</a></span><div class="spec-rhs"><span class="spec-nt"><span data-name="None">None</span></span></div></div><div class="spec-production" id="Return"><span class="spec-nt"><a href="#Return" data-name="Return">Return</a></span><div class="spec-rhs"><span class="spec-nt"><span data-name="BytesAmount">BytesAmount</span></span></div></div><pre><code><span class="token keyword">func</span> <span class="token function">GetSectorSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> BytesAmount <span class="token punctuation">{</span>
	<span class="token keyword">return</span> self<span class="token punctuation">.</span>SectorSize
<span class="token punctuation">}</span>
</code></pre></section><section id="sec-UpdatePeerID" secid="12.5.17"><h4><span class="spec-secid" title="link to this section"><a href="#sec-UpdatePeerID">12.5.17</a></span>UpdatePeerID</h4><div class="spec-production" id="Parameters"><span class="spec-nt"><a href="#Parameters" data-name="Parameters">Parameters</a></span><div class="spec-rhs"><span class="spec-t">pid</span><span class="spec-nt"><span data-name="PeerID">PeerID</span></span></div></div><div class="spec-production" id="Return"><span class="spec-nt"><a href="#Return" data-name="Return">Return</a></span><div class="spec-rhs"><span class="spec-nt"><span data-name="None">None</span></span></div></div><pre><code><span class="token keyword">func</span> <span class="token function">UpdatePeerID</span><span class="token punctuation">(</span>pid PeerID<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> msg<span class="token punctuation">.</span>From <span class="token operator">!=</span> self<span class="token punctuation">.</span>Worker <span class="token punctuation">{</span>
		<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"only the mine worker may update the peer ID"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	self<span class="token punctuation">.</span>PeerID <span class="token operator">=</span> pid
<span class="token punctuation">}</span>
</code></pre></section></section><section id="sec-Payment-Channel-Broker-Actor" secid="12.6"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Payment-Channel-Broker-Actor">12.6</a></span>Payment Channel Broker Actor</h3><p>TODO</p></section><section id="sec-Multisig-Account-Actor" secid="12.7"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Multisig-Account-Actor">12.7</a></span>Multisig Account Actor</h3><p>A basic multisig account actor. Allows sending of messages like a normal account actor, but with the requirement of M of N parties agreeing to the operation. Completed and/or cancelled operations stick around in the actors state until explicitly cleared out. Proposers may cancel transactions they propose, or transactions by proposers who are no longer approved signers.</p><p>Self modification methods (add/remove signer, change requirement) are called by doing a multisig transaction invoking the desired method on the contract itself. This means the&lsquo;signature threshold&rsquo; logic only needs to be implemented once, in one place.</p><p>The <a href="#init-actor">init actor</a> is used to create new instances of the multisig.</p><section id="sec-Multisig-Account-Actor.State" secid="12.7.1"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Multisig-Account-Actor.State">12.7.1</a></span>State</h4><pre><code><span class="token keyword">type</span> Multisig <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	Signers  <span class="token punctuation">[</span><span class="token punctuation">]</span>Address
	Required <span class="token builtin">uint</span>

	NextTxID     <span class="token builtin">uint64</span>
	Transactions <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span>Transaction
<span class="token punctuation">}</span>

<span class="token keyword">type</span> Transaction <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	Created   <span class="token builtin">uint64</span>
	TxID      <span class="token builtin">uint64</span>
	To        Address
	Value     TokenAmount
	Method    <span class="token builtin">string</span>
	Params    <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span>
	Approved  <span class="token punctuation">[</span><span class="token punctuation">]</span>Address
	Completed <span class="token builtin">bool</span>
	Canceled  <span class="token builtin">bool</span>
<span class="token punctuation">}</span>
</code></pre></section><section id="sec-Multisig-Account-Actor.Code-Cid" secid="12.7.2"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Multisig-Account-Actor.Code-Cid">12.7.2</a></span>Code Cid</h4><p><code>&lt;codec:raw&gt;&lt;mhType:identity&gt;&lt;&quot;multisig&quot;&gt;</code></p><table><thead><tr><th>Index </th><th>Method Name </th></tr></thead><tbody><tr><td>0 </td><td><code>Propose</code> </td></tr><tr><td>1 </td><td><code>Approve</code> </td></tr><tr><td>2 </td><td><code>Cancel</code> </td></tr><tr><td>3 </td><td><code>ClearCompleted</code> </td></tr><tr><td>4 </td><td><code>AddSigner</code> </td></tr><tr><td>5 </td><td><code>RemoveSigner</code> </td></tr><tr><td>6 </td><td><code>SwapSigner</code> </td></tr><tr><td>7 </td><td><code>ChangeRequirement</code> </td></tr></tbody></table><section id="sec-Multisig-Account-Actor.Code-Cid.Constructor" secid="12.7.2.1"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Multisig-Account-Actor.Code-Cid.Constructor">12.7.2.1</a></span>Constructor</h5><p>&gt; This method sets up the initial state for the multisig account</p></section><section id="sec-Multisig-Account-Actor.Code-Cid.Parameters" secid="12.7.2.2"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Multisig-Account-Actor.Code-Cid.Parameters">12.7.2.2</a></span>Parameters</h5><table><thead><tr><th>Name </th><th>Type </th><th>Description </th></tr></thead><tbody><tr><td><code>signers</code> </td><td><code>[]Address</code> </td><td>The addresses that will be the signatories of this wallet. </td></tr><tr><td><code>required</code> </td><td><code>uint</code> </td><td>The number of signatories required to perform a transaction. </td></tr></tbody></table><pre><code><span class="token keyword">func</span> <span class="token function">Multisig</span><span class="token punctuation">(</span>signers <span class="token punctuation">[</span><span class="token punctuation">]</span>Address<span class="token punctuation">,</span> required <span class="token builtin">uint</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	self<span class="token punctuation">.</span>Signers <span class="token operator">=</span> signers
	self<span class="token punctuation">.</span>Required <span class="token operator">=</span> required
<span class="token punctuation">}</span>
</code></pre></section></section><section id="sec-Propose" secid="12.7.3"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Propose">12.7.3</a></span>Propose</h4><p>&gt; Propose is used to propose a new transaction to be sent by this multisig. The proposer must be a signer, and the proposal also serves as implicit approval from the proposer. If only a single signature is required, then the transaction is executed immediately.</p><table><thead><tr><th>Name </th><th>Type </th><th>Description </th></tr></thead><tbody><tr><td><code>to</code> </td><td><code>Address</code> </td><td>The address of the target of the proposed transaction. </td></tr><tr><td><code>value</code> </td><td><code>TokenAmount</code> </td><td>The amount of funds to send with the proposed transaction </td></tr><tr><td><code>method</code> </td><td><code>string</code> </td><td>The method that will be invoked on the proposed transactions target. </td></tr><tr><td><code>params</code> </td><td><code>[]byte</code> </td><td>The parameters that will be passed to the method invocation on the proposed transactions target. </td></tr></tbody></table><pre><code><span class="token keyword">func</span> <span class="token function">Propose</span><span class="token punctuation">(</span>to Address<span class="token punctuation">,</span> value TokenAmount<span class="token punctuation">,</span> method <span class="token builtin">string</span><span class="token punctuation">,</span> params <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token builtin">uint64</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">isSigner</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>From<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"not authorized"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	txid <span class="token operator">:=</span> self<span class="token punctuation">.</span>NextTxID
	self<span class="token punctuation">.</span>NextTxID<span class="token operator">++</span>

	tx <span class="token operator">:=</span> Transaction<span class="token punctuation">{</span>
		TxID<span class="token punctuation">:</span>     txid<span class="token punctuation">,</span>
		To<span class="token punctuation">:</span>       to<span class="token punctuation">,</span>
		Value<span class="token punctuation">:</span>    value<span class="token punctuation">,</span>
		Method<span class="token punctuation">:</span>   method<span class="token punctuation">,</span>
		Params<span class="token punctuation">:</span>   params<span class="token punctuation">,</span>
		Approved<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>Address<span class="token punctuation">{</span>msg<span class="token punctuation">.</span>From<span class="token punctuation">}</span><span class="token punctuation">,</span>
	<span class="token punctuation">}</span>

	self<span class="token punctuation">.</span>Transactions<span class="token punctuation">.</span><span class="token function">Append</span><span class="token punctuation">(</span>tx<span class="token punctuation">)</span>

	<span class="token keyword">if</span> self<span class="token punctuation">.</span>Required <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">{</span>
		vm<span class="token punctuation">.</span><span class="token function">Send</span><span class="token punctuation">(</span>tx<span class="token punctuation">.</span>To<span class="token punctuation">,</span> tx<span class="token punctuation">.</span>Value<span class="token punctuation">,</span> tx<span class="token punctuation">.</span>Method<span class="token punctuation">,</span> tx<span class="token punctuation">.</span>Params<span class="token punctuation">)</span>
		tx<span class="token punctuation">.</span>Complete <span class="token operator">=</span> <span class="token boolean">true</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">return</span> txid
<span class="token punctuation">}</span>
</code></pre></section><section id="sec-Approve" secid="12.7.4"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Approve">12.7.4</a></span>Approve</h4><p>&gt; Approve is called by a signer to approve a given transaction. If their approval pushes the approvals for this transaction over the threshold, the transaction is executed.</p><table><thead><tr><th>Name </th><th>Type </th><th>Description </th></tr></thead><tbody><tr><td><code>txid</code> </td><td><code>uint64</code> </td><td>The ID of the transaction to approve. </td></tr></tbody></table><pre><code><span class="token keyword">func</span> <span class="token function">Approve</span><span class="token punctuation">(</span>txid <span class="token builtin">uint64</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> <span class="token operator">!</span>self<span class="token punctuation">.</span><span class="token function">isSigner</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>From<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"not authorized"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	tx <span class="token operator">:=</span> self<span class="token punctuation">.</span><span class="token function">getTransaction</span><span class="token punctuation">(</span>txid<span class="token punctuation">)</span>
	<span class="token keyword">if</span> tx<span class="token punctuation">.</span>Complete <span class="token punctuation">{</span>
		<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"transaction already completed"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">if</span> tx<span class="token punctuation">.</span>Canceled <span class="token punctuation">{</span>
		<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"transaction canceled"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> signer <span class="token operator">:=</span> <span class="token keyword">range</span> tx<span class="token punctuation">.</span>Approved <span class="token punctuation">{</span>
		<span class="token keyword">if</span> signer <span class="token operator">==</span> msg<span class="token punctuation">.</span>From <span class="token punctuation">{</span>
			<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"already signed this message"</span><span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	tx<span class="token punctuation">.</span>Approved<span class="token punctuation">.</span><span class="token function">Append</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>From<span class="token punctuation">)</span>

	<span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>tx<span class="token punctuation">.</span>Approved<span class="token punctuation">)</span> <span class="token operator">>=</span> self<span class="token punctuation">.</span>Required <span class="token punctuation">{</span>
		<span class="token function">Send</span><span class="token punctuation">(</span>tx<span class="token punctuation">.</span>To<span class="token punctuation">,</span> tx<span class="token punctuation">.</span>Value<span class="token punctuation">,</span> tx<span class="token punctuation">.</span>Method<span class="token punctuation">,</span> tx<span class="token punctuation">.</span>Params<span class="token punctuation">)</span>
		tx<span class="token punctuation">.</span>Complete <span class="token operator">=</span> <span class="token boolean">true</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></section><section id="sec-Cancel" secid="12.7.5"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Cancel">12.7.5</a></span>Cancel</h4><pre><code><span class="token keyword">func</span> <span class="token function">Cancel</span><span class="token punctuation">(</span>txid <span class="token builtin">uint64</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> <span class="token operator">!</span>self<span class="token punctuation">.</span><span class="token function">isSigner</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>From<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"not authorized"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	tx <span class="token operator">:=</span> self<span class="token punctuation">.</span><span class="token function">getTransaction</span><span class="token punctuation">(</span>txid<span class="token punctuation">)</span>
	<span class="token keyword">if</span> tx<span class="token punctuation">.</span>Complete <span class="token punctuation">{</span>
		<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"cannot cancel completed transaction"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">if</span> tx<span class="token punctuation">.</span>Canceled <span class="token punctuation">{</span>
		<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"transaction already canceled"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	proposer <span class="token operator">:=</span> tx<span class="token punctuation">.</span>Approved<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
	<span class="token keyword">if</span> proposer <span class="token operator">!=</span> msg<span class="token punctuation">.</span>From <span class="token operator">&amp;&amp;</span> <span class="token function">isSigner</span><span class="token punctuation">(</span>proposer<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"cannot cancel another signers transaction"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	tx<span class="token punctuation">.</span>Canceled <span class="token operator">=</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span>
</code></pre></section><section id="sec-ClearCompleted" secid="12.7.6"><h4><span class="spec-secid" title="link to this section"><a href="#sec-ClearCompleted">12.7.6</a></span>ClearCompleted</h4><pre><code><span class="token keyword">func</span> <span class="token function">ClearCompleted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> <span class="token operator">!</span>self<span class="token punctuation">.</span><span class="token function">isSigner</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>From<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"not authorized"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">for</span> tx <span class="token operator">:=</span> <span class="token keyword">range</span> self<span class="token punctuation">.</span>Transactions <span class="token punctuation">{</span>
		<span class="token keyword">if</span> tx<span class="token punctuation">.</span>Completed <span class="token operator">||</span> tx<span class="token punctuation">.</span>Canceled <span class="token punctuation">{</span>
			self<span class="token punctuation">.</span>Transactions<span class="token punctuation">.</span><span class="token function">Remove</span><span class="token punctuation">(</span>tx<span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></section><section id="sec-AddSigner" secid="12.7.7"><h4><span class="spec-secid" title="link to this section"><a href="#sec-AddSigner">12.7.7</a></span>AddSigner</h4><pre><code><span class="token keyword">func</span> <span class="token function">AddSigner</span><span class="token punctuation">(</span>signer Address<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> msg<span class="token punctuation">.</span>From <span class="token operator">!=</span> self<span class="token punctuation">.</span>Address <span class="token punctuation">{</span>
		<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"add signer must be called by wallet itself"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">if</span> self<span class="token punctuation">.</span><span class="token function">isSigner</span><span class="token punctuation">(</span>signer<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"new address is already a signer"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	self<span class="token punctuation">.</span>Signers<span class="token punctuation">.</span><span class="token function">Append</span><span class="token punctuation">(</span>signer<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></section><section id="sec-RemoveSigner" secid="12.7.8"><h4><span class="spec-secid" title="link to this section"><a href="#sec-RemoveSigner">12.7.8</a></span>RemoveSigner</h4><pre><code><span class="token keyword">func</span> <span class="token function">RemoveSigner</span><span class="token punctuation">(</span>signer Address<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> msg<span class="token punctuation">.</span>From <span class="token operator">!=</span> self<span class="token punctuation">.</span>Address <span class="token punctuation">{</span>
		<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"remove signer must be called by wallet itself"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">if</span> <span class="token operator">!</span>self<span class="token punctuation">.</span><span class="token function">isSigner</span><span class="token punctuation">(</span>signer<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"given address was not a signer"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	self<span class="token punctuation">.</span>Signers<span class="token punctuation">.</span><span class="token function">Remove</span><span class="token punctuation">(</span>signer<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></section><section id="sec-SwapSigner" secid="12.7.9"><h4><span class="spec-secid" title="link to this section"><a href="#sec-SwapSigner">12.7.9</a></span>SwapSigner</h4><pre><code><span class="token keyword">func</span> <span class="token function">SwapSigner</span><span class="token punctuation">(</span>old<span class="token punctuation">,</span> <span class="token builtin">new</span> Address<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> msg<span class="token punctuation">.</span>From <span class="token operator">!=</span> self<span class="token punctuation">.</span>Address <span class="token punctuation">{</span>
		<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"swap signer must be called by wallet itself"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">if</span> <span class="token operator">!</span>self<span class="token punctuation">.</span><span class="token function">isSigner</span><span class="token punctuation">(</span>old<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"given old address was not a signer"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">if</span> self<span class="token punctuation">.</span><span class="token function">isSigner</span><span class="token punctuation">(</span><span class="token builtin">new</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"given new address was already a signer"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	self<span class="token punctuation">.</span>Signers<span class="token punctuation">.</span><span class="token function">Remove</span><span class="token punctuation">(</span>old<span class="token punctuation">)</span>
	self<span class="token punctuation">.</span>Signers<span class="token punctuation">.</span><span class="token function">Append</span><span class="token punctuation">(</span><span class="token builtin">new</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></section><section id="sec-ChangeRequirement" secid="12.7.10"><h4><span class="spec-secid" title="link to this section"><a href="#sec-ChangeRequirement">12.7.10</a></span>ChangeRequirement</h4><pre><code><span class="token keyword">func</span> <span class="token function">ChangeRequirement</span><span class="token punctuation">(</span>req <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> msg<span class="token punctuation">.</span>From <span class="token operator">!=</span> self<span class="token punctuation">.</span>Address <span class="token punctuation">{</span>
		<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"change requirement must be called by wallet itself"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">if</span> req <span class="token operator">&lt;</span> <span class="token number">1</span> <span class="token punctuation">{</span>
		<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"requirement must be at least 1"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	self<span class="token punctuation">.</span>Required <span class="token operator">=</span> req
<span class="token punctuation">}</span>
</code></pre></section><section id="sec-Helper-Methods" secid="12.7.11"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Helper-Methods">12.7.11</a></span>Helper Methods</h4><p>The various helper methods called above are defined here.</p><pre><code><span class="token keyword">func</span> <span class="token function">isSigner</span><span class="token punctuation">(</span>a Address<span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">{</span>
	<span class="token keyword">for</span> signer <span class="token operator">:=</span> <span class="token keyword">range</span> self<span class="token punctuation">.</span>Signers <span class="token punctuation">{</span>
		<span class="token keyword">if</span> a <span class="token operator">==</span> signer <span class="token punctuation">{</span>
			<span class="token keyword">return</span> <span class="token boolean">true</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token boolean">false</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">getTransaction</span><span class="token punctuation">(</span>txid <span class="token builtin">int</span><span class="token punctuation">)</span> Transaction <span class="token punctuation">{</span>
	tx<span class="token punctuation">,</span> ok <span class="token operator">:=</span> self<span class="token punctuation">.</span>Transactions<span class="token punctuation">[</span>txid<span class="token punctuation">]</span>
	<span class="token keyword">if</span> <span class="token operator">!</span>ok <span class="token punctuation">{</span>
		<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"no such transaction"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">return</span> tx
<span class="token punctuation">}</span>
</code></pre></section></section></section><section id="sec-undefined.Faults" secid="13"><h2><span class="spec-secid" title="link to this section"><a href="#sec-undefined.Faults">13</a></span>Faults</h2><p>A fault is what happens when partcipants in the protocol are behaving incorrectly and that behavior needs to be punished. There are a number of possible faults in the Filecoin protocol, their details are all recorded below.</p><section id="sec-Fault-List" secid="13.1"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Fault-List">13.1</a></span>Fault List</h3><section id="sec-Consensus-Faults" secid="13.1.1"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Consensus-Faults">13.1.1</a></span>Consensus Faults</h4><ul><li><strong>Duplicate Block Submission Slashing:</strong><ul><li><strong>Condition:</strong> If any miner posts two blocks satisfying the slashing conditions defined in <a href="./expected-consensus.md">Expected Consensus</a>.</li><li><strong>Reporting:</strong> Anyone may call <code>SlashConsensusFault</code> and pass in the two offending block headers.</li><li><strong>Check:</strong> The chain checks that both blocks are valid, correctly signed by the same miner, and satisfy the consensus slashing conditions.</li><li><strong>Penalization:</strong> All of the miner&rsquo;s pledge collateral and all of their power is irrevocably slashed.</li></ul></li></ul></section><section id="sec-Market-Faults" secid="13.1.2"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Market-Faults">13.1.2</a></span>Market Faults</h4><ul><li><strong>Late submission penalty:</strong> <ul><li><strong>Condition</strong>: If the miner posts their PoSt after the proving period ends, but before the generation attack threshold.</li><li><strong>Reporting:</strong> The miner submits their PoSt as usual, but includes the late submission fee.</li><li><strong>Check:</strong> The chain checks first that the submission is within the <code>generation attack threshold</code>, and then checks that the fee provided matches the required fee for how many blocks late the submission is.</li><li><strong>Penalization:</strong> The miner is penalized proportionally to the delay. Penalizations are enforced by a standard PoSt submission.<ul><li><em>Economic penalization</em>: To determine the penalty amount, <code>CalculateLatePenalty(numLate)</code> is called. The miners power is not reduced after the fee submission.</li><li><em>Power penalization</em>: The miners&rsquo; power is not reduced. Note that the current view of the power table is computed with the lookback parameter.<ul><li><em>Why are we accounting the power table with a lookback parameter ?</em> If we do not use the lookback parameter then, we need to penalize late miners for the duration that they are late. This is tricky to do efficiently. For xample, if miners A, B and C each have 1/3 of the networks power, and C is late in submitting their proofs, then for that duration, A and B should each have effectively half of the networks power (and a 50% chance each of winning the block).</li></ul></li></ul></li><li>TODO: write on the spec exact parameters for PoSt Deadline and Gen Attack threshold</li></ul></li><li><strong>Unreported storage fault slashing:</strong><ul><li><strong>Condition:</strong> If the miner does not submit their PoSt by the <code>generation attack threshold</code>. </li><li><strong>Reporting:</strong> The miner can be slashed by anyone else in the network who calls <code>SlashStorageFaults</code>. We expect miners to report these faults.<ul><li>Future design note: moving forward, we should either compensate the caller, or require this</li><li>Note: we could <em>require</em> the method be called, as part of the consensus rules (this gets complicated though). In this case, there is a DoS attack where if I make a large number of miners each with a single sector, and fail them all at the same time, the next block miner will be forced to do a very large amount of work. This would either need an extended&lsquo;gas limit&rsquo;, or some other method to avoid too long validation times.</li></ul></li><li><strong>Check:</strong> The chain checks that the miners last PoSt submission was before the start of their current proving period, and that the current block is after the generation attack threshold for their current proving period.</li><li><strong>Penalization:</strong> Penalizations are enforced by <code>SlashStorageFault</code> on the <code>storage market</code> actor.<ul><li><em>Economic Penalization</em>: Miner loses all collateral.</li><li><em>Power Penalization</em>: Miner loses all power. </li><li>Note: If a miner is in this state, where they have failed to submit a PoST, any block they attempt to mine will be invalid, even if the election function selects them. (the election function should probably be made to never select them)</li><li>Future design note: There is a way to tolerate Internet connection faults. A miner runs an Emergency PoSt which does not take challenges from the chain, if the miner gets reconnected before the VDF attack time (based on Amax), then, they can submit the Emergency PoSt and get pay a late penalization fee.</li></ul></li></ul></li><li><strong>Reported storage fault penalty:</strong> <ul><li><strong>Condition:</strong> The miner submits their PoSt with a non&#8208;empty set of&lsquo;missing sectors&rsquo;.</li><li><strong>Reporting:</strong> The miner can specify some sectors that they failed to prove during the proving period.<ul><li>Note: These faults are output by the <code>ProveStorage</code> routine, and are posted on&#8208;chain when posting the proof. This occurs when the miner (for example) has a disk failure, or other local data corruption.</li></ul></li><li><strong>Check:</strong> The chain checks that the proof verifies with the missing sectors.</li><li><strong>Penalization:</strong> The miner is penalized for collateral and power proportional to the number of missing sectors. The sectors are also removed from the miners proving set.<ul><li>TODO: should the collateral lost here be proportional to the remaining time?</li><li>TODO(nicola): check if the time between posting two proofs allows for a generation attack if it does not then we might reconsider the sector not being lost</li></ul></li><li>Note: if a sector is missed here, and they are recovered after the fact, the miner could simple&lsquo;re&#8208;commit&rsquo; the sector. They still have to pay the collateral, but the data can be quickly re&#8208;introduced into the system to avoid clients calling them out for breach of contract (this would only work because the sector commD/commR is the same)</li><li>Note: In the case where a miner is temporarily unable to prove some of their data, they can simply wait for the temporary unavailability to recover, and then continue proving, submitting the proofs a bit late if necessary (paying appropriate fees, as described above).</li></ul></li><li><strong>Breach of contract dispute:</strong></li><li><strong>Condition:</strong> A client who has stored data with a miner, and the miner removes the sector containing that data before the end of the agreed upon time period.</li><li><strong>Reporting:</strong> The client invokes <code>ArbitrateDeal</code> on the offending miner actor with a signed deal from that miner for the storage in question. Note: the reporting must happen within one proving period of the miner removing the storage erroneously.</li><li><strong>Check:</strong> The chain checks that the deal was correctly signed by the miner in question, that the deal has not yet expired, and that the sector referenced by the deal is no longer in the miners proving set.</li><li><strong>Penalization:</strong> The miner is penalized an amount proportional to the incorrectly removed sector. This penalty is taken from their pledged collateral .</li><li>Note: This implies that miners cannot re&#8208;seal data into different sectors. We could come up with a protocol where the client gives the miner explicit consent to re&#8208;seal, but that is more complicated and can be done later. </li></ul></section></section></section><section id="sec-Signatures" secid="14"><h2><span class="spec-secid" title="link to this section"><a href="#sec-Signatures">14</a></span>Signatures</h2><section id="sec-What-are-signatures-in-Filecoin" secid="14.1"><h3><span class="spec-secid" title="link to this section"><a href="#sec-What-are-signatures-in-Filecoin">14.1</a></span>What are signatures in Filecoin</h3><p>Signatures are cryptographic functions that attest to the origin of a particular message. In the context of Filecoin, signatures are used to send and receive messages among with the assurance that each message was generated by specific individuals. In other words, it is infeasible for another individual i to generate a signed message that appears to have been generated by j.</p><p>We use signatures in filecoin to verify <em>something</em> was done by <em>someone</em>. For example, we use signatures in order to validate deal messages which represent an action like a storage deals We also use signatures to determine who generated a particular message, determine public keys&mdash;which can be recovered from signed data and a signature, and find filecoin addresses which generated from a public key.</p><ul><li>Messages (From actors to the blockchain)</li><li>Tickets (Signature of proof - <a href="mining.md">Mining</a></li><li>Block signature (Signature over all data in the block &ndash; done by block leader)</li></ul></section><section id="sec-What-signatures-affect" secid="14.2"><h3><span class="spec-secid" title="link to this section"><a href="#sec-What-signatures-affect">14.2</a></span>What signatures affect</h3><p>What uses them</p><ul><li>Messages [TODO: Link to messages spec]</li><li>Block validation</li><li>Tickets which inform leader election in Expected Consensus (EC) [TODO: link to EC spec]</li></ul><div class="spec-note">that messages between actors are not signed this is because messages between actors are always spawned by a message from a user -- which are singed by that user.</div><p>Filecoin specific reliance</p><ul><li>SignedMessages in go&#8208;filecoin</li></ul></section><section id="sec-Signatures.Dependencies" secid="14.3"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Signatures.Dependencies">14.3</a></span>Dependencies</h3><p>Things that affect our choices for signatures</p><ul><li>Elliptic curve choices &ndash; We use ECDSA with secp256k1 (aka the BitCoin elliptic curve)</li><li>Signature size limits &ndash; Our signatures are 64 bytes + 1 byte for public key recovery</li><li>Avg. processing power available to a CPU (signature aggregation)</li></ul><p>Filecoin specific dependancies</p><ul><li>libsecp256k1</li></ul></section><section id="sec-Non-Dependencies" secid="14.4"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Non-Dependencies">14.4</a></span>Non-Dependencies</h3><p>Does not affect</p><ul><li>Transport encryption</li><li>File encodings (PoRep)</li></ul></section><section id="sec-Signatures.Interface" secid="14.5"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Signatures.Interface">14.5</a></span>Interface</h3><p>Filecoin requires a system that fulfils the following interface to function correctly.</p><div class="spec-note"><code>Message</code> is used here as the object being signed, but this interface should also work for other things that need to be signed.</div><pre><code><span class="token keyword">type</span> Signature <span class="token keyword">interface</span> <span class="token punctuation">{</span>

	<span class="token comment" spellcheck="true">// Sign generates a proof that miner `M` generate message `m`</span>
	<span class="token comment" spellcheck="true">//</span>
	<span class="token comment" spellcheck="true">// Out:</span>
	<span class="token comment" spellcheck="true">//    sig - a series of bytes representing a signature usually `r`|`s`</span>
	<span class="token comment" spellcheck="true">//    err - a standard error message indicating any process issues</span>
	<span class="token comment" spellcheck="true">// In:</span>
	<span class="token comment" spellcheck="true">//    m - a series of bytes representing a message to be signed</span>
	<span class="token comment" spellcheck="true">//    sk - a private key which cryptographically links `M` to `sig`</span>
	<span class="token comment" spellcheck="true">//</span>
	<span class="token function">Sign</span><span class="token punctuation">(</span>m Message<span class="token punctuation">,</span> sk PrivateKey<span class="token punctuation">)</span> <span class="token punctuation">(</span>sig SignatureBytes<span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span>

	<span class="token comment" spellcheck="true">// Verify validates the statement: only `M` could have generated `sig`</span>
	<span class="token comment" spellcheck="true">// given the validator has a message `m`, a signature `sig`, and a</span>
	<span class="token comment" spellcheck="true">// public key `pk`.</span>
	<span class="token comment" spellcheck="true">//</span>
	<span class="token comment" spellcheck="true">// Out:</span>
	<span class="token comment" spellcheck="true">//    valid - a boolean value indicating the signature is valid</span>
	<span class="token comment" spellcheck="true">//    err - a standard error message indicating any process issues</span>
	<span class="token comment" spellcheck="true">// In:</span>
	<span class="token comment" spellcheck="true">//    m - a series of bytes representing the signed message</span>
	<span class="token comment" spellcheck="true">//    pk - the public key belonging to the signer `M`</span>
	<span class="token comment" spellcheck="true">//    sig - a series of bytes representing a signature usually `r`|`s`</span>
	<span class="token comment" spellcheck="true">//</span>
	<span class="token function">Verify</span><span class="token punctuation">(</span>m Messgage<span class="token punctuation">,</span> pk PublicKey<span class="token punctuation">,</span> sig SignatureBytes<span class="token punctuation">)</span> <span class="token punctuation">(</span>valid <span class="token builtin">bool</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span>

	<span class="token comment" spellcheck="true">// Recover, as its name implies, recovers a public key associated with a</span>
	<span class="token comment" spellcheck="true">// particular signature. In the case of ECDSA signatures, this function can</span>
	<span class="token comment" spellcheck="true">// be fulfilled via the 'ECRecover' method. If a different signature scheme</span>
	<span class="token comment" spellcheck="true">// is used, then some other mechanism of 'recovering' a message authors</span>
	<span class="token comment" spellcheck="true">// public key must be provided.</span>
	<span class="token comment" spellcheck="true">//</span>
	<span class="token comment" spellcheck="true">// Out:</span>
	<span class="token comment" spellcheck="true">//    pk - the public key associated with `M` who signed `m`</span>
	<span class="token comment" spellcheck="true">//    err - a standard error message indicating any process issues</span>
	<span class="token comment" spellcheck="true">//    **</span>
	<span class="token comment" spellcheck="true">// In:</span>
	<span class="token comment" spellcheck="true">//    m - a series of bytes representing the signed message</span>
	<span class="token comment" spellcheck="true">//    sig - a series of bytes representing a signature usually `r`|`s`</span>
	<span class="token comment" spellcheck="true">//</span>
	<span class="token function">Recover</span><span class="token punctuation">(</span>m Message<span class="token punctuation">,</span> sig SignatureBytes<span class="token punctuation">)</span> <span class="token punctuation">(</span>pk PublicKey<span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></section><section id="sec-Selected-Signature-Scheme" secid="14.6"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Selected-Signature-Scheme">14.6</a></span>Selected Signature Scheme</h3><p>Currently, Filecoin uses secp256k1 signatures to fulfill the above interface. All signatures on messages, blocks, and tickets currently use the same scheme and format.</p><section id="sec-Wire-Format" secid="14.6.1"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Wire-Format">14.6.1</a></span>Wire Format</h4><p>What bits are on the wire and in what order/format. We are currently adhering to libsecp256k1 serialization which is laid out as follows. Note that this format description may not be accurate. See the github link below for an authoritative format description.</p><p><strong>Signature</strong></p><pre><code>sig SignatureBytes = [0x30][len][0x02][r][indicator][s][indicator][recovery]
</code></pre><p><code>s</code> = Scalar of size 32 bytes</p><p><code>r</code> = Compressed elliptic curve point (x&#8208;coordinate) of size 32 bytes</p><p><code>recovery</code> = Information needed to recover a public key from <code>sig</code>.</p><ul><li>LSB(0) = parity of y&#8208;coordinate of r</li><li>LSB(1) = overflow indicator</li></ul><p><code>indicator</code> = a 2 byte formatting indicator</p><div class="spec-production" id="From"><span class="spec-nt"><a href="#From" data-name="From">From</a></span><div class="spec-rhs"><span class="spec-t">&lt;https://github.com/bitcoin-core/secp256k1/blob/314a61d72474aa29ff4afba8472553ad91d88e9d/src/ecdsa_impl.h#L177&gt;</span></div></div><p><strong>Signed Message</strong></p><pre><code>Type SignedMessage Struct {

    Message bytes `JSON`   

    Signature bytes `JSON`

}
</code></pre><p><a href="https://github.com/filecoin-project/go-filecoin/blob/ab60f73af1f86a954ef41e3252ef52a99066bbe2/types/signed_message.go#L25">Current Filecoin Implementation</a></p></section><section id="sec-Github" secid="14.6.2"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Github">14.6.2</a></span>Github</h4><p><https://github.com/filecoin-project/specs/issues/131></p></section><section id="sec-External-References" secid="14.6.3"><h4><span class="spec-secid" title="link to this section"><a href="#sec-External-References">14.6.3</a></span>External References</h4><ul><li>How Recovering a Private Key from a message and a signature works in ethereum:</li><li>- <https://medium.com/@libertylocked/ec-signatures-and-recovery-in-ethereum-smart-contracts-560b6dd8876></li><li>More notes on recovery</li><li>- <a href="https://crypto.stackexchange.com/questions/18105/how-does-recovering-the-public-key-from-an-ecdsa-signature-work/18106#18106">https://crypto.stackexchan ge.com/questions/18105/how&#8208;does&#8208;recovering&#8208;the&#8208;public&#8208;key&#8208;from&#8208;an&#8208;ecdsa&#8208;signature&#8208;work/18106#18106</a></li><li>See &ldquo;4.1.6 Public Key Recovery Operation Page 47&rdquo;</li><li>- <http://www.secg.org/sec1-v2.pdf></li><li>Secp256k1 Signature serialization -</li><li>- Secp256k1 cpp - <https://github.com/ethereum/ethash/blob/f5f0a8b1962544d2b6f40df8e4b0d9a32faf8f8e/vendor/github.com/ethereum/go-ethereum/crypto/secp256k1/libsecp256k1/include/secp256k1_recovery.h#L55><ul><li>Go&#8208;filecoin - <https://github.com/filecoin-project/go-filecoin/blob/e95bde8ff289b0c88d748e92b1bcca99ecc403cb/crypto/secp256k1/secp256.go#L98></li></ul></li></ul></section><section id="sec-References" secid="14.6.4"><h4><span class="spec-secid" title="link to this section"><a href="#sec-References">14.6.4</a></span>References</h4><div class="spec-todo">this section should likely be removed, and the context it adds should be linked in some other way.</div><ul><li>Maybe Marshal/Unmarshal == NewSignedMessage/SignBytes? <ul><li><https://github.com/filecoin-project/go-filecoin/blob/master/types/signed_message.go></li><li><https://github.com/filecoin-project/go-filecoin/blob/master/types/signer.go></li></ul></li><li>Message serialization currently: http://cbor.io</li><li>Recover &ndash; Extract a PublicKey from SignatureBytes (Trade storage of PublicKey (pk) for CPU work to recover pk from a signature -- assumes signature bits are enough to recover pk which might not be the case for all signature algorithms). For full explanation of recover see: <http://www.secg.org/sec1-v2.pdf></li><li>Point compression Go - <https://github.com/btcsuite/btcd/blob/86fed781132ac890ee03e906e4ecd5d6fa180c64/btcec/signature.go#L338></li><li>Create recoverable sig - <https://github.com/ipsn/go-secp256k1/blob/9d62b9f0bc52d16160f79bfb84b2bbf0f6276b03/libsecp256k1/include/secp256k1_recovery.h#L70></li><li>Recid - <https://github.com/bitcoin-core/secp256k1/blob/314a61d72474aa29ff4afba8472553ad91d88e9d/src/ecdsa_impl.h#L288></li><li>Serialize - <https://github.com/bitcoin-core/secp256k1/blob/314a61d72474aa29ff4afba8472553ad91d88e9d/src/ecdsa_impl.h#L177></li><li>Should elliptic curve points always be compressed in Marshal?</li><li>Recover is math trick trading CPU for space to generate sk*G</li><li>Serialization should account for :</li><li>- Should there be point compression?<ul><li>Point compression (x,y); len(x) = n bits &rarr; x, recovery_bit; len(x||r_bit) = n+1 bits</li><li>- Easy to check add; use (mod2) or check last bit</li><li>Sig = (r,s) &ndash; s is standard but r could be (rx,ry) or rx or r all of these can be used to generate r*G</li><li>Recovery() can be used for (1) finding r<em>G from (r,s) and (2) pk = sk</em>G from SignatureBytes</li><li>Remember that y = sqrt(curve equation for x) and there are 2 valid solutions for y. This should be accounted for in sig if point compression is used (i.e. if a PublicKey is provided (no compression) or recovered (compression) OR r is a point (no compression) or scalar(compression))</li></ul></li></ul><p>Currently signatures are not sent over the wire on their own, instead they are encapsulated in in a <a href="https://github.com/filecoin-project/go-filecoin/blob/master/types/signed_message.go#L22-L28">SignedMessage</a>. SignesMessage&rsquo;s contain a Message and a Signature. When we want to send a SignedMessage over the wire we marshal it to cbor and send, once it is recevied it is unmarshaled form <a href="http://cbor.io/">cbor</a> back into the SignedMessage Structure. <a href="https://github.com/filecoin-project/go-filecoin/blob/master/types/signed_message.go#L22-L38">Code for marshaling and unmarshaling SignedMessages</a>For opinions talks to @dig &amp; @phritz</p></section><section id="sec-Inspiration" secid="14.6.5"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Inspiration">14.6.5</a></span>Inspiration</h4><p>JSON Web Sigs/Keys: <https://tools.ietf.org/html/rfc7515></p><p>NIST Signature Standard: <https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf></p><p>Discussion on slack: <https://protocollabs.slack.com/archives/G7XUR2TU2/p1528984460000977> </p></section></section></section><section id="sec-Filecoin-Proofs" secid="15"><h2><span class="spec-secid" title="link to this section"><a href="#sec-Filecoin-Proofs">15</a></span>Filecoin Proofs</h2><p>The Filecoin protocol requires a means of generating and verifying the following cryptographic proofs:</p><ul><li>__<em>Proof of Replication</em>__ proves that a unique copy of a given __<em>sector</em>__ has been created. The <code>Seal</code> operation creates this unique copy and generates a corresponding __<em>Proof of Replication</em>__.</li><li>__<em>Proof of Space&#8208;Time</em>__ proves that an arbitrary number of __<em>sealed sectors</em>__ existed over a specified period of time in their own dedicated storage &mdash; as opposed to being generated on&#8208;the&#8208;fly at proof time.</li><li>__<em>Piece Inclusion Proof</em>__ proves that a given __<em>piece</em>__ is contained within a specified __<em>sealed sector</em>__.</li><li>__<em>Proof of Retrievability</em>__ is a merkle proof that a given challenged leaf is present in an extant __<em>sealed sector</em>__.</li></ul><p>Throughout this document, the following definitions are used:</p><ul><li>__<em>sector:</em>__ a fixed&#8208;size block of data of <code>SECTOR_SIZE</code> bytes.<ul><li>__<em>piece:</em>__ a block of data of at most <code>SECTOR_SIZE</code> bytes.</li></ul></li><li>__<em>original data:</em>__ the concatenation of a __<em>sector&rsquo;s</em>__ constitutent pieces, all __<em>piece padding</em>__, and any __<em>terminal padding</em>__.</li><li>__<em>unsealed sector:</em>__ a concrete representation (on disk or in memory) of a sector&rsquo;s __<em>original data</em>__.</li><li>__<em>sealed sector:</em>__ a concrete representation (on disk or in memory) of the unique replica generated by <code>Seal</code> from an __<em>unsealed sector</em>__.</li><li>__<em>piece padding:</em>__ a block of zero or more&lsquo;zero bytes&rsquo; inserted between __<em>pieces</em>__ to ensure they are positioned within the containing __<em>sector</em>__ in a way compatible with the __<em>Piece Inclusion Proof</em>__.</li><li>__<em>terminal padding:</em>__ a block of zero or more&lsquo;zero bytes&rsquo; inserted after a __<em>sector&rsquo;s</em>__ final piece, ensuring that the length of the __<em>original data</em>__ is <code>SECTOR_BYTES</code>.</li><li>__<em>preprocessing:</em>__ a transformation applied to an __<em>unsealed sector</em>__ as the first stage of sealing and which may increase the size of the data.</li><li>__<em>preprocessed data:</em>__ the result of __<em>preprocessing</em>__ the __<em>original data</em>__.</li><li>__<em>preprocessed sector:</em>__ a concrete representation (on disk or in memory) of a __<em>sector&rsquo;s</em>__ __<em>preprocessed data</em>__.</li><li>__<em>SNARK proof:</em>__ a block of bytes which proves that the creator is in possession of a satisfying assignment to a quadratic arithmetic program (__<em>circuit</em>__).</li><li>__<em>merkle inclusion proof:</em>__ a proof (whose format is unspecified here) that a given leaf block is contained within a merkle tree whose root is the __<em>commitment</em>__ associated with the proof.</li><li>__<em>commitment:</em>__ an opaque block of data to which a prover&lsquo;commits&rsquo;, enabling subsequent proofs which cannot be validly constructed unless the __<em>commitment</em>__ itself was validly constructed. For example: the output of a suitable pseudorandom collision&#8208;resistant hash function may serve as a __<em>commitment</em>__ to the data which is the preimage of that hash. Publication of the __<em>commitment</em>__ proves that the creator was in possession of the preimage at the time the __<em>commitment</em>__ was generated.</li><li>__<em>prover:</em>__ the party who generates a proof.</li><li>__<em>verifier:</em>__ the party who verifies a proof generated by a __<em>prover</em>__.</li><li>__<em>sectors count:</em>__ the number of sectors over which a proof&#8208;of&#8208;spacetime is performed (<code>POST_SECTORS_COUNT</code>).</li></ul><section id="sec-Filecoin-Proofs.Proof-of-Replication" secid="15.1"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Filecoin-Proofs.Proof-of-Replication">15.1</a></span>Proof of Replication</h3><p>__<em>Proof of Replication</em>__ generates a unique copy (__<em>sealed sector</em>__) of a __<em>sector&rsquo;s</em>__ __<em>original data</em>__, a __<em>SNARK proof</em>__, and a set of __<em>commitments</em>__ identifying the __<em>sealed sector</em>__ and linking it to the corresponding __<em>unsealed sector</em>__.</p></section><section id="sec-Seal" secid="15.2"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Seal">15.2</a></span>Seal</h3><p><code>Seal</code> has the side effect of generating a __<em>sealed sector</em>__ from an __<em>unsealed sector</em>__, and returns identifying __<em>commitments</em>__ and a __<em>SNARK proof</em>__. The proof returned is a __<em>SNARK proofs</em>__.</p><p>The commitments are used to verify that the correct __<em>original data</em>__ was sealed, and that the correct __<em>sealed data</em>__ is the subject of later __<em>Proofs of Space&#8208;Time</em>__, proving that this data is being stored continuously.</p><p><code>Seal</code> operates by performing a slow encoding of the __<em>unsealed sector</em>__ &mdash; such that it is infeasible for a dishonest prover to computationally regenerate the __<em>sealed sector</em>__ quickly enough to satisfy subsequent required __<em>Proofs of Space&#8208;Time</em>__ &mdash; thus ensuring that the __<em>sealed sector</em>__ remains manifest as a unique, concrete representation of the __<em>original data</em>__.</p><pre><code>Seal
 (
  // request represents a request to seal a sector.
  proverID       [31]byte,    // uniquely identifies miner
  sealedAccess   string,      // identifier providing access to sealed sector-access
  sectorID       [31]byte,    // uniquely identifies sector
  storage        SectorStore, // used to manipulate sectors
  unsealedAccess string       // identifier providing access to unsealed sector-access
 ) err Error | (
  // response contains the commitments resulting from a successful Seal().
  commD          [32]byte,                       // data commitment: merkle root of original data
  commR          [32]byte,                       // replica commitment: merkle root of replicated data [will be removed in future iteration]
  commRStar      [32]byte,                       // a hash of intermediate layers
  proof          []byte,
 )

</code></pre><section id="sec-VerifySeal" secid="15.2.1"><h4><span class="spec-secid" title="link to this section"><a href="#sec-VerifySeal">15.2.1</a></span>VerifySeal</h4><p><code>VerifySeal</code> is the functional counterpart to <code>Seal</code>&lsquo;s proof component. It takes all of <code>Seal&#x27;s</code> outputs, along with those of Seal&rsquo;s inputs which are required to uniquely identify the created __<em>sealed sector</em>__. This allows a __<em>verifier</em>__ to determine whether a given proof is valid. All inputs are required because verification requires sufficient context to determine not only that a proof is <em>valid</em> but also that the proof indeed corresponds to what it purports to prove.</p><pre><code>
VerifySeal
 (
  // request represents a request to verify the output of a Seal() operation.
  commD     [32]byte,                       // returned from Seal
  commR     [32]byte,                       // returned from Seal [will be removed in future iteration]
  commRStar [32]byte,                       // returned from Seal
  proof     []byte,                         // returned from Seal
  proverID  [31]byte,                       // uniquely identifies miner
  sectorID  [31]byte,                       // uniquely identifies sector
) err Error |
  IsValid bool                              // true iff the provided proof-of-replication os valid

</code></pre></section><section id="sec-Unseal" secid="15.2.2"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Unseal">15.2.2</a></span>Unseal</h4><p><code>Unseal</code> is the counterpart to <code>Seal</code>&lsquo;s encoding side&#8208;effect. It reverses the&lsquo;slow encoding&rsquo; and creates an __<em>unsealed sector</em>__ from a __<em>sealed sector</em>__ as a special case of its more general function. In general, it allows extraction of a range of bytes (specified in terms of the layout of the __<em>original data</em>__).</p><pre><code>Unseal
 (
  // request represents a request to unseal a sector.
  numBytes      uint64,      // number of bytes to unseal (corresponds to contents of unsealed sector-file)
  outputAccess  string,      // identifier providing access to write unsealed file-bytes
  proverID      [31]byte,    // uniquely identifies miner
  sealedAccess  string,      // identifier providing access to sealed sector-file
  sectorID      [31]byte,    // uniquely identifies sector
  startOffset   uint64,      // zero-based byte offset in original, unsealed sector-file
  storage       SectorStore  // used to manipulate sectors
 ) err Error |
  NumBytesWritten uint64     // the number of bytes unsealed (and written) by Unseal()
</code></pre></section><section id="sec-Security-Notes" secid="15.2.3"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Security-Notes">15.2.3</a></span>Security Notes</h4><section id="sec-Guaranteeing-sector-uniqueness" secid="15.2.3.1"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Guaranteeing-sector-uniqueness">15.2.3.1</a></span>Guaranteeing sector uniqueness</h5><p>Every sealed sector is unique, even if the unsealed data is identical. This prevents a malicious miner from storing the same sector twice without dedicating twice the amount of storage, or two malicious miners pretending to store the same sector, but only storing one copy. Sector uniqueness is guaranteed by having unique <code>proverId</code> and <code>sectorId</code>. Each miner has a unique <code>proverID</code>, and each sector has a unique <code>sectorID</code>within that miner&rsquo;s sectors. Taken together, <code>proverID</code> and <code>sectorID</code> are globally unique . Both the <code>proverId</code> and the <code>sectorId</code> are used to encode the sealed data.</p><p>The Filecoin node verifies that the correct <code>proverId</code> and <code>sectorId</code> is used when verifying the proof.</p><p>---</p></section></section></section><section id="sec-Proof-of-Space-Time" secid="15.3"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Proof-of-Space-Time">15.3</a></span>Proof of Space-Time</h3><p>__NOTE:__ __<em>Proof of Space&#8208;Time</em>__ is in transition. Current implementations are mocked, and the final design has not been implemented. Consumers may refer to the below for reference, but nothing should be implemented until the spec is updated and synchronized with what will be the canonical construction.</p><section id="sec-GeneratePost" secid="15.3.1"><h4><span class="spec-secid" title="link to this section"><a href="#sec-GeneratePost">15.3.1</a></span>GeneratePost</h4><p><code>GeneratePoSt</code> generates a __<em>Proof of Space&#8208;Time</em>__ over <code>POST_SECTORS_COUNT</code> __<em>sealed sectors</em>__ &mdash; identified by their <code>commR</code> commitments. This is accomplished by performing a series of merkle inclusion proofs (__<em>Proofs of Retrievability</em>__). Each proof is of a challenged node in a challenged sector. The challenges are generated pseudo&#8208;randomly, based on the provided <code>challengeSeed</code>. At each time step, a number of __<em>Proofs of Retrievability</em>__ are performed. The result of each such set of __<em>Proofs of Retrievability</em>__ is used to seed challenge generation for another iteration. Repeated and necessarily sequential generation of these __<em>Proofs of Retrievability</em>__ proves that the claimed __<em>sealed sectors</em>__ existed during the time required to generate them.</p><p>Since many __<em>sealed sectors</em>__ may be proved at once, it may be the case that one or more __<em>sealed sectors</em>__ has been lost, damaged, or otherwise become impossible to validly prove. In this case, a fault is recorded and returned in an array of faults. This allows provers to selectively default on individual __<em>sealed sector</em>__ proofs while still providing a verifiable proof of their aggregate __<em>Proof of Space&#8208;Time</em>__ claims.</p><pre><code>GeneratePoSt
 (
  // request represents a request to generate a proof-of-spacetime.
  commRs         [POST_SECTORS_COUNT][32]byte,  // the commR commitments corresponding to the sealed sectors to prove
  challengeSeed  [32]byte,    // a pseudo-random value to be used in challenge generation
) err Error | (
  // response contains PoST proof and any faults that may have occurred.
  faults        []uint64,    // faults encountered while proving (by index of associated commR in the input)
  proof         []byte
)
</code></pre></section><section id="sec-VerifyPoSt" secid="15.3.2"><h4><span class="spec-secid" title="link to this section"><a href="#sec-VerifyPoSt">15.3.2</a></span>VerifyPoSt</h4><p><code>VerifyPoSt</code> is the functional counterpart to <code>GeneratePoSt</code>. It takes all of <code>GeneratePoSt</code>&lsquo;s output, along with those of <code>GeneratePost</code>&lsquo;s inputs required to identify the claimed proof. All inputs are required because verification requires sufficient context to determine not only that a proof is valid but also that the proof indeed corresponds to what it purports to prove.</p><pre><code>VerifyPoSt
 (
  // request represents a request to generate verify a proof-of-spacetime.
  commRs        [POST_SECTORS_COUNT][32]byte,        // the commRs provided to GeneratePoSt
  challengeSeed [32]byte,
  faults        []uint64
  proof         []byte,            // SNARK proof returned by GeneratePoSt
 ) err Error |
  isValid bool                     // true iff the provided Proof of Space-Time is valid
</code></pre><p>---</p></section></section><section id="sec-Filecoin-Proofs.Piece-Inclusion-Proof" secid="15.4"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Filecoin-Proofs.Piece-Inclusion-Proof">15.4</a></span>Piece Inclusion Proof</h3><section id="sec-PieceInclusionProof" secid="15.4.1"><h4><span class="spec-secid" title="link to this section"><a href="#sec-PieceInclusionProof">15.4.1</a></span>PieceInclusionProof</h4><p>A <code>PieceInclusionProof</code> contains a merkle inclusion proof for the first and last node of a piece. This ensures all&lsquo;edge&rsquo; hashes necessary to generate a complete merkle tree are available.</p><p>Depending on the position of the nodes, not every hash provided will actually be needed. As a space optimization, and at the cost of greater complexity in the encoding,&lsquo;interior&rsquo; nodes of either path may be omitted &ndash;&ndash; provided that the implementation <code>InclusionProof</code> allows for this omission.</p><pre><code>struct PieceInclusionProof {
    FirstNodeProof  InclusionProof,
    LastNodeProof   InclusionProof,
}
</code></pre></section><section id="sec-GeneratePieceInclusionProofs" secid="15.4.2"><h4><span class="spec-secid" title="link to this section"><a href="#sec-GeneratePieceInclusionProofs">15.4.2</a></span>GeneratePieceInclusionProofs</h4><p><code>GeneratePieceInclusionProofs</code> takes a merkle tree and a slice of piece lengths, and returns a vector of <code>PieceInclusionProofs</code> corresponding to the pieces. This assumes that the first piece begins at offset 0, and that each piece begins directly after the previous piece ends. For this method to work, the piece data used to validate pieces will need to be padded as necessary, and pieces will need to be aligned (to 128&#8208;byte chunks due to details of __<em>preprocessing</em>__) when written.</p><pre><code>GeneratePieceInclusionProofs
 (
  Tree MerkleTree,
  PieceLengths uint,
 ) []PieceInclusionProof
</code></pre><p><code>GeneratePieceInclusionProof</code> takes a merkle tree and the index positions of the first and last nodes of the piece whose inclusion should be proved. It returns a corresponding <code>PieceInclusionProof</code>. For the resulting proof to be valid, first_node must be &le; last_node.</p><pre><code>GeneratePieceInclusionProof
 (
  tree       MerkleTree,
  firstNode  uint,
  lastNode   uint,
 ) err Error | proof PieceInclusionProof
</code></pre><p><code>VerifyPieceInclusionProof</code> takes a merkle root and (pre&#8208;processed) piece data. Iff it returns true, then <code>PieceInclusionProof</code> indeed proves that piece&rsquo;s bytes were included in the merkle tree corresponding to root &mdash; and at the position encoded in the proof.</p><pre><code>VerifyPieceInclusionProof
 (
  proof PieceInclusionProof,
  root  [32]byte,
  piece []byte
 ) err Error | IsValid bool // true iff the provided PieceInclusionProof is valid.
</code></pre></section></section></section><section id="sec-Filecoin-Network-Protocols" secid="16"><h2><span class="spec-secid" title="link to this section"><a href="#sec-Filecoin-Network-Protocols">16</a></span>Filecoin Network Protocols</h2><div class="spec-todo">table of contents</div><p>---</p><p>All filecoin network protocols are implemented as libp2p protocols. This document will assume that all data is communicated between peers on a libp2p stream.</p><section id="sec-CBOR-RPC" secid="16.1"><h3><span class="spec-secid" title="link to this section"><a href="#sec-CBOR-RPC">16.1</a></span>CBOR RPC</h3><div class="spec-production" id="Reference"><span class="spec-nt"><a href="#Reference" data-name="Reference">Reference</a></span><div class="spec-rhs"><span class="spec-t">[RFC</span><span class="spec-t">7049</span><span class="spec-t">,</span><span class="spec-nt"><span data-name="Concise">Concise</span></span><span class="spec-nt"><span data-name="Binary">Binary</span></span><span class="spec-nt"><span data-name="Object">Object</span></span><span class="spec-nt"><span data-name="Representation">Representation</span></span><span class="spec-t">](https://tools.ietf.org/html/rfc7049)</span></div><div class="spec-rhs"><span class="spec-t">[Little</span><span class="spec-nt"><span data-name="Endian">Endian</span></span><span class="spec-nt"><span data-name="Base">Base</span></span><span class="spec-t">128</span><span class="spec-t">](https://en.wikipedia.org/wiki/LEB128)</span></div></div><p>Filecoin uses many pre&#8208;existing protocols from ipfs and libp2p, and also implements several new protocols of its own. For these Filecoin specific protocols, we will try to use a CBOR RPC protocol format. This format is effectively just a leb128 varint length delimeted series of cbor serialized objects. Whenever a filecoin protocol says &ldquo;send X&rdquo;, it means &ldquo;cbor serialize the object X, write its length encoded using unsigned leb128, then write the serialized bytes&rdquo;.</p><pre><code><span class="token keyword">func</span> <span class="token function">ReadCborRPC</span><span class="token punctuation">(</span>r io<span class="token punctuation">.</span>Reader<span class="token punctuation">,</span> out <span class="token operator">*</span>Object<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	l <span class="token operator">:=</span> <span class="token function">ReadUVarint</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span>

	<span class="token comment" spellcheck="true">// Read 'l' bytes from the reader</span>
	buf <span class="token operator">:=</span> <span class="token function">ReadCountBytes</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span> l<span class="token punctuation">)</span>

	cbor<span class="token punctuation">.</span><span class="token function">Unmarshal</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> out<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">WriteCborRPC</span><span class="token punctuation">(</span>w io<span class="token punctuation">.</span>Writer<span class="token punctuation">,</span> obj Object<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	buf <span class="token operator">:=</span> cbor<span class="token punctuation">.</span><span class="token function">Marshal</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>

	<span class="token function">WriteUVarint</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span>

	w<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></section><section id="sec-Hello-Handshake" secid="16.2"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Hello-Handshake">16.2</a></span>Hello Handshake</h3><p>The Hello protocol is used when two filecoin nodes initially connect to eachother in order to determine information about the other node. The libp2p protocol ID for this protocol is <code>/fil/hello/1.0.0</code>.</p><p>Whenever a node gets a new connection, it opens a new stream on that connection and&lsquo;says hello&rsquo;. This is done by crafting a <code>HelloMessage</code>, sending it to the other peer using CBOR RPC and finally, closing the stream.</p><pre><code><span class="token keyword">type</span> HelloMessage <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	HeaviestTipSet       <span class="token punctuation">[</span><span class="token punctuation">]</span>Cid
	HeaviestTipSetWeight <span class="token builtin">uint64</span>
	GenesisHash          Cid
<span class="token punctuation">}</span>
</code></pre><pre><code><span class="token keyword">func</span> <span class="token function">SayHello</span><span class="token punctuation">(</span>p PeerID<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	s <span class="token operator">:=</span> <span class="token function">OpenStream</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span>
	mes <span class="token operator">:=</span> <span class="token function">GetHelloMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token function">WriteCborRPC</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> mes<span class="token punctuation">)</span>
	s<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><p>Upon receiving a&lsquo;hello&rsquo; stream from another node, you should read off the CBOR RPC message, and then check that the genesis hash matches you genesis hash. If it does not, that node is not part of your network, and should probably be disconnected from. Next, the <code>HeaviestTipSet</code>, claimed <code>HeaviestTipSetWeight</code>, and peerID of the other node should be passed to the chain sync subsystem.</p></section><section id="sec-Storage-Deal" secid="16.3"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Storage-Deal">16.3</a></span>Storage Deal</h3><p>The storage deal protocol is used by any client to store data with a storage miner. The libp2p protocol ID for this protocol is <code>/fil/storage/mk/1.0.0</code>.</p><p>The protocol starts with storage client (which in this case may be a normal storage client, or a broker). It is assumed that the client has their data already prepared into a <code>piece</code> prior to executing this protocol.</p><p>First the client sends a signed <code>StorageDealProposal</code> to the storage miner:</p><pre><code><span class="token keyword">type</span> Commitment <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">;</span>

<span class="token keyword">type</span> StorageDealProposal <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	<span class="token comment" spellcheck="true">// PieceRef is the hash of the data in native structure. This will be used for</span>
	<span class="token comment" spellcheck="true">// certifying the data transfer</span>
	PieceRef Cid

	<span class="token comment" spellcheck="true">// SerializationMode specifies how the graph referenced by 'PieceRef' gets transformed</span>
	<span class="token comment" spellcheck="true">// into the data that will be packed into a sector.</span>
	SerializationMode <span class="token builtin">string</span>

	<span class="token comment" spellcheck="true">// CommP is the data hashed in a form that is compatible with the proofs system</span>
	<span class="token comment" spellcheck="true">// TODO: this *could* possibly be combined with the PieceRef</span>
	CommP Commitment

	Size NumBytes

	TotalPrice TokenAmount

	<span class="token comment" spellcheck="true">// Duration is how long the file should be stored for</span>
	Duration NumBlocks

	<span class="token comment" spellcheck="true">// PaymentRef is a reference to the mechanism that the proposer</span>
	<span class="token comment" spellcheck="true">// will use to pay the miner. It should be verifiable by the</span>
	<span class="token comment" spellcheck="true">// miner using on-chain information.</span>
	Payment PaymentInfo

	<span class="token comment" spellcheck="true">// MinerAddress is the address of the storage miner in the deal proposal</span>
	MinerAddress Address

	ClientAddress Address
	Signature     Signature
<span class="token punctuation">}</span>

<span class="token keyword">type</span> PaymentInfo <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	<span class="token comment" spellcheck="true">// PayChActor is the address of the payment channel actor</span>
	<span class="token comment" spellcheck="true">// that will be used to facilitate payments</span>
	PayChActor Address

	<span class="token comment" spellcheck="true">// Payer is the address of the owner of the payment channel</span>
	Payer Address

	<span class="token comment" spellcheck="true">// Channel is the ID of the specific channel the client will</span>
	<span class="token comment" spellcheck="true">// use to pay the miner. It must already have sufficient funds locked up</span>
	Channel ChannelID

	<span class="token comment" spellcheck="true">// ChannelMsgCid is the B58 encoded CID of the message used to create the</span>
	<span class="token comment" spellcheck="true">// channel. Adding the message cid allows the miner to wait until the</span>
	<span class="token comment" spellcheck="true">// channel is accepted on chain.</span>
	ChannelMsgCid cid<span class="token punctuation">.</span>Cid

	<span class="token comment" spellcheck="true">// Vouchers is a set of payments from the client to the miner that can be</span>
	<span class="token comment" spellcheck="true">// cashed out contingent on the agreed upon data being provably within a</span>
	<span class="token comment" spellcheck="true">// live sector in the miners control on-chain</span>
	Vouchers <span class="token punctuation">[</span><span class="token punctuation">]</span>PaymentVouchers
<span class="token punctuation">}</span>
</code></pre><section id="sec-Deal-State-Values" secid="16.3.1"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Deal-State-Values">16.3.1</a></span>Deal State Values</h4><p>Legal values for <code>DealState</code> are as follows:</p><pre><code><span class="token keyword">const</span> <span class="token punctuation">(</span>
	<span class="token comment" spellcheck="true">// Unset implies a programmer error. This value should never appear</span>
	<span class="token comment" spellcheck="true">// in an actual message</span>
	Unset <span class="token operator">=</span> <span class="token number">0</span>

	<span class="token comment" spellcheck="true">// Unknown signifies an unknown negotiation</span>
	Unknown <span class="token operator">=</span> <span class="token number">1</span>

	<span class="token comment" spellcheck="true">// Rejected means the deal was rejected for some reason</span>
	Rejected <span class="token operator">=</span> <span class="token number">2</span>

	<span class="token comment" spellcheck="true">// Accepted means the deal was accepted but hasnt yet started</span>
	Accepted <span class="token operator">=</span> <span class="token number">3</span>

	<span class="token comment" spellcheck="true">// Started means the deal has started and the transfer is in progress</span>
	Started <span class="token operator">=</span> <span class="token number">4</span>

	<span class="token comment" spellcheck="true">// Failed means the deal has failed for some reason</span>
	Failed <span class="token operator">=</span> <span class="token number">5</span>

	<span class="token comment" spellcheck="true">// Staged is used by the storage deal protocol to indicate the data has been</span>
	<span class="token comment" spellcheck="true">// received and staged into a sector, but is not sealed yet</span>
	Staged <span class="token operator">=</span> <span class="token number">6</span>

	<span class="token comment" spellcheck="true">// Complete means the deal is complete, and the sector that the deal is contained</span>
	<span class="token comment" spellcheck="true">// in has been sealed and its commitment posted on chain.</span>
	Complete <span class="token operator">=</span> <span class="token number">6</span>

	<span class="token comment" spellcheck="true">// Staged is used by the storage deal protocol to indicate the data has been</span>
	<span class="token comment" spellcheck="true">// received and staged into a sector, but is not sealed yet</span>
	Staged <span class="token operator">=</span> <span class="token number">7</span>

	<span class="token comment" spellcheck="true">// in has been sealed and its commitment posted on chain.</span>
	Complete <span class="token operator">=</span> <span class="token number">7</span>
<span class="token punctuation">)</span>
</code></pre><pre><code><span class="token keyword">func</span> <span class="token function">SendStorageProposal</span><span class="token punctuation">(</span>miner Address<span class="token punctuation">,</span> file Cid<span class="token punctuation">,</span> duration NumBlocks<span class="token punctuation">,</span> price TokenAmount<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">IsMiner</span><span class="token punctuation">(</span>miner<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"given address was not a miner"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	<span class="token comment" spellcheck="true">// Get a PoRep friendly commitment from the file</span>
	commitment<span class="token punctuation">,</span> size <span class="token operator">:=</span> <span class="token function">ProcessRef</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span>

	<span class="token comment" spellcheck="true">// Get a handle on the payment system to be used to pay this miner</span>
	<span class="token comment" spellcheck="true">// Most likely, this grabs an existing payment channel, or creates</span>
	<span class="token comment" spellcheck="true">// a new one</span>
	payments <span class="token operator">:=</span> <span class="token function">PaymentSysToMiner</span><span class="token punctuation">(</span>miner<span class="token punctuation">)</span>

	payInfo <span class="token operator">:=</span> payments<span class="token punctuation">.</span><span class="token function">CreatePaymentInfo</span><span class="token punctuation">(</span>storageStart<span class="token punctuation">,</span> duration<span class="token punctuation">,</span> price<span class="token operator">*</span>size<span class="token punctuation">)</span>

	prop <span class="token operator">:=</span> StorageDealProposal<span class="token punctuation">{</span>
		PieceRef<span class="token punctuation">:</span>      file<span class="token punctuation">,</span>
		CommP<span class="token punctuation">:</span> commitment<span class="token punctuation">,</span>
		TotalPrice<span class="token punctuation">:</span>    price <span class="token operator">*</span> size<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// Maybe just leave this to the payment info?</span>
		Duration<span class="token punctuation">:</span>      duration<span class="token punctuation">,</span>
		Size<span class="token punctuation">:</span>          size<span class="token punctuation">,</span>
		Payment<span class="token punctuation">:</span>       payInfo<span class="token punctuation">,</span>
	<span class="token punctuation">}</span>

	client<span class="token punctuation">.</span><span class="token function">SignProposal</span><span class="token punctuation">(</span>prop<span class="token punctuation">)</span>

	peerid <span class="token operator">:=</span> lookup<span class="token punctuation">.</span><span class="token function">ByMinerAddress</span><span class="token punctuation">(</span>miner<span class="token punctuation">)</span>
	s <span class="token operator">:=</span> <span class="token function">NewStream</span><span class="token punctuation">(</span>peerid<span class="token punctuation">,</span> MakeStorageDealProtocolID<span class="token punctuation">)</span>

	<span class="token comment" spellcheck="true">// Send the proposal over</span>
	CborRpc<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> prop<span class="token punctuation">)</span>

	<span class="token comment" spellcheck="true">// Read the response...</span>
	resp <span class="token operator">:=</span> CborRpc<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>

	<span class="token keyword">switch</span> resp<span class="token punctuation">.</span>State <span class="token punctuation">{</span>
	<span class="token keyword">case</span> Accepted<span class="token punctuation">:</span>
		<span class="token comment" spellcheck="true">// Yay! the miner accepted our deal, prepare to send them the file, and then check back</span>
		<span class="token comment" spellcheck="true">// later to see how its going</span>
	<span class="token keyword">case</span> Rejected<span class="token punctuation">:</span>
		<span class="token comment" spellcheck="true">// oh no, our deal was rejected.</span>
		<span class="token comment" spellcheck="true">// practically, we should consider whether or not to close our payment channel</span>
		<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"Deal rejected, reason: "</span><span class="token punctuation">,</span> resp<span class="token punctuation">.</span>Message<span class="token punctuation">)</span>
	<span class="token keyword">default</span><span class="token punctuation">:</span>
		<span class="token comment" spellcheck="true">// unexpected response state...</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="spec-todo">possibly also include a starting block height here, to indicate when this deal may be started (implying you could select a value in the future). After the first response, both parties will have signed agreeing that the deal started at that point. This could possibly be used to challenge either party in the event of a stall. This starting block height also gives the miner time to seal and post the commitment on chain. Otherwise a weird condition exists where a client could immediately slash a miner for not having their data stored.</div><p>The miner then decides whether or not to accept the deal, and sends back a response:</p><pre><code><span class="token keyword">type</span> StorageDealResponse <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	State DealState

	<span class="token comment" spellcheck="true">// Message is an optional message to add context to any given response</span>
	Message <span class="token builtin">string</span>

	<span class="token comment" spellcheck="true">// ProposalCid is the cid of the StorageDealProposal object this response is for</span>
	ProposalCid Cid

	<span class="token comment" spellcheck="true">// PieceInclusionProof is a collection of information needed to convince the client that</span>
	<span class="token comment" spellcheck="true">// the miner has sealed the data into a sector.</span>
	<span class="token comment" spellcheck="true">// Note: the miner doesnt necessarily have to have committed the sector at this point</span>
	<span class="token comment" spellcheck="true">// they just need to have staged it into a sector, and be committed to putting it at</span>
	<span class="token comment" spellcheck="true">// that place in the sector.</span>
	PieceInclusionProof PieceInclusionProof

	<span class="token comment" spellcheck="true">// SectorCommitMsg is the Cid of the message that was sent to submit</span>
	<span class="token comment" spellcheck="true">// the sector containing this data to the chain.</span>
	SectorCommitMsg Cid

	<span class="token comment" spellcheck="true">// Signature is a signature from the miner over the response</span>
	Signature Signature
<span class="token punctuation">}</span>
</code></pre><pre><code><span class="token keyword">func</span> <span class="token function">HandleStorageDealProposal</span><span class="token punctuation">(</span>s Stream<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	prop <span class="token operator">:=</span> CborRpc<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>

	<span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">ValidateInput</span><span class="token punctuation">(</span>prop<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"client sent invalid proposal"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">if</span> accept<span class="token punctuation">,</span> reason <span class="token operator">:=</span> MinerPolicy<span class="token punctuation">.</span><span class="token function">ShouldAccept</span><span class="token punctuation">(</span>prop<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">!</span>accept <span class="token punctuation">{</span>
		CborRpc<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> StorageDealResponse<span class="token punctuation">{</span>
			State<span class="token punctuation">:</span>   Rejected<span class="token punctuation">,</span>
			Message<span class="token punctuation">:</span> reason<span class="token punctuation">,</span>
		<span class="token punctuation">}</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">}</span>

	<span class="token comment" spellcheck="true">// Alright, we're accepting</span>
	resp <span class="token operator">:=</span> StorageDealResponse<span class="token punctuation">{</span>
		State<span class="token punctuation">:</span>    Accepted<span class="token punctuation">,</span>
		Proposal<span class="token punctuation">:</span> prop<span class="token punctuation">.</span><span class="token function">Cid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token punctuation">}</span>

	miner<span class="token punctuation">.</span><span class="token function">Sign</span><span class="token punctuation">(</span>resp<span class="token punctuation">)</span>

	miner<span class="token punctuation">.</span><span class="token function">SetDealState</span><span class="token punctuation">(</span>resp<span class="token punctuation">)</span>

	<span class="token comment" spellcheck="true">// Make sure we are ready to receive the file (however it may come)</span>
	<span class="token comment" spellcheck="true">// TODO: potentially add in something to the protocol to allow</span>
	<span class="token comment" spellcheck="true">// clients to signal how the file will be transferred</span>
	miner<span class="token punctuation">.</span><span class="token function">RegisterInboundFileTransfer</span><span class="token punctuation">(</span>prop<span class="token punctuation">)</span>

	CborRpc<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> resp<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">ValidateInput</span><span class="token punctuation">(</span>prop StorageDealProposal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment" spellcheck="true">// Note: Maybe this is unnecessary, and the payment info being valid suffices?</span>
	<span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">ValidateSignature</span><span class="token punctuation">(</span>prop<span class="token punctuation">.</span>Signature<span class="token punctuation">,</span> prop<span class="token punctuation">.</span>ClientAddress<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"invalid signature from client"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">IsExistingAccount</span><span class="token punctuation">(</span>prop<span class="token punctuation">.</span>ClientAddress<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"proposal came from a fake account"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">ValidatePaymentInfo</span><span class="token punctuation">(</span>prop<span class="token punctuation">.</span>Payment<span class="token punctuation">,</span> prop<span class="token punctuation">.</span>Duration<span class="token punctuation">,</span> prop<span class="token punctuation">.</span>Size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"propsal had invalid payment information"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>If <code>response.State</code> is <code>Accepted</code> then the client should proceed to transfer the data in question to the storage miner. This operation happens out of band from this protocol, and can be a simple bitswap transfer at first. Support for other more&lsquo;exotic&rsquo;&lsquo;protocols&rsquo; such as mailing hard drives is an explicit goal.</p><p>Next, when the miner receives all the data and validates it, they set the <code>DealState</code> to <code>Staged</code>. When the sector gets sealed, and the commitment is posted on chain, the state gets set to <code>Complete</code> and the deals <code>PieceInclusionProof</code> field should be set to the appropriate values.</p><pre><code><span class="token keyword">func</span> <span class="token function">OnDataReceived</span><span class="token punctuation">(</span>prop StorageDealProposal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">ValidatePieceTranslation</span><span class="token punctuation">(</span>prop<span class="token punctuation">.</span>PieceRef<span class="token punctuation">,</span> prop<span class="token punctuation">.</span>SerializationMode<span class="token punctuation">,</span> prop<span class="token punctuation">.</span>CommP<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		resp <span class="token operator">:=</span> StorageDealResponse<span class="token punctuation">{</span>
			State<span class="token punctuation">:</span>    Rejected<span class="token punctuation">,</span>
			Proposal<span class="token punctuation">:</span> prop<span class="token punctuation">.</span><span class="token function">Cid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
			Message<span class="token punctuation">:</span>  <span class="token string">"CommP was invalid, reconstructed data did not match"</span><span class="token punctuation">,</span>
		<span class="token punctuation">}</span>

		miner<span class="token punctuation">.</span><span class="token function">Sign</span><span class="token punctuation">(</span>resp<span class="token punctuation">)</span>
		miner<span class="token punctuation">.</span><span class="token function">SetDealState</span><span class="token punctuation">(</span>resp<span class="token punctuation">)</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">}</span>

	<span class="token comment" spellcheck="true">// TODO: is CommP actually needed? How does it tie in?</span>
	SectorBuilder<span class="token punctuation">.</span><span class="token function">AddPiece</span><span class="token punctuation">(</span>prop<span class="token punctuation">.</span>PieceRef<span class="token punctuation">,</span> prop<span class="token punctuation">.</span>SerializationMode<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><pre><code><span class="token keyword">func</span> <span class="token function">OnSectorPacked</span><span class="token punctuation">(</span>prop StorageDealProposal<span class="token punctuation">,</span> pieceConf PieceCommitment<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	resp <span class="token operator">:=</span> StorageDealResponse<span class="token punctuation">{</span>
		State<span class="token punctuation">:</span>             Staged<span class="token punctuation">,</span>
		Proposal<span class="token punctuation">:</span>          prop<span class="token punctuation">.</span><span class="token function">Cid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
		PieceInclusionProof<span class="token punctuation">:</span> pieceConf<span class="token punctuation">,</span>
	<span class="token punctuation">}</span>

	miner<span class="token punctuation">.</span><span class="token function">Sign</span><span class="token punctuation">(</span>resp<span class="token punctuation">)</span>
	miner<span class="token punctuation">.</span><span class="token function">SetDealState</span><span class="token punctuation">(</span>resp<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><p>Once the deal makes it to the <code>Staged</code> state, the client should be able to query and get the <code>PieceInclusionProof</code> that they need to verify that the miner is indeed storing their data.</p><pre><code><span class="token keyword">func</span> <span class="token function">OnSectorSealed</span><span class="token punctuation">(</span>prop StorageDealProposal<span class="token punctuation">,</span> msgcid Cid<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	curState <span class="token operator">:=</span> miner<span class="token punctuation">.</span><span class="token function">GetDealState</span><span class="token punctuation">(</span>prop<span class="token punctuation">)</span>
	nstate <span class="token operator">:=</span> StorageDealResponse<span class="token punctuation">{</span>
		State<span class="token punctuation">:</span>             Complete<span class="token punctuation">,</span>
		Proposal<span class="token punctuation">:</span>          prop<span class="token punctuation">.</span><span class="token function">Cid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
		PieceInclusionProof<span class="token punctuation">:</span> curState<span class="token punctuation">.</span>PieceInclusionProof<span class="token punctuation">,</span>
		SectorCommitMsg<span class="token punctuation">:</span>   msgcid<span class="token punctuation">,</span>
	<span class="token punctuation">}</span>

	miner<span class="token punctuation">.</span><span class="token function">Sign</span><span class="token punctuation">(</span>nstate<span class="token punctuation">)</span>
	miner<span class="token punctuation">.</span><span class="token function">SetDealState</span><span class="token punctuation">(</span>nstate<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></section></section><section id="sec-Query" secid="16.4"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Query">16.4</a></span>Query</h3><p>Here we describe a basic protocol for querying the current state of a given storage deal. In the future we may want something more complex that is able to multiplex waiting for notifications about a large set of deals over a single stream simultaneously. Upgrading to that from this should be relatively simple, so for now, we do the simple thing.</p><p>The libp2p protocol ID for this protocol is <code>/fil/storage/qry/1.0.0</code></p><p>At any point, the client in this flow may query the miner for the state of a given proposal. To query, they send a&lsquo;StorageDealQuery&rsquo; that looks like this:</p><pre><code><span class="token keyword">type</span> StorageDealQuery <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	<span class="token comment" spellcheck="true">// ProposalCid is the cid of the proposal for the deal that we are querying</span>
	<span class="token comment" spellcheck="true">// the state of</span>
	ProposalCid <span class="token operator">*</span>cid<span class="token punctuation">.</span>Cid

	BaseState DealState
<span class="token punctuation">}</span>
</code></pre><p>If <code>BaseState</code> is <code>Unset</code> or a terminal state (<code>Complete</code>, <code>Rejected</code>, or <code>Failed</code>) then the current state of the deal in question is returned. If the <code>BaseState</code> is different than the current state of the deal, the current state of the deal is also returned immediately. In the case that the <code>BaseState</code> matches the current state of the deal, then the stream is held open until the state changes, at which point the new state of the deal is returned.</p></section><section id="sec-Retrieve-Piece-for-Free" secid="16.5"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Retrieve-Piece-for-Free">16.5</a></span>Retrieve Piece for Free</h3><p>The Retrieve Piece for Free protocol is used to coordinate the transfer of a piece from miner to client at no cost to the client.</p><p>The client initiates the protocol by opening a libp2p stream to the miner using the <code>/fil/retrieval/free/0.0.0</code> protocol id. To find and connect to the miner, the <a href="lookup-service.md">address lookup service</a> should be used. Once connected, the client must send the miner a <code>RetrievePieceRequest</code> message using the <a href="#CBOR-RPC">CBOR RPC</a> protocol format.</p><p>The <code>RetrievePieceRequest</code> is specified as follows:</p><pre><code><span class="token keyword">type</span> RetrievePieceRequest <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	<span class="token comment" spellcheck="true">// `PieceRef` identifies a piece of user data, typically received from the</span>
	<span class="token comment" spellcheck="true">// client while consummating a storage deal.</span>
	PieceRef <span class="token operator">*</span>cid<span class="token punctuation">.</span>Cid
<span class="token punctuation">}</span>
</code></pre><p>When the miner receives the request, it responds with a <code>RetrievePieceResponse</code> message indicating that it has accepted or rejected the request.</p><p>The <code>RetrievePieceResponse</code> message is specified as follows:</p><pre><code><span class="token keyword">type</span> RetrievePieceResponse <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	<span class="token comment" spellcheck="true">// `Status` communicates the miner's willingness to send a piece back to a</span>
	<span class="token comment" spellcheck="true">// client. The value of the `Status` field must be one of: `Failure` or</span>
	<span class="token comment" spellcheck="true">// `Success`.</span>
	Status RetrievePieceStatus

	<span class="token comment" spellcheck="true">// If `Status` is `Failure`, `ErrorMessage` should contain a string</span>
	<span class="token comment" spellcheck="true">// explaining the cause for the rejection.</span>
	ErrorMessage <span class="token builtin">string</span>
<span class="token punctuation">}</span>
</code></pre><p>Legal values for <code>RetrievePieceStatus</code> are as follows:</p><pre><code><span class="token keyword">const</span> <span class="token punctuation">(</span>
	<span class="token comment" spellcheck="true">// Unset implies a programmer error. This value should never appear in an</span>
	<span class="token comment" spellcheck="true">// actual message.</span>
	Unset <span class="token operator">=</span> <span class="token function">RetrievePieceStatus</span><span class="token punctuation">(</span><span class="token boolean">iota</span><span class="token punctuation">)</span>

	<span class="token comment" spellcheck="true">// Failure indicates that the piece can not be retrieved from the miner.</span>
	Failure

	<span class="token comment" spellcheck="true">// Success means that the piece can be retrieved from the miner.</span>
	Success
<span class="token punctuation">)</span>
</code></pre><p>If the miner does not accept the request, it sends a <code>RetrievePieceResponse</code> with the <code>Status</code> field set to <code>Failure</code>. The miner should set the <code>ErrorMessage</code> field to indicate a reason for the request being rejected.</p><p>If the miner accepts the request, it sends a <code>RetrievePieceResponse</code> with the <code>Status</code> field set to <code>Success</code>. The miner then sends the client ordered <code>RetrievePieceChunk</code> messages until all of the piece&rsquo;s data has been transferred, at which point the miner closes the stream.</p><div class="spec-note">The client must be able to reconstruct a piece by concatenating the <code>Data</code>-bytes in the order that they were received.</div><div class="spec-note">The miner divides the piece in to chunks containing a maximum of <code>256 &lt;&lt; 8</code> bytes due to a limitation in our software which caps the size of CBOR&#8208;encoded messages at <code>256 &lt;&lt; 10</code> bytes.</div><p>The <code>RetrievePieceChunk</code> message is specified as follows:</p><pre><code><span class="token keyword">type</span> RetrievePieceChunk <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	<span class="token comment" spellcheck="true">// The `Data` field contains a chunk of a piece. The length of `Data` must</span>
	<span class="token comment" spellcheck="true">// be > 0.</span>
	Data <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span>
<span class="token punctuation">}</span>
</code></pre><div class="spec-todo">document the query deal interaction</div></section><section id="sec-BlockSync" secid="16.6"><h3><span class="spec-secid" title="link to this section"><a href="#sec-BlockSync">16.6</a></span>BlockSync</h3><p>The blocksync protocol is a small protocol that allows Filecoin nodes to request ranges of blocks from each other. It is a simple request/response protocol with a protocol ID of <code>/fil/sync/blk/0.0.0</code>. It uses CBOR&#8208;RPC.</p><pre><code><span class="token keyword">type</span> BlockSyncRequest <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	Start         Cid
	RequestLength <span class="token builtin">uint64</span>
<span class="token punctuation">}</span>
</code></pre><p>The request requests a chain of a given length by the hash of its highest block.</p><pre><code><span class="token keyword">type</span> BlockSyncResponse <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	Blocks <span class="token punctuation">[</span><span class="token punctuation">]</span>Block

	Status  <span class="token builtin">uint</span>
	Message <span class="token builtin">string</span>
<span class="token punctuation">}</span>
</code></pre><p>The response contains the chain of requested blocks, in reverse iteration order, the zero&rsquo;th block should be the block referenced by <code>request.Start</code>, and the following N blocks should be its N parents, and so on. This is done to streamline validation.</p><p>Possible error codes:</p><pre><code><span class="token keyword">const</span> <span class="token punctuation">(</span>
	Success <span class="token operator">=</span> <span class="token number">0</span>

	<span class="token comment" spellcheck="true">// Sent back fewer blocks than requested</span>
	PartialResponse <span class="token operator">=</span> <span class="token number">101</span>

	<span class="token comment" spellcheck="true">// request.Start not found</span>
	BlockNotFound <span class="token operator">=</span> <span class="token number">201</span>

	<span class="token comment" spellcheck="true">// requester is making too many requests</span>
	GoAway <span class="token operator">=</span> <span class="token number">202</span>

	<span class="token comment" spellcheck="true">// Internal Error</span>
	InternalError <span class="token operator">=</span> <span class="token number">203</span>
<span class="token punctuation">)</span>
</code></pre></section></section><section id="sec-Filecoin-Data-Propagation" secid="17"><h2><span class="spec-secid" title="link to this section"><a href="#sec-Filecoin-Data-Propagation">17</a></span>Filecoin Data Propagation</h2><p>The filecoin network needs to broadcast blocks and messages to all peers in the network. This document details how that process works.</p><p>Both blocks and messages are propagated using the gossipsub libp2p pubsub router. The pubsub messages are authenticated. For blocks, the pubsub hop validation function is set to check that the block is valid before re&#8208;propagating. For messages, a similar validity check is run, the signature must be valid, and the account in question must have enough funds to cover the actions specified.</p><section id="sec-Links" secid="17.1"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Links">17.1</a></span>Links</h3><ul><li><a href="https://github.com/libp2p/specs/tree/master/pubsub/gossipsub">Gossipsub Spec</a></li><li><a href="mining.md#chain-validation">Block Validity Check</a></li><li>TODO: Link to message validity check function</li></ul></section><section id="sec-Block-Propagation" secid="17.2"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Block-Propagation">17.2</a></span>Block Propagation</h3><p>Blocks are propagated over the libp2p pubsub channel <code>/fil/blocks</code>. The block is <a href="data-structures.md#block">serialized</a> and the raw bytes are sent as the content of the pubsub message. No messages, computed state, or other additional information is sent along with the block message.</p><p>Each Filecoin node sets a&lsquo;validation function&rsquo; for the blocks topic that checks that the block is properly constructed, its ticket is valid, the block signature is valid, the miner is a valid miner, and the block is a child of a known good tipset. (TODO: clarify which of these checks are needed, any slowness here impacts propagation time significantly, this is not a full validity check) If an invalid block is received, the peer it was received from should be marked as potentially bad (TODO: we could blacklist peers who send bad blocks, maybe need support from libp2p for this?)</p><div class="spec-todo">we should likely be smarter here and track which messages we could send along with each block to improve propagation time</div></section><section id="sec-Message-Propagation" secid="17.3"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Message-Propagation">17.3</a></span>Message Propagation</h3><p>Messages are propagated over the libp2p pubsub channel <code>/fil/messages</code>. The message is <a href="data-structures.md#messages">serialized</a> and the raw bytes are sent as the content of the pubsub message.</p><p>The pubsub validation function for messages checks that the content of each pubsub message on this topic is, first, under the maximum size limit for a message, and then that it is a properly constructed message. (TODO: discuss checking signatures and account balances, some tricky bits that need consideration). If an invalid message is received from a peer, that peer should be marked as potentially bad. </p></section></section><section id="sec-Data-Structures" secid="18"><h2><span class="spec-secid" title="link to this section"><a href="#sec-Data-Structures">18</a></span>Data Structures</h2><p>This document serves as an entry point for understanding all of the data structures in filecoin.</p><section id="sec-Data-Structures.Address" secid="18.1"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Data-Structures.Address">18.1</a></span>Address</h3><p>An address is an identifier that refers to an actor in the Filecoin state. All actors (miner actors, the storage market actor, account actors) have an address. An address encodes information about the network it belongs to, the type of data it contains, the data itself, and depending on the type, a checksum.</p><pre><code><span class="token keyword">type</span> Address <span class="token keyword">struct</span> <span class="token punctuation">{</span>

	<span class="token comment" spellcheck="true">// 0: ID</span>
	<span class="token comment" spellcheck="true">// 1: SECP256K1 Public Key</span>
	<span class="token comment" spellcheck="true">// 2: Actor</span>
	<span class="token comment" spellcheck="true">// 3: BLS Public Key</span>
	protocol <span class="token builtin">byte</span>

	<span class="token comment" spellcheck="true">// raw bytes containing the data associated with protocol</span>
	payload <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span>
<span class="token punctuation">}</span>
</code></pre><p>To learn more, take a look at the <a href="https://github.com/filecoin-project/specs/blob/master/address.md">Address Spec</a>.</p></section><section id="sec-CID" secid="18.2"><h3><span class="spec-secid" title="link to this section"><a href="#sec-CID">18.2</a></span>CID</h3><p>For most objects referenced by Filecoin, a Content Identifier (CID for short) is used. This is effectively a hash value, prefixed with its hash function (multihash) prepended with a few extra labels to inform applications about how to deserialize the given data. To learn more, take a look at the <a href="https://github.com/ipld/cid">CID Spec</a>.</p><p>CIDs are serialized by applying binary multibase encoding, then encoding that as a CBOR byte array with a tag of 42.</p></section><section id="sec-Data-Structures.Block" secid="18.3"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Data-Structures.Block">18.3</a></span>Block</h3><p>A block represents an individual point in time that the network may achieve consensus on. It contains (via merkle links) the full state of the system, references to the previous state, and some notion of a&lsquo;weight&rsquo; for deciding which block is the&lsquo;best&rsquo;.</p><pre><code><span class="token comment" spellcheck="true">// Block is a block in the blockchain.</span>
<span class="token keyword">type</span> Block <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	<span class="token comment" spellcheck="true">// Miner is the address of the miner actor that mined this block.</span>
	Miner Address

	<span class="token comment" spellcheck="true">// Tickets are the winning ticket that were submitted with this block.</span>
	Tickets <span class="token punctuation">[</span><span class="token punctuation">]</span>Ticket

	<span class="token comment" spellcheck="true">// ElectionProof is a signature over the final ticket that proves this miner</span>
	<span class="token comment" spellcheck="true">// is the leader at this round</span>
	ElectionProof Signature

	<span class="token comment" spellcheck="true">// Parents is the set of parents this block was based on. Typically one,</span>
	<span class="token comment" spellcheck="true">// but can be several in the case where there were multiple winning ticket-</span>
	<span class="token comment" spellcheck="true">// holders for a round.</span>
	Parents <span class="token punctuation">[</span><span class="token punctuation">]</span>Cid

	<span class="token comment" spellcheck="true">// ParentWeight is the aggregate chain weight of the parent set.</span>
	ParentWeight Integer

	<span class="token comment" spellcheck="true">// Height is the chain height of this block.</span>
	Height Uint64

	<span class="token comment" spellcheck="true">// StateRoot is a cid pointer to the state tree after application of the</span>
	<span class="token comment" spellcheck="true">// transactions state transitions.</span>
	StateRoot Cid

	<span class="token comment" spellcheck="true">// Messages is the set of messages included in this block</span>
	<span class="token comment" spellcheck="true">// TODO: should be a merkletree-ish thing</span>
	Messages <span class="token punctuation">[</span><span class="token punctuation">]</span>SignedMessage

	<span class="token comment" spellcheck="true">// MessageReceipts is a set of receipts matching to the sending of the `Messages`.</span>
	<span class="token comment" spellcheck="true">// TODO: should be the same type of merkletree-list thing that the messages are</span>
	MessageReceipts <span class="token punctuation">[</span><span class="token punctuation">]</span>MessageReceipt

    <span class="token comment" spellcheck="true">// The block Timestamp is used to enforce a form of block delay by honest miners.</span>
    <span class="token comment" spellcheck="true">// Unix time UTC timestamp stored as an unsigned integer</span>
    Timestamp Timestamp
<span class="token punctuation">}</span>
</code></pre></section><section id="sec-Data-Structures.Message" secid="18.4"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Data-Structures.Message">18.4</a></span>Message</h3><pre><code><span class="token keyword">type</span> Message <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	To   Address
	From Address

	<span class="token comment" spellcheck="true">// When receiving a message from a user account the nonce in</span>
	<span class="token comment" spellcheck="true">// the message must match the expected nonce in the from actor.</span>
	<span class="token comment" spellcheck="true">// This prevents replay attacks.</span>
	Nonce Uint64

	Value BigInteger

	GasPrice Integer
	GasLimit Integer

	Method <span class="token builtin">uint64</span>
	Params <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span>
<span class="token punctuation">}</span>
</code></pre><section id="sec-Parameter-Encoding" secid="18.4.1"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Parameter-Encoding">18.4.1</a></span>Parameter Encoding</h4><p>Parameters to methods get encoded as described in the <a href="#basic-type-encodings">basic types</a> section below, and then put into a CBOR encoded array. (TODO: thinking about this, it might make more sense to just have <code>Params</code> be an array of things)</p></section><section id="sec-Signing" secid="18.4.2"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Signing">18.4.2</a></span>Signing</h4><p>A signed message is a wrapper type over the base message.</p><pre><code><span class="token keyword">type</span> SignedMessage <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	Message   Message
	Signature Signature
<span class="token punctuation">}</span>
</code></pre><p>The signature is a serialized signature over the serialized base message. For more details on how the signature itself is done, see the <a href="signatures.md">signatures spec</a>.</p></section></section><section id="sec-Message-Receipt" secid="18.5"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Message-Receipt">18.5</a></span>Message Receipt</h3><pre><code><span class="token keyword">type</span> MessageReceipt <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	ExitCode <span class="token builtin">uint8</span>

	Return <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span>

	GasUsed Integer
<span class="token punctuation">}</span>
</code></pre><section id="sec-Message-Receipt.Serialization" secid="18.5.1"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Message-Receipt.Serialization">18.5.1</a></span>Serialization</h4><p>Message receipts are currently serialized simply by CBOR marshaling them, using lower&#8208;camel&#8208;cased field names.</p></section></section><section id="sec-Data-Structures.Actor" secid="18.6"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Data-Structures.Actor">18.6</a></span>Actor</h3><pre><code><span class="token keyword">type</span> Actor <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	<span class="token comment" spellcheck="true">// Code is a pointer to the code object for this actor</span>
	Code Cid

	<span class="token comment" spellcheck="true">// Head is a pointer to the root of this actors state</span>
	Head Cid

	<span class="token comment" spellcheck="true">// Nonce is a counter of the number of messages this actor has sent</span>
	Nonce Uint64

	<span class="token comment" spellcheck="true">// Balance is this actors current balance of filecoin</span>
	Balance BigInteger
<span class="token punctuation">}</span>
</code></pre></section><section id="sec-State-Tree" secid="18.7"><h3><span class="spec-secid" title="link to this section"><a href="#sec-State-Tree">18.7</a></span>State Tree</h3><p>The state trie keeps track of all state in Filecoin. It is a map of addresses to <code>actors</code> in the system. It is implemented using a HAMT.</p></section><section id="sec-HAMT" secid="18.8"><h3><span class="spec-secid" title="link to this section"><a href="#sec-HAMT">18.8</a></span>HAMT</h3><div class="spec-todo">link to spec for our CHAMP HAMT</div></section><section id="sec-Signature" secid="18.9"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Signature">18.9</a></span>Signature</h3><p>All signatures in Filecoin come with a type that signifies which key type was used to create the signature.</p><pre><code><span class="token keyword">type</span> Signature <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	Type <span class="token builtin">int</span>
	Data <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span>
<span class="token punctuation">}</span>
</code></pre><section id="sec--Type-Values" secid="18.9.1"><h4><span class="spec-secid" title="link to this section"><a href="#sec--Type-Values">18.9.1</a></span>`Type` Values</h4><table><thead><tr><th>Key Type </th><th>Value </th></tr></thead><tbody><tr><td>Secp256k1 </td><td>1 </td></tr><tr><td>BLS12&#8208;381 ECDSA </td><td>2 </td></tr></tbody></table></section><section id="sec-Signature.Serialization" secid="18.9.2"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Signature.Serialization">18.9.2</a></span>Serialization</h4><p><code>&lt;uvarint(Type)&gt;&lt;Data&gt;</code></p><div class="spec-note">As signatures should always be within wrapper types, length prefixing is not needed here.</div></section></section><section id="sec-Basic-Type-Encodings" secid="18.10"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Basic-Type-Encodings">18.10</a></span>Basic Type Encodings</h3><p>Types that appear in messages or in state must be encoded as described here.</p><section id="sec--PublicKey-" secid="18.10.1"><h4><span class="spec-secid" title="link to this section"><a href="#sec--PublicKey-">18.10.1</a></span>`PublicKey`</h4><p>The public key type is simply an array of bytes. (TODO: discuss specific encoding of key types, for now just calling it bytes is sufficient)</p></section><section id="sec--BytesAmount-" secid="18.10.2"><h4><span class="spec-secid" title="link to this section"><a href="#sec--BytesAmount-">18.10.2</a></span>`BytesAmount`</h4><p>BytesAmount is just a re&#8208;typed Integer.</p></section><section id="sec--PeerID-" secid="18.10.3"><h4><span class="spec-secid" title="link to this section"><a href="#sec--PeerID-">18.10.3</a></span>`PeerID`</h4><p>PeerID is just the serialized bytes of a libp2p peer ID.</p><p>Spec incomplete, take a look at this PR: https://github.com/libp2p/specs/pull/100</p></section><section id="sec--Integer-" secid="18.10.4"><h4><span class="spec-secid" title="link to this section"><a href="#sec--Integer-">18.10.4</a></span>`Integer`</h4><p>Integers are encoded as LEB128 signed integers.</p></section><section id="sec--BitField-" secid="18.10.5"><h4><span class="spec-secid" title="link to this section"><a href="#sec--BitField-">18.10.5</a></span>`BitField`</h4><p>Bitfields are a set of bits. Encoding still TBD, but it needs to be very compact. We can assume that most often, ranges of bits will be set, or not set, and use that to our advantage here. Some form of run length encoding may work well.</p></section><section id="sec--SectorSet-" secid="18.10.6"><h4><span class="spec-secid" title="link to this section"><a href="#sec--SectorSet-">18.10.6</a></span>`SectorSet`</h4><p>TODO</p></section><section id="sec--FaultSet-" secid="18.10.7"><h4><span class="spec-secid" title="link to this section"><a href="#sec--FaultSet-">18.10.7</a></span>`FaultSet`</h4><p>A fault set is a BitField and a block height, encoding TBD.</p></section><section id="sec--BlockHeader-" secid="18.10.8"><h4><span class="spec-secid" title="link to this section"><a href="#sec--BlockHeader-">18.10.8</a></span>`BlockHeader`</h4><p>BlockHeader is a serialized <code>Block</code>.</p></section><section id="sec--SealProof-" secid="18.10.9"><h4><span class="spec-secid" title="link to this section"><a href="#sec--SealProof-">18.10.9</a></span>`SealProof`</h4><p>SealProof is a 384&#8208;element array of bytes.</p></section><section id="sec--PoStProof-" secid="18.10.10"><h4><span class="spec-secid" title="link to this section"><a href="#sec--PoStProof-">18.10.10</a></span>`PoStProof`</h4><p>PoStProof is a 192&#8208;element array of bytes.</p></section><section id="sec--TokenAmount-" secid="18.10.11"><h4><span class="spec-secid" title="link to this section"><a href="#sec--TokenAmount-">18.10.11</a></span>`TokenAmount`</h4><p>TokenAmount is a re&#8208;typed Integer.</p></section></section><section id="sec-LEB128-Encoding-Reference" secid="18.11"><h3><span class="spec-secid" title="link to this section"><a href="#sec-LEB128-Encoding-Reference">18.11</a></span>LEB128 Encoding Reference</h3><p>This is taken from the Dwarf Standard 4, Appendix C</p><section id="sec-Encode-unsigned-LEB128" secid="18.11.1"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Encode-unsigned-LEB128">18.11.1</a></span>Encode unsigned LEB128</h4><pre><code><span class="token keyword">do</span>
<span class="token punctuation">{</span>
  byte <span class="token operator">=</span> low order <span class="token number">7</span> bits of value<span class="token punctuation">;</span>
  value <span class="token operator">>>=</span> <span class="token number">7</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">/* more bytes to come */</span>
    set high order bit of byte<span class="token punctuation">;</span>
  emit byte<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>value <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><section id="sec-Encode-signed-LEB128" secid="18.11.1.1"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Encode-signed-LEB128">18.11.1.1</a></span>Encode signed LEB128</h5><pre><code>more <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
negative <span class="token operator">=</span> <span class="token punctuation">(</span>value <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
size <span class="token operator">=</span> no<span class="token punctuation">.</span> of bits in <span class="token keyword">signed</span> integer<span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>more<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  byte <span class="token operator">=</span> low order <span class="token number">7</span> bits of value<span class="token punctuation">;</span>
  value <span class="token operator">>>=</span> <span class="token number">7</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">/* the following is unnecessary if the
   * implementation of >>= uses an arithmetic rather
   * than logical shift for a signed left operand
   */</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>negative<span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">/* sign extend */</span>
    value <span class="token operator">|</span><span class="token operator">=</span> <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>size <span class="token operator">-</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">/* sign bit of byte is second high order bit (0x40) */</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>value <span class="token operator">==</span>  <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> sign bit of byte is clear<span class="token punctuation">)</span> <span class="token operator">||</span>
      <span class="token punctuation">(</span>value <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> sign bit of byte is set<span class="token punctuation">)</span><span class="token punctuation">)</span>
     more <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">else</span>
    set high order bit of byte<span class="token punctuation">;</span>
  emit byte<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></section><section id="sec-Decode-unsigned-LEB128" secid="18.11.1.2"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Decode-unsigned-LEB128">18.11.1.2</a></span>Decode unsigned LEB128</h5><pre><code>result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
shift <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>true<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  byte <span class="token operator">=</span> next byte in input<span class="token punctuation">;</span>
  result <span class="token operator">|</span><span class="token operator">=</span> <span class="token punctuation">(</span>low order <span class="token number">7</span> bits of byte <span class="token operator">&lt;&lt;</span> shift<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>high order bit of byte <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token keyword">break</span><span class="token punctuation">;</span>
  shift <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></section><section id="sec-Decode-signed-LEB128" secid="18.11.1.3"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Decode-signed-LEB128">18.11.1.3</a></span>Decode signed LEB128</h5><pre><code>result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
shift <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
size <span class="token operator">=</span> number of bits in <span class="token keyword">signed</span> integer<span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>true<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  byte <span class="token operator">=</span> next byte in input<span class="token punctuation">;</span>
  result <span class="token operator">|</span><span class="token operator">=</span> <span class="token punctuation">(</span>low order <span class="token number">7</span> bits of byte <span class="token operator">&lt;&lt;</span> shift<span class="token punctuation">)</span><span class="token punctuation">;</span>
  shift <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">/* sign bit of byte is second high order bit (0x40) */</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>high order bit of byte <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
  <span class="token keyword">break</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>shift <span class="token operator">&lt;</span>size<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>sign bit of byte is set<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token comment" spellcheck="true">/* sign extend */</span>
  result <span class="token operator">|</span><span class="token operator">=</span> <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> shift<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></section></section></section><section id="sec-Filecoin-Compact-Serialization" secid="18.12"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Filecoin-Compact-Serialization">18.12</a></span>Filecoin Compact Serialization</h3><p>Datastructures in Filecoin are encoded as compactly as is reasonable. At a high level, each object is converted into an ordered array of its fields (ordered by their appearance in the struct declaration), then CBOR marshaled, and prepended with an object type tag.</p><table><thead><tr><th>FCS Type </th><th>tag </th></tr></thead><tbody><tr><td>block v1 </td><td>43 </td></tr><tr><td>message v1 </td><td>44 </td></tr><tr><td>signedMessage v1 </td><td>45 </td></tr></tbody></table><p>For example, a message would be encoded as:</p><pre><code>tag&lt;44&gt;[msg.To, msg.From, msg.Nonce, msg.Value, msg.GasPrice, msg.GasLimit, msg.Method, msg.Params]
</code></pre><p>Each individual type should be encoded as specified:</p><table><thead><tr><th>type </th><th>encoding </th></tr></thead><tbody><tr><td>Uint64 </td><td>CBOR major type 0 </td></tr><tr><td>BigInteger </td><td><a href="https://tools.ietf.org/html/rfc7049#section-2.4.2">CBOR bignum</a> </td></tr><tr><td>Address </td><td>CBOR major type 2 </td></tr><tr><td>Uint8 </td><td>CBOR Major type 0 </td></tr><tr><td>[]byte </td><td>CBOR Major type 2 </td></tr><tr><td>string </td><td>CBOR Major type 3 </td></tr><tr><td>bool </td><td><a href="https://tools.ietf.org/html/rfc7049#section-2.3">CBOR Major type 7, value 20/21</a> </td></tr></tbody></table></section><section id="sec-Encoding-Considerations" secid="18.13"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Encoding-Considerations">18.13</a></span>Encoding Considerations</h3><p>Objects should be encoded using <a href="https://tools.ietf.org/html/rfc7049#section-3.9">canonical CBOR</a>, and decoders should operate in <a href="https://tools.ietf.org/html/rfc7049#section-3.10">strict mode</a>. The maximum size of an FCS Object should be 1MB (2^20 bytes). Objects larger than this are invalid.</p><p>Additionally, CBOR Major type 5 is not used. If an FCS object contains it, that object is invalid.</p></section><section id="sec-IPLD-Considerations" secid="18.14"><h3><span class="spec-secid" title="link to this section"><a href="#sec-IPLD-Considerations">18.14</a></span>IPLD Considerations</h3><p>Cids for FCS objects should use the FCS multicodec (<code>0x1f</code>).</p></section><section id="sec-Vectors" secid="18.15"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Vectors">18.15</a></span>Vectors</h3><p>Below are some sample vectors for each data type. </p></section></section><section id="sec-Filecoin-Node-Local-Storage" secid="19"><h2><span class="spec-secid" title="link to this section"><a href="#sec-Filecoin-Node-Local-Storage">19</a></span>Filecoin Node Local Storage</h2><p>A Filecoin node stores certain data locally. This section details what exactly gets stored (though exactly <em>how</em> things are stored is not dictated).</p><section id="sec-Chain-Data" secid="19.1"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Chain-Data">19.1</a></span>Chain Data</h3></section><section id="sec-Private-Keys" secid="19.2"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Private-Keys">19.2</a></span>Private Keys</h3></section><section id="sec-Sectors" secid="19.3"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Sectors">19.3</a></span>Sectors</h3></section><section id="sec-Storage-Deals" secid="19.4"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Storage-Deals">19.4</a></span>Storage Deals</h3><p>โ	 </p></section></section><section id="sec-Definitions-Glossary" secid="20"><h2><span class="spec-secid" title="link to this section"><a href="#sec-Definitions-Glossary">20</a></span>Definitions / Glossary</h2><section id="sec-Updates-to-definitions" secid="20.1"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Updates-to-definitions">20.1</a></span>Updates to definitions</h3><p>To make any updates to these definitions please submit a pull request with the changes, or open an issue and one of the maintainers will do it for you.</p></section><section id="sec-Notes" secid="20.2"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Notes">20.2</a></span>Notes</h3><ul><li>Want to split all repair stuff to separate doc</li><li>Let&rsquo;s refer to Filecoin system rather than network. In a sense, the network is an instantiation of the system (this protocol). We can however refer to the Filecoin VM separately which means the system by which we apply changes to the state of the system at a point in time.</li><li>Asterisks indicate that the definition requires updating by any affected party.</li></ul></section><section id="sec-Definitions" secid="20.3"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Definitions">20.3</a></span>Definitions</h3><section id="sec-Definitions.Actor" secid="20.3.1"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Definitions.Actor">20.3.1</a></span>Actor</h4><p>An actor is an on&#8208;chain object with its own state and set of methods. An actors state is persisted on&#8208;chain in the state tree, keyed by its address. All actors (miner actors, the storage market actor, account actors) have an address. Actors methods are invoked by crafting messages and getting miners to include them in blocks.</p><p>Actors are very similar to smart contracts in Ethereum.</p></section><section id="sec-Definitions.Address" secid="20.3.2"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Definitions.Address">20.3.2</a></span>Address</h4><p>An address is an identifier that refers to an actor in the Filecoin state.</p></section><section id="sec-Ask" secid="20.3.3"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Ask">20.3.3</a></span>Ask</h4></section><section id="sec-Bid" secid="20.3.4"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Bid">20.3.4</a></span>Bid</h4></section><section id="sec-Definitions.Block" secid="20.3.5"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Definitions.Block">20.3.5</a></span>Block</h4><p>A block in the Filecoin blockchain is a chunk of data appended to the shared history of the network including transactions, messages, etc. and representing the state of the storage network at a given point in time.</p><p>See <a href="#data-structures">Data Structures</a></p></section><section id="sec-Bootstrapping" secid="20.3.6"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Bootstrapping">20.3.6</a></span>Bootstrapping</h4></section><section id="sec-Chain-weight" secid="20.3.7"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Chain-weight">20.3.7</a></span>Chain weight</h4></section><section id="sec-Challenge-sampling" secid="20.3.8"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Challenge-sampling">20.3.8</a></span>Challenge sampling</h4></section><section id="sec-Cid" secid="20.3.9"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Cid">20.3.9</a></span>Cid</h4><p>CID is short for Content Identifier, a self describing content address used throughout the ipfs ecosystem. For more detailed information, see <a href="https://github.com/ipld/cid">the github documentation for it</a>.</p></section><section id="sec-Client" secid="20.3.10"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Client">20.3.10</a></span>Client</h4><p>A client is any user with an account who wishes to store data with a miner. A client&rsquo;s account is used to pay for the storage, and helps to prove the clients ability to pay.</p></section><section id="sec-Collateral" secid="20.3.11"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Collateral">20.3.11</a></span>Collateral</h4><p>Collateral is Filecoin tokens pledged by an actor as a commitment to a promise. If the promise is respected, the collateral is returned. If the promise is broken, the collateral is not returned in full. For instance:</p><ul><li>In becoming a Filecoin storage miner: the miner will put up collateral alongside their SEAL to</li><li>In a Filecoin deal: both the miner and client put up collateral to ensure their respect of deal terms.</li></ul></section><section id="sec-Commitment" secid="20.3.12"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Commitment">20.3.12</a></span>Commitment</h4><p>See <a href="proofs.md">Filecoin Proofs</a></p></section><section id="sec-Confirmation" secid="20.3.13"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Confirmation">20.3.13</a></span>Confirmation</h4></section><section id="sec-Consensus" secid="20.3.14"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Consensus">20.3.14</a></span>Consensus</h4></section><section id="sec-Definitions.Deal" secid="20.3.15"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Definitions.Deal">20.3.15</a></span>Deal</h4><p>*** *A deal in a Filecoin market is made when a bid and ask are matched, corresponding to an agreement on a service and price between a miner and client.</p></section><section id="sec-Erasure-coding" secid="20.3.16"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Erasure-coding">20.3.16</a></span>Erasure coding</h4><p>Erasure coding is a strategy through which messages can be lengthened so as to be made recoverable in spite of errors.</p><p>See <a href="https://en.wikipedia.org/wiki/Erasure_code">Wikipedia</a></p></section><section id="sec-Epoch" secid="20.3.17"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Epoch">20.3.17</a></span>Epoch</h4><p>An epoch refers to the period over which a given random seed is used in Expected Consensus. In the current Filecoin implementation, each round is an epoch.</p></section><section id="sec-Fault" secid="20.3.18"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Fault">20.3.18</a></span>Fault</h4><p>A fault occurs when a proof is not posted in the Filecoin system within the proving period, denoting another malfunction such as loss of network connectivity, storage malfunction, malicious miner, etc.</p></section><section id="sec-Fair" secid="20.3.19"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Fair">20.3.19</a></span>Fair</h4></section><section id="sec-File" secid="20.3.20"><h4><span class="spec-secid" title="link to this section"><a href="#sec-File">20.3.20</a></span>File</h4><p>Files are what clients bring to the filecoin system to store. A file is split up into <code>pieces</code>, which are what is actually stored by the network.</p></section><section id="sec-Finality" secid="20.3.21"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Finality">20.3.21</a></span>Finality</h4></section><section id="sec-Definitions.Piece-Inclusion-Proof" secid="20.3.22"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Definitions.Piece-Inclusion-Proof">20.3.22</a></span>Piece Inclusion Proof</h4><p>See <a href="proofs.md">Filecoin Proofs</a></p></section><section id="sec-Gas-Fees-Prices" secid="20.3.23"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Gas-Fees-Prices">20.3.23</a></span>Gas, Fees, Prices</h4></section><section id="sec-Generation-Attack-Threshold" secid="20.3.24"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Generation-Attack-Threshold">20.3.24</a></span>Generation Attack Threshold</h4><p>Security parameter. Number of rounds within which a new Proof&#8208;of&#8208;Storage must be submitted in order for a miner to retain power in the network (and avoid getting slashed). This number must be be smaller than the minimum time it takes for an adversarial miner to generate a replica of the data (thereby not storing it undetectably for some period of time).</p><p>The Generation Attack Threshold is equal to the Polling Time + some Grace Period after which miners get slashed.</p></section><section id="sec-GHOST" secid="20.3.25"><h4><span class="spec-secid" title="link to this section"><a href="#sec-GHOST">20.3.25</a></span>GHOST</h4></section><section id="sec-Leader" secid="20.3.26"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Leader">20.3.26</a></span>Leader</h4><p>A leader, in the context of Filecoin consensus, is a node that is chosen to propose the next block in the blockchain.</p></section><section id="sec-Leader-election" secid="20.3.27"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Leader-election">20.3.27</a></span>Leader election</h4><p>Leader election is the process by which the Filecoin network agrees who gets to create the next block.</p></section><section id="sec-Definitions.Message" secid="20.3.28"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Definitions.Message">20.3.28</a></span>Message</h4><p>A message is a call to an actor in the Filecoin VM.</p></section><section id="sec-Miner" secid="20.3.29"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Miner">20.3.29</a></span>Miner</h4><p>A miner is an actor in the Filecoin system performing a service in the network for a reward.</p><p>There are multiple types of miners in Filecoin:</p><ul><li>Storage miners &ndash; storage miners</li><li>Retrieval miners:</li><li>Repair miners (to be split out):</li></ul></section><section id="sec-Node" secid="20.3.30"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Node">20.3.30</a></span>Node</h4><p>*** *A node is a communication endpoint that implements the Filecoin protocol. (also mention IPLD Node?)</p></section><section id="sec-Null-Blocks" secid="20.3.31"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Null-Blocks">20.3.31</a></span>Null Blocks</h4><p>A null block refers to a block with no content mined by default during an epoch in which no miner is elected leader.</p></section><section id="sec-On-chain-off-chain" secid="20.3.32"><h4><span class="spec-secid" title="link to this section"><a href="#sec-On-chain-off-chain">20.3.32</a></span>On-chain/off-chain</h4></section><section id="sec-Online-offline" secid="20.3.33"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Online-offline">20.3.33</a></span>Online/offline</h4></section><section id="sec-Payment-Channel" secid="20.3.34"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Payment-Channel">20.3.34</a></span>Payment Channel</h4><p>A payment channel is set up between actors in the Filecoin system to enable off&#8208;chain payments with on&#8208;chain guarantees, making settlement more efficient.</p></section><section id="sec-Piece" secid="20.3.35"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Piece">20.3.35</a></span>Piece</h4><p>A piece is a portion of a file that gets fitted into a sector.</p></section><section id="sec-Pledge" secid="20.3.36"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Pledge">20.3.36</a></span>Pledge</h4><p>****The initial commitment of a storage miner to provide a number of sectors to the system.</p></section><section id="sec-Polling-Time" secid="20.3.37"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Polling-Time">20.3.37</a></span>Polling Time</h4><p>Security Parameter. Polling time is the time between two online PoReps in a PoSt proof.</p></section><section id="sec-Power-table" secid="20.3.38"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Power-table">20.3.38</a></span>Power table</h4><p>The power table is an abstraction provided by the Filecoin storage market that lists the <code>power</code> of every miner in the system.</p></section><section id="sec-Power-table-lookback" secid="20.3.39"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Power-table-lookback">20.3.39</a></span>Power table lookback</h4><p>Security parameter. A number of rounds to sample back from when determining miner <code>power</code> for use in leader election. A higher number can help secure the system by making potential attacks more costly (as power must be maintained for longer to take effect), but also makes mining more costly for the same reason.</p><p>Also referred to as <code>L</code> in consensus settings.</p></section><section id="sec-Protocol" secid="20.3.40"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Protocol">20.3.40</a></span>Protocol</h4></section><section id="sec-Proving-Period" secid="20.3.41"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Proving-Period">20.3.41</a></span>Proving Period</h4><p>The period of time during which storage miners must compute Proofs of Spacetime. At the end of the period they must submit their PoSt. Put another way, it is the duration of a PoSt.</p></section><section id="sec-Proving-Set" secid="20.3.42"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Proving-Set">20.3.42</a></span>Proving Set</h4><p>The elements used as input by a proof of Spacetime to enable a proof to be generated.</p><p>**** elements necessary to generate a SEAL, or elements necessary to generate a proof</p></section><section id="sec-Definitions.Proof-of-Replication" secid="20.3.43"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Definitions.Proof-of-Replication">20.3.43</a></span>Proof of Replication</h4><p>Proof that a unique encoding of data exists in physical storage.</p><p>Used in the Filecoin system to generate SEALed sectors through which storage miners prove they hold client data.</p></section><section id="sec-Proof-of-Spacetime" secid="20.3.44"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Proof-of-Spacetime">20.3.44</a></span>Proof of Spacetime</h4><p>Proof that a given encoding of data existed in physical storage continuously over a period of time.</p><p>Used in the Filecoin system by a storage miner to prove that client data was kept over the contract duration.</p></section><section id="sec-Random-ness-" secid="20.3.45"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Random-ness-">20.3.45</a></span>Random(ness)</h4><p>****Source of unpredictability used in the Filecoin system to ensure fairness and prevent malicious actors from gaining an advantage over the system.</p><div class="spec-todo">add a note to distinguish predictability from randomness</div></section><section id="sec-Election-Randomness-Lookback" secid="20.3.46"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Election-Randomness-Lookback">20.3.46</a></span>Election Randomness Lookback</h4><p>Security parameter. A number of rounds to sample back from when choosing randomness for use in leader election. A higher number turns a more localized lottery into a more global one since a miner wins or loses on all descendants of a given randomness, but enables miners to look&#8208;ahead and know whether they will be elected in the future.</p><p>Also referred to as <code>K</code> in consensus settings.</p></section><section id="sec-Repair" secid="20.3.47"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Repair">20.3.47</a></span>Repair</h4><p>Repair refers to the processes and protocols by which the Filecoin network ensures that data that is partially lost (by, for example, a miner disappearing) can be re&#8208;constructed and re&#8208;added to the network.</p></section><section id="sec-Round" secid="20.3.48"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Round">20.3.48</a></span>Round</h4><p>A round refers to the period over which a new leader election occurs and a block is generated if a leader is found. Typically this means a new block will be mined at every round, though some rounds may see 0 or multiple blocks generated.</p></section><section id="sec-SEAL-UNSEAL" secid="20.3.49"><h4><span class="spec-secid" title="link to this section"><a href="#sec-SEAL-UNSEAL">20.3.49</a></span>SEAL/UNSEAL</h4><p>See <a href="proofs.md">Filecoin Proofs</a></p></section><section id="sec-Sector" secid="20.3.50"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Sector">20.3.50</a></span>Sector</h4><p>A sector is a contiguous array of bytes that a miner puts together, seals, and performs Proofs of Spacetime on.</p></section><section id="sec-Definitions.Slashing" secid="20.3.51"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Definitions.Slashing">20.3.51</a></span>Slashing</h4></section><section id="sec-Smart-contracts" secid="20.3.52"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Smart-contracts">20.3.52</a></span>Smart contracts</h4></section><section id="sec-Definitions.Storage" secid="20.3.53"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Definitions.Storage">20.3.53</a></span>Storage</h4><p>Storage widely refers to a place in which to store data in a given system.</p><p>In the context of:</p><ul><li>The Filecoin miner: sotrage refers to disk sectors made available to the network.</li><li>The Filecoin chain: storage refers to the way in which system state is tracked through time on&#8208;chain through blocks.</li><li>Actor: the struct that defines an actor.</li></ul></section><section id="sec-Definitions.State" secid="20.3.54"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Definitions.State">20.3.54</a></span>State</h4><p>****Refers to The shared history of the Filecoin system contains actors and their storage, deals, etc. State is deterministically generated from the initial state and the set of messages generated by the system.</p></section><section id="sec-Ticket" secid="20.3.55"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Ticket">20.3.55</a></span>Ticket</h4><p>Some unpredictable element generated by the system for two uses:</p><ul><li>as a random challenge to PoSTs.</li><li>to elect a leader in Expected Consensus.</li></ul><p>See more on <a href="expected-consensus.md">Expected Consensus</a> and <a href="proofs.md">PoSTs</a>.</p></section><section id="sec-TipSet" secid="20.3.56"><h4><span class="spec-secid" title="link to this section"><a href="#sec-TipSet">20.3.56</a></span>TipSet</h4><p>A collection of blocks mined by different miners, each an elected leader of a given epoch. All tip sets have the same parent&#8208;set and epoch number (height). TODO add picture.</p></section><section id="sec-Verifiable" secid="20.3.57"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Verifiable">20.3.57</a></span>Verifiable</h4><p>Something that is verifiable can be checked for correctness by a third party.</p></section><section id="sec-VM" secid="20.3.58"><h4><span class="spec-secid" title="link to this section"><a href="#sec-VM">20.3.58</a></span>VM</h4><p>Virtual Machine. The Filecoin VM refers to the system by which changes are applied to the Filecoin system&rsquo;s state. The VM takes messages as input, and outputs state.</p></section><section id="sec-Voucher" secid="20.3.59"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Voucher">20.3.59</a></span>Voucher</h4><p>Held by an actor as part of a payment channel to complete settlement when the counterparty defaults.</p></section><section id="sec-zkSNARK" secid="20.3.60"><h4><span class="spec-secid" title="link to this section"><a href="#sec-zkSNARK">20.3.60</a></span>zkSNARK</h4><p>Zero Knowledge Succinct ARguments of Knowledge. A way of producing a small&lsquo;proof&rsquo; that convinces a&lsquo;verifier&rsquo; that some computation was done correctly. </p></section></section></section><section id="index" secid="index" class="spec-index"><h1><span class="spec-secid" title="link to the index"><a href="#index">ยง</a></span>Index</h1><ol><li><a href="#From">From</a></li><li><a href="#Parameters">Parameters</a></li><li><a href="#Reference">Reference</a></li><li><a href="#Return">Return</a></li></ol></section><footer>Written in <a href="http://leebyron.com/spec-md/" target="_blank">Spec Markdown</a>.</footer><input hidden class="spec-sidebar-toggle" type="checkbox" id="spec-sidebar-toggle" aria-hidden /><label for="spec-sidebar-toggle" aria-hidden>&#x2630;</label><div class="spec-sidebar" aria-hidden><div class="spec-toc"><div class="title"><a href="#">Filecoin Spec</a></div><ol><li id="_sidebar_1"><a href="#sec-Overview"><span class="spec-secid">1</span>Overview</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_1" /><label for="_sidebar_toggle_1"></label><ol><li id="_sidebar_1.1"><a href="#sec-Message-Transport"><span class="spec-secid">1.1</span>Message Transport</a></li></ol></li><li id="_sidebar_2"><a href="#sec-Filecoin-Spec-Process-v0-"><span class="spec-secid">2</span>Filecoin Spec Process (v0)</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_2" /><label for="_sidebar_toggle_2"></label><ol><li id="_sidebar_2.1"><a href="#sec--Catch-Up-Mode"><span class="spec-secid">2.1</span>&#x27;Catch Up&#x27; Mode</a></li><li id="_sidebar_2.2"><a href="#sec-Proposals---Drafts---Spec"><span class="spec-secid">2.2</span>Proposals -&gt; Drafts -&gt; Spec</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_2.2" /><label for="_sidebar_toggle_2.2"></label><ol><li id="_sidebar_2.2.1"><a href="#sec-On-merging"><span class="spec-secid">2.2.1</span>On merging</a></li><li id="_sidebar_2.2.2"><a href="#sec-Issues"><span class="spec-secid">2.2.2</span>Issues</a></li></ol></li></ol></li><li id="_sidebar_3"><a href="#sec-Filecoin-Node-Operation"><span class="spec-secid">3</span>Filecoin Node Operation</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_3" /><label for="_sidebar_toggle_3"></label><ol><li id="_sidebar_3.1"><a href="#sec-Chain-Validation"><span class="spec-secid">3.1</span>Chain Validation</a></li><li id="_sidebar_3.2"><a href="#sec-MemPool-Maintenance"><span class="spec-secid">3.2</span>MemPool Maintenance</a></li><li id="_sidebar_3.3"><a href="#sec-Handshaking"><span class="spec-secid">3.3</span>Handshaking</a></li><li id="_sidebar_3.4"><a href="#sec-DHT-for-Peer-Routing"><span class="spec-secid">3.4</span>DHT for Peer Routing</a></li><li id="_sidebar_3.5"><a href="#sec-Bitswap-for-data-requests"><span class="spec-secid">3.5</span>Bitswap for data requests</a></li><li id="_sidebar_3.6"><a href="#sec-Filecoin-Node-Operation.Mining"><span class="spec-secid">3.6</span>Mining</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_3.6" /><label for="_sidebar_toggle_3.6"></label><ol><li id="_sidebar_3.6.1"><a href="#sec-Filecoin-Node-Operation.Mining.Storage"><span class="spec-secid">3.6.1</span>Storage</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_3.6.1" /><label for="_sidebar_toggle_3.6.1"></label><ol><li id="_sidebar_3.6.1.1"><a href="#sec-Accept-Deals"><span class="spec-secid">3.6.1.1</span>Accept Deals</a></li><li id="_sidebar_3.6.1.2"><a href="#sec-Prove-Storage"><span class="spec-secid">3.6.1.2</span>Prove Storage</a></li><li id="_sidebar_3.6.1.3"><a href="#sec-Extend-the-Blockchain"><span class="spec-secid">3.6.1.3</span>Extend the Blockchain</a></li></ol></li><li id="_sidebar_3.6.2"><a href="#sec-Retrieval"><span class="spec-secid">3.6.2</span>Retrieval</a></li></ol></li></ol></li><li id="_sidebar_4"><a href="#sec-Chain-Syncing"><span class="spec-secid">4</span>Chain Syncing</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_4" /><label for="_sidebar_toggle_4"></label><ol><li id="_sidebar_4.1"><a href="#sec-What-is-chain-syncing-in-Filecoin-"><span class="spec-secid">4.1</span>What is chain syncing in Filecoin?</a></li><li id="_sidebar_4.2"><a href="#sec-Chain-Syncing.Interface"><span class="spec-secid">4.2</span>Interface</a></li><li id="_sidebar_4.3"><a href="#sec-General-Operation"><span class="spec-secid">4.3</span>General Operation</a></li><li id="_sidebar_4.4"><a href="#sec-Syncing-Mode"><span class="spec-secid">4.4</span>Syncing Mode</a></li><li id="_sidebar_4.5"><a href="#sec-Caught-Up-Mode"><span class="spec-secid">4.5</span>Caught Up Mode</a></li><li id="_sidebar_4.6"><a href="#sec-Maintaining-a-fresh-Peer-Set"><span class="spec-secid">4.6</span>Maintaining a fresh Peer Set</a></li><li id="_sidebar_4.7"><a href="#sec-Chain-Syncing.Dependencies"><span class="spec-secid">4.7</span>Dependencies</a></li><li id="_sidebar_4.8"><a href="#sec-Chain-Syncing.Open-Questions"><span class="spec-secid">4.8</span>Open Questions</a></li></ol></li><li id="_sidebar_5"><a href="#sec-The-Filecoin-Storage-Market"><span class="spec-secid">5</span>The Filecoin Storage Market</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_5" /><label for="_sidebar_toggle_5"></label><ol><li id="_sidebar_5.1"><a href="#sec-What-is-the-Filecoin-Storage-Market"><span class="spec-secid">5.1</span>What is the Filecoin Storage Market</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_5.1" /><label for="_sidebar_toggle_5.1"></label><ol><li id="_sidebar_5.1.1"><a href="#sec-Visualization-of-the-Filecoin-Storage-Market"><span class="spec-secid">5.1.1</span>Visualization of the Filecoin Storage Market</a></li></ol></li><li id="_sidebar_5.2"><a href="#sec-The-Market-Interface"><span class="spec-secid">5.2</span>The Market Interface</a></li><li id="_sidebar_5.3"><a href="#sec-The-Filecoin-Storage-Market-Operation"><span class="spec-secid">5.3</span>The Filecoin Storage Market Operation</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_5.3" /><label for="_sidebar_toggle_5.3"></label><ol><li id="_sidebar_5.3.1"><a href="#sec-Market-Datastructures"><span class="spec-secid">5.3.1</span>Market Datastructures</a></li></ol></li><li id="_sidebar_5.4"><a href="#sec-Market-Flow"><span class="spec-secid">5.4</span>Market Flow</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_5.4" /><label for="_sidebar_toggle_5.4"></label><ol><li id="_sidebar_5.4.1"><a href="#sec-Before-Deal"><span class="spec-secid">5.4.1</span>Before Deal</a></li><li id="_sidebar_5.4.2"><a href="#sec-Market-Flow.Deal"><span class="spec-secid">5.4.2</span>Deal</a></li></ol></li><li id="_sidebar_5.5"><a href="#sec-The-Power-Table"><span class="spec-secid">5.5</span>The Power Table</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_5.5" /><label for="_sidebar_toggle_5.5"></label><ol><li id="_sidebar_5.5.1"><a href="#sec-Power-Updates"><span class="spec-secid">5.5.1</span>Power Updates</a></li></ol></li><li id="_sidebar_5.6"><a href="#sec-The-Filecoin-Storage-Market.Payments"><span class="spec-secid">5.6</span>Payments</a></li><li id="_sidebar_5.7"><a href="#sec-Future-Protocol-Improvements"><span class="spec-secid">5.7</span>Future Protocol Improvements</a></li><li id="_sidebar_5.8"><a href="#sec-Open-questions"><span class="spec-secid">5.8</span>Open questions</a></li></ol></li><li id="_sidebar_6"><a href="#sec--Retrieval-Market-V0"><span class="spec-secid">6</span>`Retrieval Market` V0</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_6" /><label for="_sidebar_toggle_6"></label><ol><li id="_sidebar_6.1"><a href="#sec-What-is-the-Retrieval-Market-"><span class="spec-secid">6.1</span>What is the `Retrieval Market`</a></li><li id="_sidebar_6.2"><a href="#sec-What-the-Retrieval-Market-affects"><span class="spec-secid">6.2</span>What the `Retrieval Market` affects</a></li><li id="_sidebar_6.3"><a href="#sec--Retrieval-Market-V0.Dependencies"><span class="spec-secid">6.3</span>Dependencies</a></li><li id="_sidebar_6.4"><a href="#sec-Components"><span class="spec-secid">6.4</span>Components</a></li><li id="_sidebar_6.5"><a href="#sec-Retrieval-V0-libp2p-Services"><span class="spec-secid">6.5</span>Retrieval V0 `libp2p` Services</a></li><li id="_sidebar_6.6"><a href="#sec-Chain-Based-Content-Routing"><span class="spec-secid">6.6</span>Chain Based Content Routing</a></li><li id="_sidebar_6.7"><a href="#sec-Retrieval-Market-Commands"><span class="spec-secid">6.7</span>Retrieval Market Commands</a></li></ol></li><li id="_sidebar_7"><a href="#sec-undefined.Payments"><span class="spec-secid">7</span>Payments</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_7" /><label for="_sidebar_toggle_7"></label><ol><li id="_sidebar_7.1"><a href="#sec-What-are-payments"><span class="spec-secid">7.1</span>What are payments</a></li><li id="_sidebar_7.2"><a href="#sec-What-payments-affect"><span class="spec-secid">7.2</span>What payments affect</a></li><li id="_sidebar_7.3"><a href="#sec-undefined.Payments.Dependencies"><span class="spec-secid">7.3</span>Dependencies</a></li><li id="_sidebar_7.4"><a href="#sec-Miners-Claiming-Earnings"><span class="spec-secid">7.4</span>Miners Claiming Earnings</a></li><li id="_sidebar_7.5"><a href="#sec-Payment-Channels"><span class="spec-secid">7.5</span>Payment Channels</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_7.5" /><label for="_sidebar_toggle_7.5"></label><ol><li id="_sidebar_7.5.1"><a href="#sec-Multi-Lane-Payment-Channel"><span class="spec-secid">7.5.1</span>Multi-Lane Payment Channel</a></li><li id="_sidebar_7.5.2"><a href="#sec-Payment-Channel-Reconciliation"><span class="spec-secid">7.5.2</span>Payment Channel Reconciliation</a></li></ol></li></ol></li><li id="_sidebar_8"><a href="#sec-Payment-Reconciliation"><span class="spec-secid">8</span>Payment Reconciliation</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_8" /><label for="_sidebar_toggle_8"></label><ol><li id="_sidebar_8.1"><a href="#sec-Storage-Miner-Payments"><span class="spec-secid">8.1</span>Storage Miner Payments</a></li></ol></li><li id="_sidebar_9"><a href="#sec-undefined.Mining"><span class="spec-secid">9</span>Mining</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_9" /><label for="_sidebar_toggle_9"></label><ol><li id="_sidebar_9.1"><a href="#sec-What-is-the-Filecoin-Mining-Process"><span class="spec-secid">9.1</span>What is the Filecoin Mining Process</a></li><li id="_sidebar_9.2"><a href="#sec-The-Miner-Actor"><span class="spec-secid">9.2</span>The Miner Actor</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_9.2" /><label for="_sidebar_toggle_9.2"></label><ol><li id="_sidebar_9.2.1"><a href="#sec-Owner-Worker-distinction"><span class="spec-secid">9.2.1</span>Owner Worker distinction</a></li><li id="_sidebar_9.2.2"><a href="#sec-Storage-Mining-Cycle"><span class="spec-secid">9.2.2</span>Storage Mining Cycle</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_9.2.2" /><label for="_sidebar_toggle_9.2.2"></label><ol><li id="_sidebar_9.2.2.1"><a href="#sec-Step-0-Registration"><span class="spec-secid">9.2.2.1</span>Step 0: Registration</a></li><li id="_sidebar_9.2.2.2"><a href="#sec-Step-1-Commit"><span class="spec-secid">9.2.2.2</span>Step 1: Commit</a></li><li id="_sidebar_9.2.2.3"><a href="#sec-Step-2-Proving-Storage-PoSt-creation-"><span class="spec-secid">9.2.2.3</span>Step 2: Proving Storage (PoSt creation)</a></li><li id="_sidebar_9.2.2.4"><a href="#sec-Step-3-PoSt-Submission"><span class="spec-secid">9.2.2.4</span>Step 3: PoSt Submission</a></li></ol></li><li id="_sidebar_9.2.3"><a href="#sec-Stop-Mining"><span class="spec-secid">9.2.3</span>Stop Mining</a></li><li id="_sidebar_9.2.4"><a href="#sec-The-Miner-Actor.Faults"><span class="spec-secid">9.2.4</span>Faults</a></li><li id="_sidebar_9.2.5"><a href="#sec-On-Being-Slashed-WIP-needs-discussion-"><span class="spec-secid">9.2.5</span>On Being Slashed (WIP, needs discussion)</a></li></ol></li><li id="_sidebar_9.3"><a href="#sec-Mining-Blocks"><span class="spec-secid">9.3</span>Mining Blocks</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_9.3" /><label for="_sidebar_toggle_9.3"></label><ol><li id="_sidebar_9.3.1"><a href="#sec-Receiving-Blocks"><span class="spec-secid">9.3.1</span>Receiving Blocks</a></li><li id="_sidebar_9.3.2"><a href="#sec-Block-Validation"><span class="spec-secid">9.3.2</span>Block Validation</a></li><li id="_sidebar_9.3.3"><a href="#sec-Ticket-Generation"><span class="spec-secid">9.3.3</span>Ticket Generation</a></li><li id="_sidebar_9.3.4"><a href="#sec-Scratching-a-losing-ticket"><span class="spec-secid">9.3.4</span>Scratching a losing ticket</a></li><li id="_sidebar_9.3.5"><a href="#sec-Block-Creation"><span class="spec-secid">9.3.5</span>Block Creation</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_9.3.5" /><label for="_sidebar_toggle_9.3.5"></label><ol><li id="_sidebar_9.3.5.1"><a href="#sec-Block-Broadcast"><span class="spec-secid">9.3.5.1</span>Block Broadcast</a></li></ol></li><li id="_sidebar_9.3.6"><a href="#sec-Block-Rewards"><span class="spec-secid">9.3.6</span>Block Rewards</a></li></ol></li><li id="_sidebar_9.4"><a href="#sec-undefined.Mining.Open-Questions"><span class="spec-secid">9.4</span>Open Questions</a></li><li id="_sidebar_9.5"><a href="#sec-Future-Work"><span class="spec-secid">9.5</span>Future Work</a></li></ol></li><li id="_sidebar_10"><a href="#sec-Expected-Consensus"><span class="spec-secid">10</span>Expected Consensus</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_10" /><label for="_sidebar_toggle_10"></label><ol><li id="_sidebar_10.1"><a href="#sec-Secret-Leader-Election"><span class="spec-secid">10.1</span>Secret Leader Election</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_10.1" /><label for="_sidebar_toggle_10.1"></label><ol><li id="_sidebar_10.1.1"><a href="#sec-Tickets"><span class="spec-secid">10.1.1</span>Tickets</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_10.1.1" /><label for="_sidebar_toggle_10.1.1"></label><ol><li id="_sidebar_10.1.1.1"><a href="#sec-Ticket-generation"><span class="spec-secid">10.1.1.1</span>Ticket generation</a></li><li id="_sidebar_10.1.1.2"><a href="#sec-Checking-election-results"><span class="spec-secid">10.1.1.2</span>Checking election results</a></li></ol></li><li id="_sidebar_10.1.2"><a href="#sec-Losing-Tickets"><span class="spec-secid">10.1.2</span>Losing Tickets</a></li><li id="_sidebar_10.1.3"><a href="#sec-Block-Generation"><span class="spec-secid">10.1.3</span>Block Generation</a></li></ol></li><li id="_sidebar_10.2"><a href="#sec-Chain-Selection"><span class="spec-secid">10.2</span>Chain Selection</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_10.2" /><label for="_sidebar_toggle_10.2"></label><ol><li id="_sidebar_10.2.1"><a href="#sec-Tipsets"><span class="spec-secid">10.2.1</span>Tipsets</a></li><li id="_sidebar_10.2.2"><a href="#sec-Chain-Weighting"><span class="spec-secid">10.2.2</span>Chain Weighting</a></li><li id="_sidebar_10.2.3"><a href="#sec-Selecting-between-TipSets-with-equal-weight"><span class="spec-secid">10.2.3</span>Selecting between TipSets with equal weight</a></li><li id="_sidebar_10.2.4"><a href="#sec-Chain-Selection.Slashing"><span class="spec-secid">10.2.4</span>Slashing</a></li><li id="_sidebar_10.2.5"><a href="#sec-ChainTipsManager"><span class="spec-secid">10.2.5</span>ChainTipsManager</a></li></ol></li><li id="_sidebar_10.3"><a href="#sec-Implementation-Notes"><span class="spec-secid">10.3</span>Implementation Notes</a></li><li id="_sidebar_10.4"><a href="#sec-Expected-Consensus.Open-Questions"><span class="spec-secid">10.4</span>Open Questions</a></li></ol></li><li id="_sidebar_11"><a href="#sec-The-Filecoin-State-Machine"><span class="spec-secid">11</span>The Filecoin State Machine</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_11" /><label for="_sidebar_toggle_11"></label><ol><li id="_sidebar_11.1"><a href="#sec-Method-Invocation"><span class="spec-secid">11.1</span>Method Invocation</a></li><li id="_sidebar_11.2"><a href="#sec-State-Representation"><span class="spec-secid">11.2</span>State Representation</a></li><li id="_sidebar_11.3"><a href="#sec-Execution-Calling-a-method-on-an-Actor-"><span class="spec-secid">11.3</span>Execution (Calling a method on an Actor)</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_11.3" /><label for="_sidebar_toggle_11.3"></label><ol><li id="_sidebar_11.3.1"><a href="#sec-Receipts"><span class="spec-secid">11.3.1</span>Receipts</a></li><li id="_sidebar_11.3.2"><a href="#sec-Execution-Calling-a-method-on-an-Actor-.Storage"><span class="spec-secid">11.3.2</span>Storage</a></li></ol></li></ol></li><li id="_sidebar_12"><a href="#sec-Filecoin-State-Machine-Actors"><span class="spec-secid">12</span>Filecoin State Machine Actors</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_12" /><label for="_sidebar_toggle_12"></label><ol><li id="_sidebar_12.1"><a href="#sec-Built-In-Actors"><span class="spec-secid">12.1</span>Built In Actors</a></li><li id="_sidebar_12.2"><a href="#sec-Init-Actor"><span class="spec-secid">12.2</span>Init Actor</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_12.2" /><label for="_sidebar_toggle_12.2"></label><ol><li id="_sidebar_12.2.1"><a href="#sec-Init-Actor.Code-Cid"><span class="spec-secid">12.2.1</span>Code Cid</a></li><li id="_sidebar_12.2.2"><a href="#sec--Exec-code-Cid-params-Param-Address-"><span class="spec-secid">12.2.2</span>`Exec(code Cid, params []Param) Address`</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_12.2.2" /><label for="_sidebar_toggle_12.2.2"></label><ol><li id="_sidebar_12.2.2.1"><a href="#sec--Exec-code-Cid-params-Param-Address-.Parameters"><span class="spec-secid">12.2.2.1</span>Parameters</a></li></ol></li><li id="_sidebar_12.2.3"><a href="#sec--GetIdForAddress-addr-Address-BigInt-"><span class="spec-secid">12.2.3</span>`GetIdForAddress(addr Address) BigInt`</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_12.2.3" /><label for="_sidebar_toggle_12.2.3"></label><ol><li id="_sidebar_12.2.3.1"><a href="#sec--GetIdForAddress-addr-Address-BigInt-.Parameters"><span class="spec-secid">12.2.3.1</span>Parameters</a></li></ol></li></ol></li><li id="_sidebar_12.3"><a href="#sec-Account-Actor"><span class="spec-secid">12.3</span>Account Actor</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_12.3" /><label for="_sidebar_toggle_12.3"></label><ol><li id="_sidebar_12.3.1"><a href="#sec-Account-Actor.Code-Cid"><span class="spec-secid">12.3.1</span>Code Cid</a></li></ol></li><li id="_sidebar_12.4"><a href="#sec-Storage-Market-Actor"><span class="spec-secid">12.4</span>Storage Market Actor</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_12.4" /><label for="_sidebar_toggle_12.4"></label><ol><li id="_sidebar_12.4.1"><a href="#sec-Storage-Market-Actor.Code-Cid"><span class="spec-secid">12.4.1</span>Code Cid</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_12.4.1" /><label for="_sidebar_toggle_12.4.1"></label><ol><li id="_sidebar_12.4.1.1"><a href="#sec-CreateStorageMiner"><span class="spec-secid">12.4.1.1</span>CreateStorageMiner</a></li></ol></li><li id="_sidebar_12.4.2"><a href="#sec-SlashConsensusFault"><span class="spec-secid">12.4.2</span>SlashConsensusFault</a></li><li id="_sidebar_12.4.3"><a href="#sec-UpdateStorage"><span class="spec-secid">12.4.3</span>UpdateStorage</a></li><li id="_sidebar_12.4.4"><a href="#sec-GetTotalStorage"><span class="spec-secid">12.4.4</span>GetTotalStorage</a></li></ol></li><li id="_sidebar_12.5"><a href="#sec-Storage-Miner-Actor"><span class="spec-secid">12.5</span>Storage Miner Actor</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_12.5" /><label for="_sidebar_toggle_12.5"></label><ol><li id="_sidebar_12.5.1"><a href="#sec-Storage-Miner-Actor.Code-Cid"><span class="spec-secid">12.5.1</span>Code Cid</a></li><li id="_sidebar_12.5.2"><a href="#sec-Storage-Miner-Actor.Constructor"><span class="spec-secid">12.5.2</span>Constructor</a></li><li id="_sidebar_12.5.3"><a href="#sec-AddAsk"><span class="spec-secid">12.5.3</span>AddAsk</a></li><li id="_sidebar_12.5.4"><a href="#sec-CommitSector"><span class="spec-secid">12.5.4</span>CommitSector</a></li><li id="_sidebar_12.5.5"><a href="#sec-SubmitPoSt"><span class="spec-secid">12.5.5</span>SubmitPoSt</a></li><li id="_sidebar_12.5.6"><a href="#sec-IncreasePledge"><span class="spec-secid">12.5.6</span>IncreasePledge</a></li><li id="_sidebar_12.5.7"><a href="#sec-SlashStorageFault"><span class="spec-secid">12.5.7</span>SlashStorageFault</a></li><li id="_sidebar_12.5.8"><a href="#sec-GetCurrentProvingSet"><span class="spec-secid">12.5.8</span>GetCurrentProvingSet</a></li><li id="_sidebar_12.5.9"><a href="#sec-ArbitrateDeal"><span class="spec-secid">12.5.9</span>ArbitrateDeal</a></li><li id="_sidebar_12.5.10"><a href="#sec-DePledge"><span class="spec-secid">12.5.10</span>DePledge</a></li><li id="_sidebar_12.5.11"><a href="#sec-GetOwner"><span class="spec-secid">12.5.11</span>GetOwner</a></li><li id="_sidebar_12.5.12"><a href="#sec-GetWorkerAddr"><span class="spec-secid">12.5.12</span>GetWorkerAddr</a></li><li id="_sidebar_12.5.13"><a href="#sec-GetPower"><span class="spec-secid">12.5.13</span>GetPower</a></li><li id="_sidebar_12.5.14"><a href="#sec-GetKey"><span class="spec-secid">12.5.14</span>GetKey</a></li><li id="_sidebar_12.5.15"><a href="#sec-GetPeerID"><span class="spec-secid">12.5.15</span>GetPeerID</a></li><li id="_sidebar_12.5.16"><a href="#sec-GetSectorSize"><span class="spec-secid">12.5.16</span>GetSectorSize</a></li><li id="_sidebar_12.5.17"><a href="#sec-UpdatePeerID"><span class="spec-secid">12.5.17</span>UpdatePeerID</a></li></ol></li><li id="_sidebar_12.6"><a href="#sec-Payment-Channel-Broker-Actor"><span class="spec-secid">12.6</span>Payment Channel Broker Actor</a></li><li id="_sidebar_12.7"><a href="#sec-Multisig-Account-Actor"><span class="spec-secid">12.7</span>Multisig Account Actor</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_12.7" /><label for="_sidebar_toggle_12.7"></label><ol><li id="_sidebar_12.7.1"><a href="#sec-Multisig-Account-Actor.State"><span class="spec-secid">12.7.1</span>State</a></li><li id="_sidebar_12.7.2"><a href="#sec-Multisig-Account-Actor.Code-Cid"><span class="spec-secid">12.7.2</span>Code Cid</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_12.7.2" /><label for="_sidebar_toggle_12.7.2"></label><ol><li id="_sidebar_12.7.2.1"><a href="#sec-Multisig-Account-Actor.Code-Cid.Constructor"><span class="spec-secid">12.7.2.1</span>Constructor</a></li><li id="_sidebar_12.7.2.2"><a href="#sec-Multisig-Account-Actor.Code-Cid.Parameters"><span class="spec-secid">12.7.2.2</span>Parameters</a></li></ol></li><li id="_sidebar_12.7.3"><a href="#sec-Propose"><span class="spec-secid">12.7.3</span>Propose</a></li><li id="_sidebar_12.7.4"><a href="#sec-Approve"><span class="spec-secid">12.7.4</span>Approve</a></li><li id="_sidebar_12.7.5"><a href="#sec-Cancel"><span class="spec-secid">12.7.5</span>Cancel</a></li><li id="_sidebar_12.7.6"><a href="#sec-ClearCompleted"><span class="spec-secid">12.7.6</span>ClearCompleted</a></li><li id="_sidebar_12.7.7"><a href="#sec-AddSigner"><span class="spec-secid">12.7.7</span>AddSigner</a></li><li id="_sidebar_12.7.8"><a href="#sec-RemoveSigner"><span class="spec-secid">12.7.8</span>RemoveSigner</a></li><li id="_sidebar_12.7.9"><a href="#sec-SwapSigner"><span class="spec-secid">12.7.9</span>SwapSigner</a></li><li id="_sidebar_12.7.10"><a href="#sec-ChangeRequirement"><span class="spec-secid">12.7.10</span>ChangeRequirement</a></li><li id="_sidebar_12.7.11"><a href="#sec-Helper-Methods"><span class="spec-secid">12.7.11</span>Helper Methods</a></li></ol></li></ol></li><li id="_sidebar_13"><a href="#sec-undefined.Faults"><span class="spec-secid">13</span>Faults</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_13" /><label for="_sidebar_toggle_13"></label><ol><li id="_sidebar_13.1"><a href="#sec-Fault-List"><span class="spec-secid">13.1</span>Fault List</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_13.1" /><label for="_sidebar_toggle_13.1"></label><ol><li id="_sidebar_13.1.1"><a href="#sec-Consensus-Faults"><span class="spec-secid">13.1.1</span>Consensus Faults</a></li><li id="_sidebar_13.1.2"><a href="#sec-Market-Faults"><span class="spec-secid">13.1.2</span>Market Faults</a></li></ol></li></ol></li><li id="_sidebar_14"><a href="#sec-Signatures"><span class="spec-secid">14</span>Signatures</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_14" /><label for="_sidebar_toggle_14"></label><ol><li id="_sidebar_14.1"><a href="#sec-What-are-signatures-in-Filecoin"><span class="spec-secid">14.1</span>What are signatures in Filecoin</a></li><li id="_sidebar_14.2"><a href="#sec-What-signatures-affect"><span class="spec-secid">14.2</span>What signatures affect</a></li><li id="_sidebar_14.3"><a href="#sec-Signatures.Dependencies"><span class="spec-secid">14.3</span>Dependencies</a></li><li id="_sidebar_14.4"><a href="#sec-Non-Dependencies"><span class="spec-secid">14.4</span>Non-Dependencies</a></li><li id="_sidebar_14.5"><a href="#sec-Signatures.Interface"><span class="spec-secid">14.5</span>Interface</a></li><li id="_sidebar_14.6"><a href="#sec-Selected-Signature-Scheme"><span class="spec-secid">14.6</span>Selected Signature Scheme</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_14.6" /><label for="_sidebar_toggle_14.6"></label><ol><li id="_sidebar_14.6.1"><a href="#sec-Wire-Format"><span class="spec-secid">14.6.1</span>Wire Format</a></li><li id="_sidebar_14.6.2"><a href="#sec-Github"><span class="spec-secid">14.6.2</span>Github</a></li><li id="_sidebar_14.6.3"><a href="#sec-External-References"><span class="spec-secid">14.6.3</span>External References</a></li><li id="_sidebar_14.6.4"><a href="#sec-References"><span class="spec-secid">14.6.4</span>References</a></li><li id="_sidebar_14.6.5"><a href="#sec-Inspiration"><span class="spec-secid">14.6.5</span>Inspiration</a></li></ol></li></ol></li><li id="_sidebar_15"><a href="#sec-Filecoin-Proofs"><span class="spec-secid">15</span>Filecoin Proofs</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_15" /><label for="_sidebar_toggle_15"></label><ol><li id="_sidebar_15.1"><a href="#sec-Filecoin-Proofs.Proof-of-Replication"><span class="spec-secid">15.1</span>Proof of Replication</a></li><li id="_sidebar_15.2"><a href="#sec-Seal"><span class="spec-secid">15.2</span>Seal</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_15.2" /><label for="_sidebar_toggle_15.2"></label><ol><li id="_sidebar_15.2.1"><a href="#sec-VerifySeal"><span class="spec-secid">15.2.1</span>VerifySeal</a></li><li id="_sidebar_15.2.2"><a href="#sec-Unseal"><span class="spec-secid">15.2.2</span>Unseal</a></li><li id="_sidebar_15.2.3"><a href="#sec-Security-Notes"><span class="spec-secid">15.2.3</span>Security Notes</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_15.2.3" /><label for="_sidebar_toggle_15.2.3"></label><ol><li id="_sidebar_15.2.3.1"><a href="#sec-Guaranteeing-sector-uniqueness"><span class="spec-secid">15.2.3.1</span>Guaranteeing sector uniqueness</a></li></ol></li></ol></li><li id="_sidebar_15.3"><a href="#sec-Proof-of-Space-Time"><span class="spec-secid">15.3</span>Proof of Space-Time</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_15.3" /><label for="_sidebar_toggle_15.3"></label><ol><li id="_sidebar_15.3.1"><a href="#sec-GeneratePost"><span class="spec-secid">15.3.1</span>GeneratePost</a></li><li id="_sidebar_15.3.2"><a href="#sec-VerifyPoSt"><span class="spec-secid">15.3.2</span>VerifyPoSt</a></li></ol></li><li id="_sidebar_15.4"><a href="#sec-Filecoin-Proofs.Piece-Inclusion-Proof"><span class="spec-secid">15.4</span>Piece Inclusion Proof</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_15.4" /><label for="_sidebar_toggle_15.4"></label><ol><li id="_sidebar_15.4.1"><a href="#sec-PieceInclusionProof"><span class="spec-secid">15.4.1</span>PieceInclusionProof</a></li><li id="_sidebar_15.4.2"><a href="#sec-GeneratePieceInclusionProofs"><span class="spec-secid">15.4.2</span>GeneratePieceInclusionProofs</a></li></ol></li></ol></li><li id="_sidebar_16"><a href="#sec-Filecoin-Network-Protocols"><span class="spec-secid">16</span>Filecoin Network Protocols</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_16" /><label for="_sidebar_toggle_16"></label><ol><li id="_sidebar_16.1"><a href="#sec-CBOR-RPC"><span class="spec-secid">16.1</span>CBOR RPC</a></li><li id="_sidebar_16.2"><a href="#sec-Hello-Handshake"><span class="spec-secid">16.2</span>Hello Handshake</a></li><li id="_sidebar_16.3"><a href="#sec-Storage-Deal"><span class="spec-secid">16.3</span>Storage Deal</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_16.3" /><label for="_sidebar_toggle_16.3"></label><ol><li id="_sidebar_16.3.1"><a href="#sec-Deal-State-Values"><span class="spec-secid">16.3.1</span>Deal State Values</a></li></ol></li><li id="_sidebar_16.4"><a href="#sec-Query"><span class="spec-secid">16.4</span>Query</a></li><li id="_sidebar_16.5"><a href="#sec-Retrieve-Piece-for-Free"><span class="spec-secid">16.5</span>Retrieve Piece for Free</a></li><li id="_sidebar_16.6"><a href="#sec-BlockSync"><span class="spec-secid">16.6</span>BlockSync</a></li></ol></li><li id="_sidebar_17"><a href="#sec-Filecoin-Data-Propagation"><span class="spec-secid">17</span>Filecoin Data Propagation</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_17" /><label for="_sidebar_toggle_17"></label><ol><li id="_sidebar_17.1"><a href="#sec-Links"><span class="spec-secid">17.1</span>Links</a></li><li id="_sidebar_17.2"><a href="#sec-Block-Propagation"><span class="spec-secid">17.2</span>Block Propagation</a></li><li id="_sidebar_17.3"><a href="#sec-Message-Propagation"><span class="spec-secid">17.3</span>Message Propagation</a></li></ol></li><li id="_sidebar_18"><a href="#sec-Data-Structures"><span class="spec-secid">18</span>Data Structures</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_18" /><label for="_sidebar_toggle_18"></label><ol><li id="_sidebar_18.1"><a href="#sec-Data-Structures.Address"><span class="spec-secid">18.1</span>Address</a></li><li id="_sidebar_18.2"><a href="#sec-CID"><span class="spec-secid">18.2</span>CID</a></li><li id="_sidebar_18.3"><a href="#sec-Data-Structures.Block"><span class="spec-secid">18.3</span>Block</a></li><li id="_sidebar_18.4"><a href="#sec-Data-Structures.Message"><span class="spec-secid">18.4</span>Message</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_18.4" /><label for="_sidebar_toggle_18.4"></label><ol><li id="_sidebar_18.4.1"><a href="#sec-Parameter-Encoding"><span class="spec-secid">18.4.1</span>Parameter Encoding</a></li><li id="_sidebar_18.4.2"><a href="#sec-Signing"><span class="spec-secid">18.4.2</span>Signing</a></li></ol></li><li id="_sidebar_18.5"><a href="#sec-Message-Receipt"><span class="spec-secid">18.5</span>Message Receipt</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_18.5" /><label for="_sidebar_toggle_18.5"></label><ol><li id="_sidebar_18.5.1"><a href="#sec-Message-Receipt.Serialization"><span class="spec-secid">18.5.1</span>Serialization</a></li></ol></li><li id="_sidebar_18.6"><a href="#sec-Data-Structures.Actor"><span class="spec-secid">18.6</span>Actor</a></li><li id="_sidebar_18.7"><a href="#sec-State-Tree"><span class="spec-secid">18.7</span>State Tree</a></li><li id="_sidebar_18.8"><a href="#sec-HAMT"><span class="spec-secid">18.8</span>HAMT</a></li><li id="_sidebar_18.9"><a href="#sec-Signature"><span class="spec-secid">18.9</span>Signature</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_18.9" /><label for="_sidebar_toggle_18.9"></label><ol><li id="_sidebar_18.9.1"><a href="#sec--Type-Values"><span class="spec-secid">18.9.1</span>`Type` Values</a></li><li id="_sidebar_18.9.2"><a href="#sec-Signature.Serialization"><span class="spec-secid">18.9.2</span>Serialization</a></li></ol></li><li id="_sidebar_18.10"><a href="#sec-Basic-Type-Encodings"><span class="spec-secid">18.10</span>Basic Type Encodings</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_18.10" /><label for="_sidebar_toggle_18.10"></label><ol><li id="_sidebar_18.10.1"><a href="#sec--PublicKey-"><span class="spec-secid">18.10.1</span>`PublicKey`</a></li><li id="_sidebar_18.10.2"><a href="#sec--BytesAmount-"><span class="spec-secid">18.10.2</span>`BytesAmount`</a></li><li id="_sidebar_18.10.3"><a href="#sec--PeerID-"><span class="spec-secid">18.10.3</span>`PeerID`</a></li><li id="_sidebar_18.10.4"><a href="#sec--Integer-"><span class="spec-secid">18.10.4</span>`Integer`</a></li><li id="_sidebar_18.10.5"><a href="#sec--BitField-"><span class="spec-secid">18.10.5</span>`BitField`</a></li><li id="_sidebar_18.10.6"><a href="#sec--SectorSet-"><span class="spec-secid">18.10.6</span>`SectorSet`</a></li><li id="_sidebar_18.10.7"><a href="#sec--FaultSet-"><span class="spec-secid">18.10.7</span>`FaultSet`</a></li><li id="_sidebar_18.10.8"><a href="#sec--BlockHeader-"><span class="spec-secid">18.10.8</span>`BlockHeader`</a></li><li id="_sidebar_18.10.9"><a href="#sec--SealProof-"><span class="spec-secid">18.10.9</span>`SealProof`</a></li><li id="_sidebar_18.10.10"><a href="#sec--PoStProof-"><span class="spec-secid">18.10.10</span>`PoStProof`</a></li><li id="_sidebar_18.10.11"><a href="#sec--TokenAmount-"><span class="spec-secid">18.10.11</span>`TokenAmount`</a></li></ol></li><li id="_sidebar_18.11"><a href="#sec-LEB128-Encoding-Reference"><span class="spec-secid">18.11</span>LEB128 Encoding Reference</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_18.11" /><label for="_sidebar_toggle_18.11"></label><ol><li id="_sidebar_18.11.1"><a href="#sec-Encode-unsigned-LEB128"><span class="spec-secid">18.11.1</span>Encode unsigned LEB128</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_18.11.1" /><label for="_sidebar_toggle_18.11.1"></label><ol><li id="_sidebar_18.11.1.1"><a href="#sec-Encode-signed-LEB128"><span class="spec-secid">18.11.1.1</span>Encode signed LEB128</a></li><li id="_sidebar_18.11.1.2"><a href="#sec-Decode-unsigned-LEB128"><span class="spec-secid">18.11.1.2</span>Decode unsigned LEB128</a></li><li id="_sidebar_18.11.1.3"><a href="#sec-Decode-signed-LEB128"><span class="spec-secid">18.11.1.3</span>Decode signed LEB128</a></li></ol></li></ol></li><li id="_sidebar_18.12"><a href="#sec-Filecoin-Compact-Serialization"><span class="spec-secid">18.12</span>Filecoin Compact Serialization</a></li><li id="_sidebar_18.13"><a href="#sec-Encoding-Considerations"><span class="spec-secid">18.13</span>Encoding Considerations</a></li><li id="_sidebar_18.14"><a href="#sec-IPLD-Considerations"><span class="spec-secid">18.14</span>IPLD Considerations</a></li><li id="_sidebar_18.15"><a href="#sec-Vectors"><span class="spec-secid">18.15</span>Vectors</a></li></ol></li><li id="_sidebar_19"><a href="#sec-Filecoin-Node-Local-Storage"><span class="spec-secid">19</span>Filecoin Node Local Storage</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_19" /><label for="_sidebar_toggle_19"></label><ol><li id="_sidebar_19.1"><a href="#sec-Chain-Data"><span class="spec-secid">19.1</span>Chain Data</a></li><li id="_sidebar_19.2"><a href="#sec-Private-Keys"><span class="spec-secid">19.2</span>Private Keys</a></li><li id="_sidebar_19.3"><a href="#sec-Sectors"><span class="spec-secid">19.3</span>Sectors</a></li><li id="_sidebar_19.4"><a href="#sec-Storage-Deals"><span class="spec-secid">19.4</span>Storage Deals</a></li></ol></li><li id="_sidebar_20"><a href="#sec-Definitions-Glossary"><span class="spec-secid">20</span>Definitions / Glossary</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_20" /><label for="_sidebar_toggle_20"></label><ol><li id="_sidebar_20.1"><a href="#sec-Updates-to-definitions"><span class="spec-secid">20.1</span>Updates to definitions</a></li><li id="_sidebar_20.2"><a href="#sec-Notes"><span class="spec-secid">20.2</span>Notes</a></li><li id="_sidebar_20.3"><a href="#sec-Definitions"><span class="spec-secid">20.3</span>Definitions</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_20.3" /><label for="_sidebar_toggle_20.3"></label><ol><li id="_sidebar_20.3.1"><a href="#sec-Definitions.Actor"><span class="spec-secid">20.3.1</span>Actor</a></li><li id="_sidebar_20.3.2"><a href="#sec-Definitions.Address"><span class="spec-secid">20.3.2</span>Address</a></li><li id="_sidebar_20.3.3"><a href="#sec-Ask"><span class="spec-secid">20.3.3</span>Ask</a></li><li id="_sidebar_20.3.4"><a href="#sec-Bid"><span class="spec-secid">20.3.4</span>Bid</a></li><li id="_sidebar_20.3.5"><a href="#sec-Definitions.Block"><span class="spec-secid">20.3.5</span>Block</a></li><li id="_sidebar_20.3.6"><a href="#sec-Bootstrapping"><span class="spec-secid">20.3.6</span>Bootstrapping</a></li><li id="_sidebar_20.3.7"><a href="#sec-Chain-weight"><span class="spec-secid">20.3.7</span>Chain weight</a></li><li id="_sidebar_20.3.8"><a href="#sec-Challenge-sampling"><span class="spec-secid">20.3.8</span>Challenge sampling</a></li><li id="_sidebar_20.3.9"><a href="#sec-Cid"><span class="spec-secid">20.3.9</span>Cid</a></li><li id="_sidebar_20.3.10"><a href="#sec-Client"><span class="spec-secid">20.3.10</span>Client</a></li><li id="_sidebar_20.3.11"><a href="#sec-Collateral"><span class="spec-secid">20.3.11</span>Collateral</a></li><li id="_sidebar_20.3.12"><a href="#sec-Commitment"><span class="spec-secid">20.3.12</span>Commitment</a></li><li id="_sidebar_20.3.13"><a href="#sec-Confirmation"><span class="spec-secid">20.3.13</span>Confirmation</a></li><li id="_sidebar_20.3.14"><a href="#sec-Consensus"><span class="spec-secid">20.3.14</span>Consensus</a></li><li id="_sidebar_20.3.15"><a href="#sec-Definitions.Deal"><span class="spec-secid">20.3.15</span>Deal</a></li><li id="_sidebar_20.3.16"><a href="#sec-Erasure-coding"><span class="spec-secid">20.3.16</span>Erasure coding</a></li><li id="_sidebar_20.3.17"><a href="#sec-Epoch"><span class="spec-secid">20.3.17</span>Epoch</a></li><li id="_sidebar_20.3.18"><a href="#sec-Fault"><span class="spec-secid">20.3.18</span>Fault</a></li><li id="_sidebar_20.3.19"><a href="#sec-Fair"><span class="spec-secid">20.3.19</span>Fair</a></li><li id="_sidebar_20.3.20"><a href="#sec-File"><span class="spec-secid">20.3.20</span>File</a></li><li id="_sidebar_20.3.21"><a href="#sec-Finality"><span class="spec-secid">20.3.21</span>Finality</a></li><li id="_sidebar_20.3.22"><a href="#sec-Definitions.Piece-Inclusion-Proof"><span class="spec-secid">20.3.22</span>Piece Inclusion Proof</a></li><li id="_sidebar_20.3.23"><a href="#sec-Gas-Fees-Prices"><span class="spec-secid">20.3.23</span>Gas, Fees, Prices</a></li><li id="_sidebar_20.3.24"><a href="#sec-Generation-Attack-Threshold"><span class="spec-secid">20.3.24</span>Generation Attack Threshold</a></li><li id="_sidebar_20.3.25"><a href="#sec-GHOST"><span class="spec-secid">20.3.25</span>GHOST</a></li><li id="_sidebar_20.3.26"><a href="#sec-Leader"><span class="spec-secid">20.3.26</span>Leader</a></li><li id="_sidebar_20.3.27"><a href="#sec-Leader-election"><span class="spec-secid">20.3.27</span>Leader election</a></li><li id="_sidebar_20.3.28"><a href="#sec-Definitions.Message"><span class="spec-secid">20.3.28</span>Message</a></li><li id="_sidebar_20.3.29"><a href="#sec-Miner"><span class="spec-secid">20.3.29</span>Miner</a></li><li id="_sidebar_20.3.30"><a href="#sec-Node"><span class="spec-secid">20.3.30</span>Node</a></li><li id="_sidebar_20.3.31"><a href="#sec-Null-Blocks"><span class="spec-secid">20.3.31</span>Null Blocks</a></li><li id="_sidebar_20.3.32"><a href="#sec-On-chain-off-chain"><span class="spec-secid">20.3.32</span>On-chain/off-chain</a></li><li id="_sidebar_20.3.33"><a href="#sec-Online-offline"><span class="spec-secid">20.3.33</span>Online/offline</a></li><li id="_sidebar_20.3.34"><a href="#sec-Payment-Channel"><span class="spec-secid">20.3.34</span>Payment Channel</a></li><li id="_sidebar_20.3.35"><a href="#sec-Piece"><span class="spec-secid">20.3.35</span>Piece</a></li><li id="_sidebar_20.3.36"><a href="#sec-Pledge"><span class="spec-secid">20.3.36</span>Pledge</a></li><li id="_sidebar_20.3.37"><a href="#sec-Polling-Time"><span class="spec-secid">20.3.37</span>Polling Time</a></li><li id="_sidebar_20.3.38"><a href="#sec-Power-table"><span class="spec-secid">20.3.38</span>Power table</a></li><li id="_sidebar_20.3.39"><a href="#sec-Power-table-lookback"><span class="spec-secid">20.3.39</span>Power table lookback</a></li><li id="_sidebar_20.3.40"><a href="#sec-Protocol"><span class="spec-secid">20.3.40</span>Protocol</a></li><li id="_sidebar_20.3.41"><a href="#sec-Proving-Period"><span class="spec-secid">20.3.41</span>Proving Period</a></li><li id="_sidebar_20.3.42"><a href="#sec-Proving-Set"><span class="spec-secid">20.3.42</span>Proving Set</a></li><li id="_sidebar_20.3.43"><a href="#sec-Definitions.Proof-of-Replication"><span class="spec-secid">20.3.43</span>Proof of Replication</a></li><li id="_sidebar_20.3.44"><a href="#sec-Proof-of-Spacetime"><span class="spec-secid">20.3.44</span>Proof of Spacetime</a></li><li id="_sidebar_20.3.45"><a href="#sec-Random-ness-"><span class="spec-secid">20.3.45</span>Random(ness)</a></li><li id="_sidebar_20.3.46"><a href="#sec-Election-Randomness-Lookback"><span class="spec-secid">20.3.46</span>Election Randomness Lookback</a></li><li id="_sidebar_20.3.47"><a href="#sec-Repair"><span class="spec-secid">20.3.47</span>Repair</a></li><li id="_sidebar_20.3.48"><a href="#sec-Round"><span class="spec-secid">20.3.48</span>Round</a></li><li id="_sidebar_20.3.49"><a href="#sec-SEAL-UNSEAL"><span class="spec-secid">20.3.49</span>SEAL/UNSEAL</a></li><li id="_sidebar_20.3.50"><a href="#sec-Sector"><span class="spec-secid">20.3.50</span>Sector</a></li><li id="_sidebar_20.3.51"><a href="#sec-Definitions.Slashing"><span class="spec-secid">20.3.51</span>Slashing</a></li><li id="_sidebar_20.3.52"><a href="#sec-Smart-contracts"><span class="spec-secid">20.3.52</span>Smart contracts</a></li><li id="_sidebar_20.3.53"><a href="#sec-Definitions.Storage"><span class="spec-secid">20.3.53</span>Storage</a></li><li id="_sidebar_20.3.54"><a href="#sec-Definitions.State"><span class="spec-secid">20.3.54</span>State</a></li><li id="_sidebar_20.3.55"><a href="#sec-Ticket"><span class="spec-secid">20.3.55</span>Ticket</a></li><li id="_sidebar_20.3.56"><a href="#sec-TipSet"><span class="spec-secid">20.3.56</span>TipSet</a></li><li id="_sidebar_20.3.57"><a href="#sec-Verifiable"><span class="spec-secid">20.3.57</span>Verifiable</a></li><li id="_sidebar_20.3.58"><a href="#sec-VM"><span class="spec-secid">20.3.58</span>VM</a></li><li id="_sidebar_20.3.59"><a href="#sec-Voucher"><span class="spec-secid">20.3.59</span>Voucher</a></li><li id="_sidebar_20.3.60"><a href="#sec-zkSNARK"><span class="spec-secid">20.3.60</span>zkSNARK</a></li></ol></li></ol></li><li id="_sidebar_index"><a href="#index"><span class="spec-secid">ยง</span>Index</a></li></ol></div><script>(function (){
var currentSection;
var numberedSections = [];

var sections = document.getElementsByTagName('section');
for (var i = 0; i < sections.length; i++) {
  if (sections[i].getAttribute('secid')) {
    numberedSections.push(sections[i]);
  }
}

var scrollPos = window.scrollY;
var pending = false;
window.addEventListener('scroll', function (e) {
  scrollPos = window.scrollY;
  if (!pending) {
    pending = true;
    window.requestAnimationFrame(function () {
      updateSectionFocus(scrollPos);
      pending = false;
    });
  }
});

function updateSectionFocus(pos) {
  var readLine = pos + document.documentElement.clientHeight / 4;

  var focusedSection;
  for (var n = numberedSections.length - 1; n >= 0; n--) {
    if (numberedSections[n].offsetTop < readLine) {
      focusedSection = numberedSections[n];
      break;
    }
  }

  var secid = focusedSection && focusedSection.getAttribute('secid');
  if (secid !== currentSection) {
    currentSection && fold(currentSection, false);
    secid && fold(secid, true);
    currentSection = secid;
  }
}

function fold(secid, check) {
  document.getElementById('_sidebar_' + secid).className = check ? 'viewing' : '';
  var sections = secid.split('.');
  while (sections.length) {
    var toggle = document.getElementById('_sidebar_toggle_' + sections.join('.'));
    if (toggle) {
      toggle.checked = check;
    }
    sections.pop();
  }
}

updateSectionFocus(window.scrollY);
})()</script></div></body></html>
